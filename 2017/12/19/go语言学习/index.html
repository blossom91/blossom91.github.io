<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="blossom Html Css JavaScript Node Go Python Swift 全端 后端 Ios"><title>go语言学习 | blossom</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.2"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">go语言学习</h1><a id="logo" href="/.">blossom</a><p class="description">good good study and day day up</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">go语言学习</h1><div class="post-meta">Dec 19, 2017<span> | </span><span class="category"><a href="/categories/后端/">后端</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#声明"><span class="toc-number">1.1.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串"><span class="toc-number">1.2.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环"><span class="toc-number">1.3.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-else"><span class="toc-number">1.4.</span> <span class="toc-text">if/else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-number">1.5.</span> <span class="toc-text">switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-number">1.6.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切片slice"><span class="toc-number">1.7.</span> <span class="toc-text">切片slice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关系数组map"><span class="toc-number">1.8.</span> <span class="toc-text">关系数组map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历Rang"><span class="toc-number">1.9.</span> <span class="toc-text">遍历Rang</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON"><span class="toc-number">1.10.</span> <span class="toc-text">JSON</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-number">2.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多返回值"><span class="toc-number">2.1.</span> <span class="toc-text">多返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变参函数"><span class="toc-number">2.2.</span> <span class="toc-text">变参函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包"><span class="toc-number">2.3.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归"><span class="toc-number">2.4.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针"><span class="toc-number">2.5.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体"><span class="toc-number">2.6.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-number">2.7.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口"><span class="toc-number">2.8.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取-interface-变量存储的类型"><span class="toc-number">2.9.</span> <span class="toc-text">获取 interface 变量存储的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反射-不太懂"><span class="toc-number">2.10.</span> <span class="toc-text">反射(不太懂)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误处理"><span class="toc-number">2.11.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序"><span class="toc-number">2.12.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义排序"><span class="toc-number">2.13.</span> <span class="toc-text">自定义排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Panic"><span class="toc-number">2.14.</span> <span class="toc-text">Panic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Defer"><span class="toc-number">2.15.</span> <span class="toc-text">Defer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间"><span class="toc-number">2.16.</span> <span class="toc-text">时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间戳"><span class="toc-number">2.17.</span> <span class="toc-text">时间戳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间的格式化与解析"><span class="toc-number">2.18.</span> <span class="toc-text">时间的格式化与解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数字解析"><span class="toc-number">2.19.</span> <span class="toc-text">数字解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#url-解析"><span class="toc-number">2.20.</span> <span class="toc-text">url 解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#随机数"><span class="toc-number">2.21.</span> <span class="toc-text">随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SHA1-散列"><span class="toc-number">2.22.</span> <span class="toc-text">SHA1 散列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BASE64-编码"><span class="toc-number">2.23.</span> <span class="toc-text">BASE64 编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协程"><span class="toc-number">3.</span> <span class="toc-text">协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通道"><span class="toc-number">3.1.</span> <span class="toc-text">通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通道缓冲"><span class="toc-number">3.2.</span> <span class="toc-text">通道缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通道同步"><span class="toc-number">3.3.</span> <span class="toc-text">通道同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通道方向"><span class="toc-number">3.4.</span> <span class="toc-text">通道方向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通道选择器"><span class="toc-number">3.5.</span> <span class="toc-text">通道选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#超时处理"><span class="toc-number">3.6.</span> <span class="toc-text">超时处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非阻塞通道"><span class="toc-number">3.7.</span> <span class="toc-text">非阻塞通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通道的关闭"><span class="toc-number">3.8.</span> <span class="toc-text">通道的关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通道遍历"><span class="toc-number">3.9.</span> <span class="toc-text">通道遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定时器"><span class="toc-number">3.10.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打点器"><span class="toc-number">3.11.</span> <span class="toc-text">打点器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工作池"><span class="toc-number">3.12.</span> <span class="toc-text">工作池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#速率限制-未懂"><span class="toc-number">3.13.</span> <span class="toc-text">速率限制(未懂)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子计数器"><span class="toc-number">3.14.</span> <span class="toc-text">原子计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥锁-未懂"><span class="toc-number">3.15.</span> <span class="toc-text">互斥锁(未懂)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go状态协程-未读"><span class="toc-number">3.16.</span> <span class="toc-text">go状态协程(未读)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读文件"><span class="toc-number">3.17.</span> <span class="toc-text">读文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写文件"><span class="toc-number">3.18.</span> <span class="toc-text">写文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#行过滤器"><span class="toc-number">3.19.</span> <span class="toc-text">行过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令行参数"><span class="toc-number">3.20.</span> <span class="toc-text">命令行参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令行标志-未懂"><span class="toc-number">3.21.</span> <span class="toc-text">命令行标志(未懂)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#环境变量-未懂"><span class="toc-number">3.22.</span> <span class="toc-text">环境变量(未懂)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行外部进程"><span class="toc-number">3.23.</span> <span class="toc-text">执行外部进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#替换执行进程"><span class="toc-number">3.24.</span> <span class="toc-text">替换执行进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号"><span class="toc-number">3.25.</span> <span class="toc-text">信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#退出"><span class="toc-number">3.26.</span> <span class="toc-text">退出</span></a></li></ol></li></ol></div></div><div class="post-content"><p><code>go</code>的学习,感谢<a href="https://gobyexample.xgwang.me/" target="_blank" rel="noopener">Go By Example</a>、<a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md" target="_blank" rel="noopener">go 网络编程</a>与<a href="http://books.studygolang.com/The-Golang-Standard-Library-by-Example/" target="_blank" rel="noopener">go 语言标准库</a><br>随着学习的深入,此文章持续更新…</p>
<a id="more"></a>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量  </span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span> = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">var</span> b, c <span class="keyword">int</span> =  <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="comment">// 只允许函数中这样声明</span></span><br><span class="line">f := <span class="string">"world"</span></span><br><span class="line"><span class="comment">// 常量(只允许布尔型、数字型（整数型、浮点型和复数）和字符串型)</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="string">"hello, world"</span></span><br><span class="line"><span class="comment">// 同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明</span></span><br><span class="line"><span class="comment">// 关键字iota，这个关键字用来声明enum的时候采用，它默认开始值是0，const中每增加一行加1</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span>  <span class="comment">//0</span></span><br><span class="line">    b = <span class="literal">iota</span>  <span class="comment">//1</span></span><br><span class="line">    c = <span class="literal">iota</span>  <span class="comment">//2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> v = <span class="literal">iota</span> <span class="comment">// 每遇到一个const关键字，iota就会重置，此时v == 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	h, i, j = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//h=0,i=0,j=0 iota在同一行值相同</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素</span></span><br><span class="line">doubleArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;[<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的声明可以简化，直接忽略内部的类型</span></span><br><span class="line">easyArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><code>go</code>语言中字符串是不可变的,想改变可以这样实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello"</span></span><br><span class="line">c := []<span class="keyword">byte</span>(s)  <span class="comment">// 将字符串 s 转换为 []byte 类型</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="string">'c'</span></span><br><span class="line">s2 := <span class="keyword">string</span>(c)  <span class="comment">// 再转换回 string 类型</span></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, s2)</span><br></pre></td></tr></table></figure>
<p>这样修改,字符串虽不能更改，但可进行切片操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello"</span></span><br><span class="line">s = <span class="string">"c"</span> + s[<span class="number">1</span>:]</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, s)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>strings.Contains(&quot;test&quot;, &quot;es&quot;)</code></td>
<td style="text-align:left">是否包含:<code>true</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.Count(&quot;test&quot;, &quot;t&quot;)</code></td>
<td style="text-align:left">包含数量:<code>2</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.HasPrefix(&quot;test&quot;, &quot;te&quot;)</code></td>
<td style="text-align:left">前缀:<code>true</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.HasSuffix(&quot;test&quot;, &quot;st&quot;)</code></td>
<td style="text-align:left">后缀:<code>true</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.Index(&quot;test&quot;, &quot;e&quot;)</code></td>
<td style="text-align:left">index:<code>1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.Join([]string{&quot;a&quot;, &quot;b&quot;, &quot;b&quot;}, &quot;-&quot;)</code></td>
<td style="text-align:left">join:<code>a-b-b</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.Repeat(&quot;a&quot;, 5)</code></td>
<td style="text-align:left">复制:<code>aaaaa</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.Replace(&quot;foo&quot;, &quot;o&quot;, &quot;0&quot;, -1)</code></td>
<td style="text-align:left">替换:<code>f00</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.Replace(&quot;foo&quot;, &quot;o&quot;, &quot;0&quot;, 1)</code></td>
<td style="text-align:left">替换 1 次:<code>f0o</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.Split(&quot;a-b-c-d-e&quot;, &quot;-&quot;)</code></td>
<td style="text-align:left">split:<code>[a b c d e]</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.ToLower(&quot;TEST&quot;)</code></td>
<td style="text-align:left">转小写:<code>test</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.ToUpper(&quot;test&quot;)</code></td>
<td style="text-align:left">转大写:<code>TEST</code></td>
</tr>
<tr>
<td style="text-align:left"><code>len(&quot;hello&quot;)</code></td>
<td style="text-align:left">长度:<code>5</code></td>
</tr>
<tr>
<td style="text-align:left"><code>&quot;hello&quot;[1]</code></td>
<td style="text-align:left">索引取值:<code>101</code></td>
</tr>
</tbody>
</table>
<hr>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// fmt.Printf  通过 os.Stdout打印格式化的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Sprintf 格式化并返回一个字符串而不带任何输出</span></span><br><span class="line">s := fmt.Sprintf(<span class="string">"a %s"</span>, <span class="string">"string"</span>)</span><br><span class="line">fmt.Println(s)   <span class="comment">// a string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Fprintf 格式化并输出到 io.Writers而不是 os.Stdout</span></span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"an %s\n"</span>, <span class="string">"error"</span>)  <span class="comment">// an error</span></span><br><span class="line"></span><br><span class="line">p := point&#123;x:<span class="number">1</span>, y:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%v\n&quot;, p)</code></td>
<td style="text-align:left">打印结构体<code>{1 2}</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%+v\n&quot;, p)</code></td>
<td style="text-align:left">打印结构体的字段名<code>{x:1 y:2}</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%#v\n&quot;, p)</code></td>
<td style="text-align:left">打印 Go 语法表示<code>main.point{x:1, y:2}</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%T\n&quot;, p)</code></td>
<td style="text-align:left">打印值的类型<code>main.point</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%t\n&quot;, true)</code></td>
<td style="text-align:left">格式化布尔值<code>true</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%d\n&quot;, 123)</code></td>
<td style="text-align:left">整数标准的十进制格式化<code>123</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%b\n&quot;, 14)</code></td>
<td style="text-align:left">整数二进制<code>1110</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%c\n&quot;, 33)</code></td>
<td style="text-align:left">整数输出给定整数的对应字符<code>!</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%x\n&quot;, 456)</code></td>
<td style="text-align:left">整数十六进制<code>1c8</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%f\n&quot;, 78.9)</code></td>
<td style="text-align:left">浮点数十进制格式化<code>78.900000</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%e\n&quot;, 123400000.0)</code></td>
<td style="text-align:left">浮点型格式化科学技科学记数法<code>1.234000e+08</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%E\n&quot;, 123400000.0)</code></td>
<td style="text-align:left">浮点型格式化科学技科学记数法<code>1.234000E+08</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%s\n&quot;, &quot;\&quot;string\&quot;&quot;)</code></td>
<td style="text-align:left">基本的字符串输出<code>&quot;string&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%q\n&quot;, &quot;\&quot;string\&quot;&quot;)</code></td>
<td style="text-align:left">Go 源代码中那样带有双引号的输出<code>&quot;\&quot;string\&quot;&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%x\n&quot;, &quot;hex this&quot;)</code></td>
<td style="text-align:left">base-16 编码的字符串<code>6865782074686973</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%p\n&quot;, &amp;p)</code></td>
<td style="text-align:left">输出一个指针的值<code>0x42135100</code></td>
</tr>
</tbody>
</table>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当输出数字的时候，你将经常想要控制输出结果的宽度和精度，可以使用在 % 后面使用数字来控制输出宽度。默认结果使用右对齐并且通过空格来填充空白部分。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%6d|%6d|\n"</span>, <span class="number">12</span>, <span class="number">345</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也可以指定浮点型的输出宽度，同时也可以通过 宽度.精度 的语法来指定输出的精度。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%6.2f|%6.2f|\n"</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要左对齐，使用 - 标志。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%-6.2f|%-6.2f|\n"</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也许也想控制字符串输出时的宽度，特别是要确保他们在类表格输出时的对齐。这是基本的右对齐宽度表示。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%6s|%6s|\n"</span>, <span class="string">"foo"</span>, <span class="string">"b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要左对齐，和数字一样，使用 - 标志。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%-6s|%-6s|\n"</span>, <span class="string">"foo"</span>, <span class="string">"b"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">3</span> &#123;</span><br><span class="line">	fmt.Println(i)</span><br><span class="line">	i = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 经典的初始化/条件/后续形式 for 循环。 同样也支持跳过循环</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">7</span>; j &lt;= <span class="number">9</span>; j++ &#123;</span><br><span class="line">	fmt.Println(j)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不带条件的 for 循环将一直执行，直到在循环体内使用了 break 或者 return 来跳出循环。</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"loop"</span>)</span><br><span class="line">	<span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="if-else"><a href="#if-else" class="headerlink" title="if/else"></a>if/else</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">7</span>%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"7 is even"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"7 is odd"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在条件语句之前可以有一个语句；任何在这里声明的变量都可以在所有的条件分支中使用。</span></span><br><span class="line"><span class="keyword">if</span> num := <span class="number">9</span>; num &lt; <span class="number">0</span> &#123;</span><br><span class="line">	fmt.Println(num, <span class="string">"is negative"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> num &lt; <span class="number">10</span> &#123;</span><br><span class="line">	fmt.Println(num, <span class="string">"has 1 digit"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(num, <span class="string">"has multiple digits"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个 case 语句中，你可以使用逗号来分隔多个表达式。在这个例子中，我们很好的使用了可选的default 分支。</span></span><br><span class="line"><span class="keyword">switch</span> time.Now().Weekday() &#123;</span><br><span class="line"><span class="keyword">case</span> time.Saturday, time.Sunday:</span><br><span class="line">	fmt.Println(<span class="string">"it's the weekend"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	fmt.Println(<span class="string">"it's a weekday"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不带表达式的 switch 是实现 if/else 逻辑的另一种方式。这里展示了 case 表达式是如何使用非常量的。</span></span><br><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">	fmt.Println(<span class="string">"it's before noon"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	fmt.Println(<span class="string">"it's after noon"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里我们创建了一个数组 a 来存放刚好 5 个 int。元素的类型和长度都是数组类型的一部分。数组默认是零值的，对于 int 数组来说也就是 0。</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(<span class="string">"emp:"</span>, a)</span><br><span class="line"><span class="comment">// 我们可以使用 array[index] = value 语法来设置数组指定位置的值，或者用 array[index] 得到值。</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(<span class="string">"set:"</span>, a)</span><br><span class="line">fmt.Println(<span class="string">"get:"</span>, a[<span class="number">4</span>])</span><br><span class="line"><span class="comment">// 使用内置函数 len 返回数组的长度</span></span><br><span class="line">fmt.Println(<span class="string">"len:"</span>, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="comment">// 使用这个语法在一行内初始化一个数组</span></span><br><span class="line">b := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"dcl:"</span>, b)</span><br><span class="line"><span class="comment">// 数组的存储类型是单一的，但是你可以组合这些数据来构造多维的数据结构。</span></span><br><span class="line"><span class="keyword">var</span> twoD [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">		twoD[i][j] = i + j</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"2d: "</span>, twoD)</span><br></pre></td></tr></table></figure>
<h3 id="切片slice"><a href="#切片slice" class="headerlink" title="切片slice"></a>切片<code>slice</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不像数组，slice 的类型仅由它所包含的元素决定（不像数组中还需要元素的个数）。要创建一个长度非零的空slice，需要使用内建的方法 make。这里我们创建了一个长度为3的 string 类型 slice（初始化为零值）。</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">"emp:"</span>, s)</span><br><span class="line"><span class="comment">// 我们可以和数组一样设置和得到值</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">"a"</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">"b"</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="string">"c"</span></span><br><span class="line">fmt.Println(<span class="string">"set:"</span>, s)</span><br><span class="line">fmt.Println(<span class="string">"get:"</span>, s[<span class="number">2</span>])</span><br><span class="line"><span class="comment">// 如你所料，len 返回 slice 的长度</span></span><br><span class="line">fmt.Println(<span class="string">"len:"</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="comment">// 作为基本操作的补充，slice 支持比数组更多的操作。其中一个是内建的 append，它返回一个包含了一个或者多个新值的 slice。注意我们接受返回由 append返回的新的 slice 值。</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"d"</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"e"</span>, <span class="string">"f"</span>)</span><br><span class="line">fmt.Println(<span class="string">"apd:"</span>, s)</span><br><span class="line"><span class="comment">// Slice 也可以被 copy。这里我们创建一个空的和 s 有相同长度的 slice c，并且将 s 复制给 c。</span></span><br><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="built_in">copy</span>(c, s)</span><br><span class="line">fmt.Println(<span class="string">"cpy:"</span>, c)</span><br><span class="line"><span class="comment">// Slice 支持通过 slice[low:high] 语法进行“切片”操作。例如，这里得到一个包含元素 s[2], s[3],s[4] 的 slice。</span></span><br><span class="line">l := s[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Println(<span class="string">"sl1:"</span>, l)</span><br><span class="line"><span class="comment">// 这个 slice 从 s[0] 到（但是包含）s[5]。</span></span><br><span class="line">l = s[:<span class="number">5</span>]</span><br><span class="line">fmt.Println(<span class="string">"sl2:"</span>, l)</span><br><span class="line"><span class="comment">// 这个 slice 从（包含）s[2] 到 slice 的后一个值。</span></span><br><span class="line">l = s[<span class="number">2</span>:]</span><br><span class="line">fmt.Println(<span class="string">"sl3:"</span>, l)</span><br><span class="line"><span class="comment">// 我们可以在一行代码中声明并初始化一个 slice 变量。</span></span><br><span class="line">t := []<span class="keyword">string</span>&#123;<span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"dcl:"</span>, t)</span><br><span class="line"><span class="comment">// Slice 可以组成多维数据结构。内部的 slice 长度可以不同，这和多位数组不同。</span></span><br><span class="line">twoD := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">	innerLen := i + <span class="number">1</span></span><br><span class="line">	twoD[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, innerLen)</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; innerLen; j++ &#123;</span><br><span class="line">		twoD[i][j] = i + j</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"2d: "</span>, twoD)</span><br></pre></td></tr></table></figure>
<h3 id="关系数组map"><a href="#关系数组map" class="headerlink" title="关系数组map"></a>关系数组<code>map</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要创建一个空 map，需要使用内建的 make:make(map[key-type]val-type).</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 使用典型的 make[key] = val 语法来设置键值对。</span></span><br><span class="line">m[<span class="string">"k1"</span>] = <span class="number">7</span></span><br><span class="line">m[<span class="string">"k2"</span>] = <span class="number">13</span></span><br><span class="line"><span class="comment">// 使用例如 Println 来打印一个 map 将会输出所有的键值对。</span></span><br><span class="line">fmt.Println(<span class="string">"map:"</span>, m)</span><br><span class="line"><span class="comment">// 使用 name[key] 来获取一个键的值</span></span><br><span class="line">v1 := m[<span class="string">"k1"</span>]</span><br><span class="line">fmt.Println(<span class="string">"v1: "</span>, v1)</span><br><span class="line"><span class="comment">// 当对一个 map 调用内建的 len 时，返回的是键值对数目</span></span><br><span class="line">fmt.Println(<span class="string">"len:"</span>, <span class="built_in">len</span>(m))</span><br><span class="line"><span class="comment">// 内建的 delete 可以从一个 map 中移除键值对</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"k2"</span>)</span><br><span class="line">fmt.Println(<span class="string">"map:"</span>, m)</span><br><span class="line"><span class="comment">// 当从一个 map 中取值时，可选的第二返回值指示这个键是在这个 map 中。这可以用来消除键不存在和键有零值，像 0 或者 "" 而产生的歧义。</span></span><br><span class="line">num, prs := m[<span class="string">"k1"</span>]</span><br><span class="line">fmt.Println(<span class="string">"prs:"</span>, prs, num)</span><br><span class="line"><span class="comment">// 你也可以通过这个语法在同一行申明和初始化一个新的map。</span></span><br><span class="line">n := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"foo"</span>: <span class="number">1</span>, <span class="string">"bar"</span>: <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"map:"</span>, n)</span><br></pre></td></tr></table></figure>
<h3 id="遍历Rang"><a href="#遍历Rang" class="headerlink" title="遍历Rang"></a>遍历<code>Rang</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里我们使用 range 来统计一个 slice 的元素个数。数组也可以采用这种方法。</span></span><br><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">	sum += num</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"sum:"</span>, sum)</span><br><span class="line"><span class="comment">// range 在数组和 slice 中都同样提供每个项的索引和值。上面我们不需要索引，所以我们使用 空值定义符_ 来忽略它。有时候我们实际上是需要这个索引的。</span></span><br><span class="line"><span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">	<span class="keyword">if</span> num == <span class="number">3</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"index:"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// range 在 map 中迭代键值对。</span></span><br><span class="line">kvs := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"a"</span>: <span class="string">"apple"</span>, <span class="string">"b"</span>: <span class="string">"banana"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s -&gt; %s\n"</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// range 在字符串中迭代 unicode 编码。第一个返回值是rune 的起始字节位置，然后第二个是 rune 自己。</span></span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> <span class="string">"go"</span> &#123;</span><br><span class="line">	fmt.Println(i, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 首先我们来看一下基本数据类型到 JSON 字符串的编码过程。这里是一些原子值的例子。</span></span><br><span class="line">	bolB, _ := json.Marshal(<span class="literal">true</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(bolB))</span><br><span class="line">	intB, _ := json.Marshal(<span class="number">1</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(intB))</span><br><span class="line">	fltB, _ := json.Marshal(<span class="number">2.34</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(fltB))</span><br><span class="line">	strB, _ := json.Marshal(<span class="string">"gopher"</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(strB))</span><br><span class="line">	<span class="comment">// 这里是一些切片和 map 编码成 JSON 数组和对象的例子。</span></span><br><span class="line">	slcD := []<span class="keyword">string</span>&#123;<span class="string">"apple"</span>, <span class="string">"peach"</span>, <span class="string">"pear"</span>&#125;</span><br><span class="line">	slcB, _ := json.Marshal(slcD)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(slcB))</span><br><span class="line">	mapD := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"apple"</span>: <span class="number">5</span>, <span class="string">"lettuce"</span>: <span class="number">7</span>&#125;</span><br><span class="line">	mapB, _ := json.Marshal(mapD)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(mapB))</span><br><span class="line">	<span class="comment">// JSON 包可以自动的编码你的自定义类型。编码仅输出可导出的字段，并且默认使用他们的名字作为 JSON 数据的键。</span></span><br><span class="line">	res1D := &amp;Response1&#123;</span><br><span class="line">		Page:   <span class="number">1</span>,</span><br><span class="line">		Fruits: []<span class="keyword">string</span>&#123;<span class="string">"apple"</span>, <span class="string">"peach"</span>, <span class="string">"pear"</span>&#125;&#125;</span><br><span class="line">	res1B, _ := json.Marshal(res1D)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(res1B))</span><br><span class="line">	<span class="comment">// 你可以给结构字段声明标签来自定义编码的 JSON 数据键名称。在上面 Response2 的定义可以作为这个标签这个的一个例子。</span></span><br><span class="line">	res2D := Response2&#123;</span><br><span class="line">		Page:   <span class="number">1</span>,</span><br><span class="line">		Fruits: []<span class="keyword">string</span>&#123;<span class="string">"apple"</span>, <span class="string">"peach"</span>, <span class="string">"pear"</span>&#125;&#125;</span><br><span class="line">	res2B, _ := json.Marshal(res2D)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(res2B))</span><br><span class="line">	<span class="comment">// 现在来看看解码 JSON 数据为 Go 值的过程。这里是一个普通数据结构的解码例子。</span></span><br><span class="line">	byt := []<span class="keyword">byte</span>(<span class="string">`&#123;"num":6.13,"strs":["a","b"]&#125;`</span>)</span><br><span class="line">	<span class="comment">// 我们需要提供一个 JSON 包可以存放解码数据的变量。这里的 map[string]interface&#123;&#125; 将保存一个 string 为键，值为任意值的map。</span></span><br><span class="line">	<span class="keyword">var</span> dat <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 这里就是实际的解码和相关的错误检查。</span></span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal(byt, &amp;dat); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(dat)</span><br><span class="line">	<span class="comment">// 为了使用解码 map 中的值，我们需要将他们进行适当的类型转换。例如这里我们将 num 的值转换成 float64类型。</span></span><br><span class="line">	num := dat[<span class="string">"num"</span>].(<span class="keyword">float64</span>)</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">	<span class="comment">// 访问嵌套的值需要一系列的转化。</span></span><br><span class="line">	strs := dat[<span class="string">"strs"</span>].([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	str1 := strs[<span class="number">0</span>].(<span class="keyword">string</span>)</span><br><span class="line">	fmt.Println(str1)</span><br><span class="line">	<span class="comment">// 我们也可以解码 JSON 值到自定义类型。这个功能的好处就是可以为我们的程序带来额外的类型安全加强，并且消除在访问数据时的类型断言。</span></span><br><span class="line">	str := <span class="string">`&#123;"page": 1, "fruits": ["apple", "peach"]&#125;`</span></span><br><span class="line">	res := &amp;Response2&#123;&#125;</span><br><span class="line">	json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;res)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">	fmt.Println(res.Fruits[<span class="number">0</span>])</span><br><span class="line">	<span class="comment">// 在上面的例子中，我们经常使用 byte 和 string 作为使用标准输出时数据和 JSON 表示之间的中间值。我们也可以和os.Stdout 一样，直接将 JSON 编码直接输出至 os.Writer流中，或者作为 HTTP 响应体。</span></span><br><span class="line">	enc := json.NewEncoder(os.Stdout)</span><br><span class="line">	d := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"apple"</span>: <span class="number">5</span>, <span class="string">"lettuce"</span>: <span class="number">7</span>&#125;</span><br><span class="line">	enc.Encode(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是一个函数，接受两个 int 并且以 int 返回它们的和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// Go 需要明确的返回值，例如，它不会自动返回最后一个表达式的值</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 正如你期望的那样，通过 name(args) 来调用一个函数，</span></span><br><span class="line">	res := plus(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	fmt.Println(<span class="string">"1+2 ="</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (int, int) 在这个函数中标志着这个函数返回 2 个 int。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">vals</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span>, <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里我们通过多赋值 操作来使用这两个不同的返回值。</span></span><br><span class="line">	a, b := vals()</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	<span class="comment">// 如果你仅仅想返回值的一部分的话，你可以使用空白定义符 _。</span></span><br><span class="line">	_, c := vals()</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变参函数"><a href="#变参函数" class="headerlink" title="变参函数"></a>变参函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数使用任意数目的 int 作为参数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Print(nums, <span class="string">" "</span>)</span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		total += num</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(total)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 变参函数使用常规的调用方式，除了参数比较特殊。</span></span><br><span class="line">	sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 如果你的 slice 已经有了多个值，想把它们作为变参使用，你要这样调用 func(slice...)。</span></span><br><span class="line">	nums := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	sum(nums...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个 intSeq 函数返回另一个在 intSeq 函数体内定义的匿名函数。这个返回的函数使用闭包的方式 隐藏 变量 i。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSeq</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 我们调用 intSeq 函数，将返回值（也是一个函数）赋给nextInt。这个函数的值包含了自己的值 i，这样在每次调用 nextInt 时都会更新 i 的值。</span></span><br><span class="line">	nextInt := intSeq()</span><br><span class="line">	<span class="comment">// 通过多次调用 nextInt 来看看闭包的效果。</span></span><br><span class="line">	fmt.Println(nextInt())</span><br><span class="line">	fmt.Println(nextInt())</span><br><span class="line">	fmt.Println(nextInt())</span><br><span class="line">	<span class="comment">// 为了确认这个状态对于这个特定的函数是唯一的，我们重新创建并测试一下。</span></span><br><span class="line">	newInts := intSeq()</span><br><span class="line">	fmt.Println(newInts())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// face 函数在到达 face(0) 前一直调用自身。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fact</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n * fact(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(fact(<span class="number">7</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们将通过两个函数：zeroval 和 zeroptr 来比较指针和值类型的不同。zeroval 有一个 int 型参数，所以使用值传递。zeroval 将从调用它的那个函数中得到一个 ival形参的拷贝。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zeroval</span><span class="params">(ival <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	ival = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zeroptr 有一和上面不同的 *int 参数，意味着它用了一个 int指针。函数体内的 *iptr 接着解引用 这个指针，从它内存地址得到这个地址对应的当前值。对一个解引用的指针赋值将会改变这个指针引用的真实地址的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zeroptr</span><span class="params">(iptr *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	*iptr = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	fmt.Println(<span class="string">"initial:"</span>, i)</span><br><span class="line">	zeroval(i)</span><br><span class="line">	fmt.Println(<span class="string">"zeroval:"</span>, i)</span><br><span class="line">	<span class="comment">// 通过 &amp;i 语法来取得 i 的内存地址，例如一个变量i 的指针。</span></span><br><span class="line">	zeroptr(&amp;i)</span><br><span class="line">	fmt.Println(<span class="string">"zeroptr:"</span>, i)</span><br><span class="line">	<span class="comment">// 指针也是可以被打印的。</span></span><br><span class="line">	fmt.Println(<span class="string">"pointer:"</span>, &amp;i)</span><br><span class="line">        <span class="comment">// 又可以获取到值了</span></span><br><span class="line">	fmt.Println(<span class="string">"pointer:"</span>, *&amp;i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zeroval 在 main 函数中不能改变 i 的值，但是zeroptr 可以，因为它有一个这个变量的内存地址的引用。</span></span><br><span class="line"><span class="comment">// 对于空指针   var  ptr *int    ptr == nil</span></span><br></pre></td></tr></table></figure>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用这个语法创建了一个新的结构体元素。</span></span><br><span class="line">	fmt.Println(person&#123;<span class="string">"Bob"</span>, <span class="number">20</span>&#125;)</span><br><span class="line">	<span class="comment">// 你可以在初始化一个结构体元素时指定字段名字。</span></span><br><span class="line">	fmt.Println(person&#123;name: <span class="string">"Alice"</span>, age: <span class="number">30</span>&#125;)</span><br><span class="line">	<span class="comment">// 省略的字段将被初始化为零值。</span></span><br><span class="line">	fmt.Println(person&#123;name: <span class="string">"Fred"</span>&#125;)</span><br><span class="line">	<span class="comment">// &amp; 前缀生成一个结构体指针。</span></span><br><span class="line">	fmt.Println(&amp;person&#123;name: <span class="string">"Ann"</span>, age: <span class="number">40</span>&#125;)</span><br><span class="line">	<span class="comment">// 使用点来访问结构体字段。</span></span><br><span class="line">	s := person&#123;name: <span class="string">"Sean"</span>, age: <span class="number">50</span>&#125;</span><br><span class="line">	fmt.Println(s.name)</span><br><span class="line">	<span class="comment">// 也可以对结构体指针使用. - 指针会被自动解引用。</span></span><br><span class="line">	sp := &amp;s</span><br><span class="line">	fmt.Println(sp.age)</span><br><span class="line">	<span class="comment">// 结构体是可变的。</span></span><br><span class="line">	sp.age = <span class="number">51</span></span><br><span class="line">	fmt.Println(sp.age)</span><br><span class="line">	fmt.Println(s.age) <span class="comment">// 51</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 area 方法有一个接收器类型 rect。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rect)</span> <span class="title">area</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以为值类型或者指针类型的接收器定义方法。这里是一个值类型接收器的例子。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>*r.width + <span class="number">2</span>*r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := rect&#123;width: <span class="number">10</span>, height: <span class="number">5</span>&#125;</span><br><span class="line">	<span class="comment">// 这里我们调用上面为结构体定义的两个方法。</span></span><br><span class="line">	fmt.Println(<span class="string">"area: "</span>, r.area())</span><br><span class="line">	fmt.Println(<span class="string">"perim:"</span>, r.perim())</span><br><span class="line">	<span class="comment">// Go 自动处理方法调用时的值和指针之间的转化。你可以使用指针来调用方法来避免在方法调用时产生一个拷贝，或者让方法能够改变接受的数据。</span></span><br><span class="line">	rp := &amp;r</span><br><span class="line">	fmt.Println(<span class="string">"area: "</span>, rp.area())</span><br><span class="line">	fmt.Println(<span class="string">"perim:"</span>, rp.perim())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口 是方法特征的命名集合。</span></span><br><span class="line"><span class="comment">// 这里是一个几何体的基本接口。</span></span><br><span class="line"><span class="keyword">type</span> geometry <span class="keyword">interface</span> &#123;</span><br><span class="line">	area() <span class="keyword">float64</span></span><br><span class="line">	perim() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在我们的例子中，我们将让 rect 和 circle 实现这个接口</span></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要在 Go 中实现一个接口，我们只需要实现接口中的所有方法。这里我们让 rect 实现了 geometry 接口。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>*r.width + <span class="number">2</span>*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// circle 的实现。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一个变量是接口类型，那么我们可以调用这个被命名的接口中的方法。这里有一个一通用的 measure 函数，利用这个特性，它可以用在任何 geometry 上。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measure</span><span class="params">(g geometry)</span></span> &#123;</span><br><span class="line">	fmt.Println(g)</span><br><span class="line">	fmt.Println(g.area())</span><br><span class="line">	fmt.Println(g.perim())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := rect&#123;width: <span class="number">3</span>, height: <span class="number">4</span>&#125;</span><br><span class="line">	c := circle&#123;radius: <span class="number">5</span>&#125;</span><br><span class="line">	<span class="comment">// 结构体类型 circle 和 rect 都实现了 geometry接口，所以我们可以使用它们的实例作为 measure 的参数。</span></span><br><span class="line">	measure(r)</span><br><span class="line">	measure(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取-interface-变量存储的类型"><a href="#获取-interface-变量存储的类型" class="headerlink" title="获取 interface 变量存储的类型"></a>获取 interface 变量存储的类型</h3><p><code>interface</code>的变量里面可以存储任意类型的数值(该类型实现了<code>interface</code>)<br>那么获取这个变量里面实际保存的对象类型可以使用下列方法</p>
<ul>
<li>Comma-ok 断言<br>Go 语言里面有一个语法，可以直接判断是否是该类型的变量： value, ok = element.(T)，这里 value 就是变量的值，ok 是一个 bool 类型，element 是 interface 变量，T 是断言的类型。如果 element 里面确实存储了 T 类型的数值，那么 ok 返回 true，否则返回 false。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> List []Element</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了String方法，实现了fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"(name: "</span> + p.name + <span class="string">" - age: "</span> + strconv.Itoa(p.age) + <span class="string">" years)"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">	list[<span class="number">0</span>] = <span class="number">1</span>       <span class="comment">// an int</span></span><br><span class="line">	list[<span class="number">1</span>] = <span class="string">"Hello"</span> <span class="comment">// a string</span></span><br><span class="line">	list[<span class="number">2</span>] = Person&#123;<span class="string">"Dennis"</span>, <span class="number">70</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> index, element := <span class="keyword">range</span> list &#123;</span><br><span class="line">		<span class="keyword">if</span> value, ok := element.(<span class="keyword">int</span>); ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"list[%d] is an int and its value is %d\n"</span>, index, value)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"list[%d] is a string and its value is %s\n"</span>, index, value)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(Person); ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"list[%d] is a Person and its value is %s\n"</span>, index, value)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"list[%d] is of a different type\n"</span>, index)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>switch 测试</li>
</ul>
<p>因为用到了很多的 if 所以自然有<code>switch</code><br>这里有一点需要强调的是：<code>element.(type)</code>语法不能在 switch 外的任何逻辑里面使用，如果你要在 switch 外面判断一个类型就使用<code>comma-ok</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">	list[<span class="number">0</span>] = <span class="number">1</span>       <span class="comment">//an int</span></span><br><span class="line">	list[<span class="number">1</span>] = <span class="string">"Hello"</span> <span class="comment">//a string</span></span><br><span class="line">	list[<span class="number">2</span>] = Person&#123;<span class="string">"Dennis"</span>, <span class="number">70</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> index, element := <span class="keyword">range</span> list &#123;</span><br><span class="line">		<span class="keyword">switch</span> value := element.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">			fmt.Printf(<span class="string">"list[%d] is an int and its value is %d\n"</span>, index, value)</span><br><span class="line">		<span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">			fmt.Printf(<span class="string">"list[%d] is a string and its value is %s\n"</span>, index, value)</span><br><span class="line">		<span class="keyword">case</span> Person:</span><br><span class="line">			fmt.Printf(<span class="string">"list[%d] is a Person and its value is %s\n"</span>, index, value)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"list[%d] is of a different type"</span>, index)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反射-不太懂"><a href="#反射-不太懂" class="headerlink" title="反射(不太懂)"></a>反射(不太懂)</h3><p>暂时觉得这个可以判断结构类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStruct)</span> <span class="title">GetName</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	this.name = str</span><br><span class="line">	<span class="keyword">return</span> this.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 备注: reflect.Indirect -&gt; 如果是指针则返回 Elem()</span></span><br><span class="line">	<span class="comment">// 首先，reflect包有两个数据类型我们必须知道，一个是Type，一个是Value。</span></span><br><span class="line">	<span class="comment">// Type就是定义的类型的一个数据类型，Value是值的类型</span></span><br><span class="line">	<span class="comment">// 对象</span></span><br><span class="line">	s := <span class="string">"this is string"</span></span><br><span class="line">	<span class="comment">// 获取对象类型 (string)</span></span><br><span class="line">	fmt.Println(reflect.TypeOf(s))</span><br><span class="line">	<span class="comment">// 获取对象值 (this is string)</span></span><br><span class="line">	fmt.Println(reflect.ValueOf(s))</span><br><span class="line">	<span class="comment">// 对象</span></span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">	<span class="comment">// 获取对象值 (&lt;float64 Value&gt;)</span></span><br><span class="line">	fmt.Println(reflect.ValueOf(x))</span><br><span class="line">	<span class="comment">// 对象</span></span><br><span class="line">	a := &amp;MyStruct&#123;name: <span class="string">"nljb"</span>&#125;</span><br><span class="line">	<span class="comment">// 返回对象的方法的数量 (1)</span></span><br><span class="line">	fmt.Println(reflect.TypeOf(a).NumMethod())</span><br><span class="line">	<span class="comment">// 遍历对象中的方法</span></span><br><span class="line">	<span class="keyword">for</span> m := <span class="number">0</span>; m &lt; reflect.TypeOf(a).NumMethod(); m++ &#123;</span><br><span class="line">		method := reflect.TypeOf(a).Method(m)</span><br><span class="line">		fmt.Println(method.Type)         <span class="comment">// func(*main.MyStruct) string</span></span><br><span class="line">		fmt.Println(method.Name)         <span class="comment">// GetName</span></span><br><span class="line">		fmt.Println(method.Type.NumIn()) <span class="comment">// 参数个数</span></span><br><span class="line">		fmt.Println(method.Type.In(<span class="number">1</span>))   <span class="comment">// 参数类型</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取对象值 (&lt;*main.MyStruct Value&gt;)</span></span><br><span class="line">	fmt.Println(reflect.ValueOf(a))</span><br><span class="line">	<span class="comment">// 获取对象名称</span></span><br><span class="line">	fmt.Println(reflect.Indirect(reflect.ValueOf(a)).Type().Name())</span><br><span class="line">	<span class="comment">// 参数</span></span><br><span class="line">	i := <span class="string">"Hello"</span></span><br><span class="line">	v := <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>)</span><br><span class="line">	v = <span class="built_in">append</span>(v, reflect.ValueOf(i))</span><br><span class="line">	<span class="comment">// 通过对象值中的方法名称调用方法 ([nljb]) (返回数组因为Go支持多值返回)</span></span><br><span class="line">	fmt.Println(reflect.ValueOf(a).MethodByName(<span class="string">"GetName"</span>).Call(v))</span><br><span class="line">	<span class="comment">// 通过对值中的子对象名称获取值 (nljb)</span></span><br><span class="line">	fmt.Println(reflect.Indirect(reflect.ValueOf(a)).FieldByName(<span class="string">"name"</span>))</span><br><span class="line">	<span class="comment">// 是否可以改变这个值 (false)</span></span><br><span class="line">	fmt.Println(reflect.Indirect(reflect.ValueOf(a)).FieldByName(<span class="string">"name"</span>).CanSet())</span><br><span class="line">	<span class="comment">// 是否可以改变这个值 (true)</span></span><br><span class="line">	fmt.Println(reflect.Indirect(reflect.ValueOf(&amp;(a.name))).CanSet())</span><br><span class="line">	<span class="comment">// 不可改变 (false)</span></span><br><span class="line">	fmt.Println(reflect.Indirect(reflect.ValueOf(s)).CanSet())</span><br><span class="line">	<span class="comment">// 可以改变</span></span><br><span class="line">	<span class="comment">// reflect.Indirect(reflect.ValueOf(&amp;s)).SetString("jbnl")</span></span><br><span class="line">	fmt.Println(reflect.Indirect(reflect.ValueOf(&amp;s)).CanSet())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照惯例，错误通常是最后一个返回值并且是 error 类型，一个内建的接口。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(arg <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> arg == <span class="number">42</span> &#123;</span><br><span class="line">		<span class="comment">// errors.New 构造一个使用给定的错误信息的基本error 值。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"can't work with 42"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回错误值为 nil 代表没有错误。</span></span><br><span class="line">	<span class="keyword">return</span> arg + <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过实现 Error 方法来自定义 error 类型是可以的。这里使用自定义错误类型来表示上面的参数错误。</span></span><br><span class="line"><span class="keyword">type</span> argError <span class="keyword">struct</span> &#123;</span><br><span class="line">	arg  <span class="keyword">int</span></span><br><span class="line">	prob <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *argError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d - %s"</span>, e.arg, e.prob)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(arg <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> arg == <span class="number">42</span> &#123;</span><br><span class="line">		<span class="comment">// 在这个例子中，我们使用 &amp;argError 语法来建立一个新的结构体，并提供了 arg 和 prob 这个两个字段的值。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, &amp;argError&#123;arg, <span class="string">"can't work with it"</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arg + <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 下面的两个循环测试了各个返回错误的函数。注意在 if行内的错误检查代码，在 Go 中是一个普遍的用法。</span></span><br><span class="line">	<span class="keyword">for</span> _, i := <span class="keyword">range</span> []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">42</span>&#125; &#123;</span><br><span class="line">		<span class="keyword">if</span> r, e := f1(i); e != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"f1 failed:"</span>, e)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"f1 worked:"</span>, r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, i := <span class="keyword">range</span> []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">42</span>&#125; &#123;</span><br><span class="line">		<span class="keyword">if</span> r, e := f2(i); e != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"f2 failed:"</span>, e)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"f2 worked:"</span>, r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 你如果想在程序中使用一个自定义错误类型中的数据，你需要通过类型断言来得到这个错误类型的实例。</span></span><br><span class="line">	_, e := f2(<span class="number">42</span>)</span><br><span class="line">	<span class="keyword">if</span> ae, ok := e.(*argError); ok &#123;</span><br><span class="line">		fmt.Println(ae.arg)</span><br><span class="line">		fmt.Println(ae.prob)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 排序方法是正对内置数据类型的；这里是一个字符串的例子。注意排序是原地更新的，所以他会改变给定的序列并且不返回一个新值。</span></span><br><span class="line">	strs := []<span class="keyword">string</span>&#123;<span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>&#125;</span><br><span class="line">	sort.Strings(strs)</span><br><span class="line">	fmt.Println(<span class="string">"Strings:"</span>, strs)</span><br><span class="line">	<span class="comment">// 一个 int 排序的例子。</span></span><br><span class="line">	ints := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line">	sort.Ints(ints)</span><br><span class="line">	fmt.Println(<span class="string">"Ints:   "</span>, ints)</span><br><span class="line">	<span class="comment">// 我们也可以使用 sort 来检查一个序列是不是已经是排好序的。</span></span><br><span class="line">	s := sort.IntsAreSorted(ints)</span><br><span class="line">	fmt.Println(<span class="string">"Sorted: "</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了在 Go 中使用自定义函数进行排序，我们需要一个对应的类型。这里我们创建一个为内置 []string 类型的别名的ByLength 类型，</span></span><br><span class="line"><span class="keyword">type</span> ByLength []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在类型中实现了 sort.Interface 的 Len，Less和 Swap 方法，这样我们就可以使用 sort 包的通用Sort 方法了，Len 和 Swap 通常在各个类型中都差不多，Less 将控制实际的自定义排序逻辑。在我们的例子中，我们想按字符串长度增加的顺序来排序，所以这里使用了 len(s[i]) 和 len(s[j])。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByLength)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByLength)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByLength)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s[i]) &lt; <span class="built_in">len</span>(s[j])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一切都准备好了，我们现在可以通过将原始的 fruits 切片转型成 ByLength 来实现我们的自定排序了。然后对这个转型的切片使用 sort.Sort 方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fruits := []<span class="keyword">string</span>&#123;<span class="string">"peach"</span>, <span class="string">"banana"</span>, <span class="string">"kiwi"</span>&#125;</span><br><span class="line">	sort.Sort(ByLength(fruits))</span><br><span class="line">	fmt.Println(fruits)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 我们将在这个网站中使用 panic 来检查预期外的错误。这个是唯一一个为 panic 准备的例子。</span></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"a problem"</span>)</span><br><span class="line">	<span class="comment">// panic 的一个基本用法就是在一个函数返回了错误值但是我们并不知道（或者不想）处理时终止运行。这里是一个在创建一个新文件时返回异常错误时的panic 用法。</span></span><br><span class="line">	_, err := os.Create(<span class="string">"/tmp/file"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们想要创建一个文件，向它进行写操作，然后在结束时关闭它。这里展示了如何通过 defer 来做到这一切。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在 closeFile 后得到一个文件对象，我们使用 defer通过 closeFile 来关闭这个文件。这会在封闭函数（main）结束时执行，就是 writeFile 结束后。</span></span><br><span class="line">	f := createFile(<span class="string">"/tmp/defer.txt"</span>)</span><br><span class="line">	<span class="keyword">defer</span> closeFile(f)</span><br><span class="line">	writeFile(f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createFile</span><span class="params">(p <span class="keyword">string</span>)</span> *<span class="title">os</span>.<span class="title">File</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"creating"</span>)</span><br><span class="line">	f, err := os.Create(p)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">(f *os.File)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"writing"</span>)</span><br><span class="line">	fmt.Fprintln(f, <span class="string">"data"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closeFile</span><span class="params">(f *os.File)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"closing"</span>)</span><br><span class="line">	f.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := fmt.Println</span><br><span class="line">	<span class="comment">// 得到当前时间。</span></span><br><span class="line">	now := time.Now()</span><br><span class="line">	p(now)</span><br><span class="line">	<span class="comment">// 通过提供年月日等信息，你可以构建一个 time。时间总是关联着位置信息，例如时区。</span></span><br><span class="line">	then := time.Date(</span><br><span class="line">		<span class="number">2009</span>, <span class="number">11</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">34</span>, <span class="number">58</span>, <span class="number">651387237</span>, time.UTC)</span><br><span class="line">	p(then)</span><br><span class="line">	<span class="comment">// 你可以提取出时间的各个组成部分。</span></span><br><span class="line">	p(then.Year())</span><br><span class="line">	p(then.Month())</span><br><span class="line">	p(then.Day())</span><br><span class="line">	p(then.Hour())</span><br><span class="line">	p(then.Minute())</span><br><span class="line">	p(then.Second())</span><br><span class="line">	p(then.Nanosecond())</span><br><span class="line">	p(then.Location())</span><br><span class="line">	<span class="comment">// 输出是星期一到日的 Weekday 也是支持的。</span></span><br><span class="line">	p(then.Weekday())</span><br><span class="line">	<span class="comment">// 这些方法来比较两个时间，分别测试一下是否是之前，之后或者是同一时刻，精确到秒。</span></span><br><span class="line">	p(then.Before(now))</span><br><span class="line">	p(then.After(now))</span><br><span class="line">	p(then.Equal(now))</span><br><span class="line">	<span class="comment">// 方法 Sub 返回一个 Duration 来表示两个时间点的间隔时间。</span></span><br><span class="line">	diff := now.Sub(then)</span><br><span class="line">	p(diff)</span><br><span class="line">	<span class="comment">// 我们计算出不同单位下的时间长度值。</span></span><br><span class="line">	p(diff.Hours())</span><br><span class="line">	p(diff.Minutes())</span><br><span class="line">	p(diff.Seconds())</span><br><span class="line">	p(diff.Nanoseconds())</span><br><span class="line">	<span class="comment">// 你可以使用 Add 将时间后移一个时间间隔，或者使用一个 - 来将时间前移一个时间间隔。</span></span><br><span class="line">	p(then.Add(diff))</span><br><span class="line">	p(then.Add(-diff))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 分别使用带 Unix 或者 UnixNano 的 time.Now来获取从自协调世界时起到现在的秒数或者纳秒数。</span></span><br><span class="line">	now := time.Now()</span><br><span class="line">	secs := now.Unix()</span><br><span class="line">	nanos := now.UnixNano()</span><br><span class="line">	fmt.Println(now)</span><br><span class="line">	<span class="comment">// 注意 UnixMillis 是不存在的，所以要得到毫秒数的话，你要自己手动的从纳秒转化一下。</span></span><br><span class="line">	millis := nanos / <span class="number">1000000</span></span><br><span class="line">	fmt.Println(secs)</span><br><span class="line">	fmt.Println(millis)</span><br><span class="line">	fmt.Println(nanos)</span><br><span class="line">	<span class="comment">// 你也可以将协调世界时起的整数秒或者纳秒转化到相应的时间。</span></span><br><span class="line">	fmt.Println(time.Unix(secs, <span class="number">0</span>))</span><br><span class="line">	fmt.Println(time.Unix(<span class="number">0</span>, nanos))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间的格式化与解析"><a href="#时间的格式化与解析" class="headerlink" title="时间的格式化与解析"></a>时间的格式化与解析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := fmt.Println</span><br><span class="line">	<span class="comment">// 这里是一个基本的按照 RFC3339 进行格式化的例子，使用对应模式常量。</span></span><br><span class="line">	t := time.Now()</span><br><span class="line">	p(t.Format(time.RFC3339))</span><br><span class="line">	<span class="comment">// 时间解析使用同 Format 相同的形式值。</span></span><br><span class="line">	t1, e := time.Parse(</span><br><span class="line">		time.RFC3339,</span><br><span class="line">		<span class="string">"2012-11-01T22:08:41+00:00"</span>)</span><br><span class="line">	p(t1)</span><br><span class="line">	<span class="comment">// Format 和 Parse 使用基于例子的形式来决定日期格式，一般你只要使用 time 包中提供的模式常量就行了，但是你也可以实现自定义模式。模式必须使用时间 Mon Jan 2 15:04:05 MST 2006来指定给定时间/字符串的格式化/解析方式。时间一定要按照如下所示：2006为年，15 为小时，Monday 代表星期几，等等。</span></span><br><span class="line">	p(t.Format(<span class="string">"3:04PM"</span>))</span><br><span class="line">	p(t.Format(<span class="string">"Mon Jan _2 15:04:05 2006"</span>))</span><br><span class="line">	p(t.Format(<span class="string">"2006-01-02T15:04:05.999999-07:00"</span>))</span><br><span class="line">	form := <span class="string">"3 04 PM"</span></span><br><span class="line">	t2, e := time.Parse(form, <span class="string">"8 41 PM"</span>)</span><br><span class="line">	p(t2)</span><br><span class="line">	<span class="comment">// 对于纯数字表示的时间，你也可以使用标准的格式化字符串来提出出时间值得组成。</span></span><br><span class="line">	fmt.Printf(<span class="string">"%d-%02d-%02dT%02d:%02d:%02d-00:00\n"</span>,</span><br><span class="line">		t.Year(), t.Month(), t.Day(),</span><br><span class="line">		t.Hour(), t.Minute(), t.Second())</span><br><span class="line">	<span class="comment">// Parse 函数在输入的时间格式不正确是会返回一个错误。</span></span><br><span class="line">	ansic := <span class="string">"Mon Jan _2 15:04:05 2006"</span></span><br><span class="line">	_, e = time.Parse(ansic, <span class="string">"8:41PM"</span>)</span><br><span class="line">	p(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数字解析"><a href="#数字解析" class="headerlink" title="数字解析"></a>数字解析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用 ParseFloat 解析浮点数，这里的 64 表示表示解析的数的位数。</span></span><br><span class="line">	f, _ := strconv.ParseFloat(<span class="string">"1.234"</span>, <span class="number">64</span>)</span><br><span class="line">	fmt.Println(f)</span><br><span class="line">	<span class="comment">// 在使用 ParseInt 解析整形数时，例子中的参数 0 表示自动推断字符串所表示的数字的进制。64 表示返回的整形数是以 64 位存储的。</span></span><br><span class="line">	i, _ := strconv.ParseInt(<span class="string">"123"</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">	fmt.Println(i)</span><br><span class="line">	<span class="comment">// ParseInt 会自动识别出十六进制数。</span></span><br><span class="line">	d, _ := strconv.ParseInt(<span class="string">"0x1c8"</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">	fmt.Println(d)</span><br><span class="line">	<span class="comment">// ParseUint 也是可用的。</span></span><br><span class="line">	u, _ := strconv.ParseUint(<span class="string">"789"</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">	fmt.Println(u)</span><br><span class="line">	<span class="comment">// Atoi 是一个基础的 10 进制整型数转换函数。</span></span><br><span class="line">	k, _ := strconv.Atoi(<span class="string">"135"</span>)</span><br><span class="line">	fmt.Println(k)</span><br><span class="line">	<span class="comment">// 在输入错误时，解析函数会返回一个错误。</span></span><br><span class="line">	_, e := strconv.Atoi(<span class="string">"wat"</span>)</span><br><span class="line">	fmt.Println(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="url-解析"><a href="#url-解析" class="headerlink" title="url 解析"></a>url 解析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 我们将解析这个 URL 示例，它包含了一个 scheme，认证信息，主机名，端口，路径，查询参数和片段。</span></span><br><span class="line">	s := <span class="string">"postgres://user:pass@host.com:5432/path?k=v#f"</span></span><br><span class="line">	<span class="comment">// 解析这个 URL 并确保解析没有出错。</span></span><br><span class="line">	u, err := url.Parse(s)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 直接访问 scheme。</span></span><br><span class="line">	fmt.Println(u.Scheme) <span class="comment">// postgres</span></span><br><span class="line">	<span class="comment">// User 包含了所有的认证信息，这里调用 Username和 Password 来获取独立值。</span></span><br><span class="line">	fmt.Println(u.User)            <span class="comment">// user:pass</span></span><br><span class="line">	fmt.Println(u.User.Username()) <span class="comment">// user</span></span><br><span class="line">	p, _ := u.User.Password()</span><br><span class="line">	fmt.Println(p) <span class="comment">// pass</span></span><br><span class="line">	<span class="comment">// Host 同时包括主机名和端口信息，如过端口存在的话，使用 strings.Split() 从 Host 中手动提取端口。</span></span><br><span class="line">	fmt.Println(u.Host) <span class="comment">// host.com:5432</span></span><br><span class="line">	h := strings.Split(u.Host, <span class="string">":"</span>)</span><br><span class="line">	fmt.Println(h[<span class="number">0</span>]) <span class="comment">// host.com</span></span><br><span class="line">	fmt.Println(h[<span class="number">1</span>]) <span class="comment">// 5432</span></span><br><span class="line">	<span class="comment">// 这里我们提出路径和查询片段信息。</span></span><br><span class="line">	fmt.Println(u.Path)     <span class="comment">// /path</span></span><br><span class="line">	fmt.Println(u.Fragment) <span class="comment">// f</span></span><br><span class="line">	<span class="comment">// 要得到字符串中的 k=v 这种格式的查询参数，可以使用 RawQuery 函数。你也可以将查询参数解析为一个map。</span></span><br><span class="line">	<span class="comment">// 已解析的查询参数 map 以查询字符串为键，对应值字符串切片为值，所以如何只想得到一个键对应的第一个值，将索引位置设置为 [0] 就行了。</span></span><br><span class="line">	fmt.Println(u.RawQuery) <span class="comment">// k=v</span></span><br><span class="line">	m, _ := url.ParseQuery(u.RawQuery)</span><br><span class="line">	fmt.Println(m)         <span class="comment">// map[k:[v]]</span></span><br><span class="line">	fmt.Println(m[<span class="string">"k"</span>][<span class="number">0</span>]) <span class="comment">// v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 例如，rand.Intn 返回一个随机的整数 n，0 &lt;= n &lt;= 100。</span></span><br><span class="line">	fmt.Print(rand.Intn(<span class="number">100</span>), <span class="string">","</span>)</span><br><span class="line">	fmt.Print(rand.Intn(<span class="number">100</span>))</span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="comment">// rand.Float64 返回一个64位浮点数 f，0.0 &lt;= f &lt;= 1.0。</span></span><br><span class="line">	fmt.Println(rand.Float64())</span><br><span class="line">	<span class="comment">// 这个技巧可以用来生成其他范围的随机浮点数，例如5.0 &lt;= f &lt;= 10.0</span></span><br><span class="line">	fmt.Print((rand.Float64()*<span class="number">5</span>)+<span class="number">5</span>, <span class="string">","</span>)</span><br><span class="line">	fmt.Print((rand.Float64() * <span class="number">5</span>) + <span class="number">5</span>)</span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="comment">// 默认情况下，给定的种子是确定的，每次都会产生相同的随机数数字序列。要产生变化的序列，需要给定一个变化的种子。需要注意的是，如果你出于加密目的，需要使用随机数的话，请使用 crypto/rand 包，此方法不够安全。</span></span><br><span class="line">	s1 := rand.NewSource(time.Now().UnixNano())</span><br><span class="line">	r1 := rand.New(s1)</span><br><span class="line">	<span class="comment">// 调用上面返回的 rand.Source 的函数和调用 rand 包中函数是相同的。</span></span><br><span class="line">	fmt.Print(r1.Intn(<span class="number">100</span>), <span class="string">","</span>)</span><br><span class="line">	fmt.Print(r1.Intn(<span class="number">100</span>))</span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="comment">// 如果使用相同的种子生成的随机数生成器，将会产生相同的随机数序列。</span></span><br><span class="line">	s2 := rand.NewSource(<span class="number">42</span>)</span><br><span class="line">	r2 := rand.New(s2)</span><br><span class="line">	fmt.Print(r2.Intn(<span class="number">100</span>), <span class="string">","</span>)</span><br><span class="line">	fmt.Print(r2.Intn(<span class="number">100</span>))</span><br><span class="line">	fmt.Println()</span><br><span class="line">	s3 := rand.NewSource(<span class="number">42</span>)</span><br><span class="line">	r3 := rand.New(s3)</span><br><span class="line">	fmt.Print(r3.Intn(<span class="number">100</span>), <span class="string">","</span>)</span><br><span class="line">	fmt.Print(r3.Intn(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SHA1-散列"><a href="#SHA1-散列" class="headerlink" title="SHA1 散列"></a>SHA1 散列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">"sha1"</span></span><br><span class="line">	<span class="comment">// 产生一个散列值得方式是 sha1.New()，sha1.Write(bytes)，然后 sha1.Sum([]byte&#123;&#125;)。这里我们从一个新的散列开始。</span></span><br><span class="line">	h := sha1.New()</span><br><span class="line">	<span class="comment">// 写入要处理的字节。如果是一个字符串，需要使用[]byte(s) 来强制转换成字节数组。</span></span><br><span class="line">	h.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">	<span class="comment">// 这个用来得到最终的散列值的字符切片。Sum 的参数可以用来都现有的字符切片追加额外的字节切片：一般不需要要。</span></span><br><span class="line">	bs := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// SHA1 值经常以 16 进制输出，例如在 git commit 中。使用%x 来将散列结果格式化为 16 进制字符串。</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	fmt.Printf(<span class="string">"%x\n"</span>, bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BASE64-编码"><a href="#BASE64-编码" class="headerlink" title="BASE64 编码"></a>BASE64 编码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这是将要编解码的字符串。</span></span><br><span class="line">	data := <span class="string">"abc123!?$*&amp;()'-=@~"</span></span><br><span class="line">	<span class="comment">// Go 同时支持标准的和 URL 兼容的 base64 格式。编码需要使用 []byte 类型的参数，所以要将字符串转成此类型。</span></span><br><span class="line">	<span class="comment">// 标准 base64 编码和 URL 兼容 base64 编码的编码字符串存在稍许不同（后缀为 + 和 -），但是两者都可以正确解码为原始字符串。</span></span><br><span class="line">	sEnc := base64.StdEncoding.EncodeToString([]<span class="keyword">byte</span>(data))</span><br><span class="line">	fmt.Println(sEnc)</span><br><span class="line">	<span class="comment">// 解码可能会返回错误，如果不确定输入信息格式是否正确，那么，你就需要进行错误检查了。</span></span><br><span class="line">	sDec, _ := base64.StdEncoding.DecodeString(sEnc)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(sDec))</span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="comment">// 使用 URL 兼容的 base64 格式进行编解码。</span></span><br><span class="line">	uEnc := base64.URLEncoding.EncodeToString([]<span class="keyword">byte</span>(data))</span><br><span class="line">	fmt.Println(uEnc)</span><br><span class="line">	uDec, _ := base64.URLEncoding.DecodeString(uEnc)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(uDec))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(from <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		fmt.Println(from, <span class="string">":"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 假设我们有一个函数叫做 f(s)。我们使用一般的方式调并同时运行。</span></span><br><span class="line">	f(<span class="string">"direct"</span>)</span><br><span class="line">	<span class="comment">// 使用 go f(s) 在一个 Go 协程中调用这个函数。这个新的 Go 协程将会并行的执行这个函数调用。</span></span><br><span class="line">	<span class="keyword">go</span> f(<span class="string">"goroutine"</span>)</span><br><span class="line">	<span class="comment">// 你也可以为匿名函数启动一个 Go 协程。</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(msg)</span><br><span class="line">	&#125;(<span class="string">"going"</span>)</span><br><span class="line">	<span class="comment">// 现在这两个 Go 协程在独立的 Go 协程中异步的运行，所以我们需要等它们执行结束。这里的 Scanln 代码需要我们在程序退出前按下任意键结束。</span></span><br><span class="line">	<span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">	fmt.Scanln(&amp;input)</span><br><span class="line">	fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">	<span class="comment">// 当我们运行这个程序时，将首先看到阻塞式调用的输出，然后是两个 Go 协程的交替输出。这种交替的情况表示 Go 运行时是以异步的方式运行协程的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通道 是连接多个 Go 协程的管道。你可以从一个 Go 协程将值发送到通道，然后在别的 Go 协程中接收。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用 make(chan val-type) 创建一个新的通道。通道类型就是他们需要传递值的类型。</span></span><br><span class="line">	messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="comment">// 使用 channel &lt;- 语法 发送 一个新的值到通道中。这里我们在一个新的 Go 协程中发送 "ping" 到上面创建的messages 通道中。</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; messages &lt;- <span class="string">"ping"</span> &#125;()</span><br><span class="line">	<span class="comment">// 使用 &lt;-channel 语法从通道中 接收 一个值。这里将接收我们在上面发送的 "ping" 消息并打印出来。</span></span><br><span class="line">	msg := &lt;-messages</span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们运行程序时，通过通道，消息 "ping" 成功的从一个 Go 协程传到另一个中。</span></span><br><span class="line"><span class="comment">// 默认发送和接收操作是阻塞的，直到发送方和接收方都准备完毕。这个特性允许我们，不使用任何其它的同步操作，来在程序结尾等待消息 "ping"。</span></span><br></pre></td></tr></table></figure>
<h3 id="通道缓冲"><a href="#通道缓冲" class="headerlink" title="通道缓冲"></a>通道缓冲</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认通道是 无缓冲 的，这意味着只有在对应的接收（&lt;- chan）通道准备好接收时，才允许进行发送（chan &lt;-）。可缓存通道允许在没有对应接收方的情况下，缓存限定数量的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里我们 make 了一个通道，最多允许缓存 2 个值。</span></span><br><span class="line">	messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="comment">// 因为这个通道是有缓冲区的，即使没有一个对应的并发接收方，我们仍然可以发送这些值。</span></span><br><span class="line">	messages &lt;- <span class="string">"buffered"</span></span><br><span class="line">	messages &lt;- <span class="string">"channel"</span></span><br><span class="line">	<span class="comment">// 然后我们可以像前面一样接收这两个值。</span></span><br><span class="line">	fmt.Println(&lt;-messages)</span><br><span class="line">	fmt.Println(&lt;-messages)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通道同步"><a href="#通道同步" class="headerlink" title="通道同步"></a>通道同步</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们可以使用通道来同步 Go 协程间的执行状态。这里是一个使用阻塞的接受方式来等待一个 Go 协程的运行结束。</span></span><br><span class="line"><span class="comment">// 这是一个我们将要在 Go 协程中运行的函数。done 通道将被用于通知其他 Go 协程这个函数已经工作完毕。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">"working..."</span>)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">	<span class="comment">// 发送一个值来通知我们已经完工啦。</span></span><br><span class="line">	done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 运行一个 worker Go协程，并给予用于通知的通道。</span></span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> worker(done)</span><br><span class="line">	<span class="comment">// 程序将在接收到通道中 worker 发出的通知前一直阻塞。</span></span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你把 &lt;- done 这行代码从程序中移除，程序甚至会在 worker还没开始运行时就结束了</span></span><br></pre></td></tr></table></figure>
<h3 id="通道方向"><a href="#通道方向" class="headerlink" title="通道方向"></a>通道方向</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ping 函数定义了一个只允许发送数据的通道。尝试使用这个通道来接收数据将会得到一个编译时错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping</span><span class="params">(pings <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>, msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	pings &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pong 函数允许通道（pings）来接收数据，另一通道（pongs）来发送数据。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pong</span><span class="params">(pings &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>, pongs <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	msg := &lt;-pings</span><br><span class="line">	pongs &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pings := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">	pongs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">	ping(pings, <span class="string">"passed message"</span>)</span><br><span class="line">	pong(pings, pongs)</span><br><span class="line">	fmt.Println(&lt;-pongs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通道选择器"><a href="#通道选择器" class="headerlink" title="通道选择器"></a>通道选择器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在我们的例子中，我们将从两个通道中选择。</span></span><br><span class="line">	c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="comment">// 各个通道将在若干时间后接收一个值，这个用来模拟例如并行的 Go 协程中阻塞的 RPC 操作</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">		c1 &lt;- <span class="string">"one"</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">		c2 &lt;- <span class="string">"two"</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 我们使用 select 关键字来同时等待这两个值，并打印各自接收到的值。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">			fmt.Println(<span class="string">"received"</span>, msg1)</span><br><span class="line">		<span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">			fmt.Println(<span class="string">"received"</span>, msg2)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在我们的例子中，假如我们执行一个外部调用，并在 2 秒后通过通道 c1 返回它的执行结果。</span></span><br><span class="line">	c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">		c1 &lt;- <span class="string">"result 1"</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 这里是使用 select 实现一个超时操作。res := &lt;- c1 等待结果，&lt;-Time.After 等待超时时间 1 秒后发送的值。由于 select 默认处理第一个已准备好的接收操作，如果这个操作超过了允许的 1 秒的话，将会执行超时 case。</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> res := &lt;-c1:</span><br><span class="line">		fmt.Println(res)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>):</span><br><span class="line">		fmt.Println(<span class="string">"timeout 1"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果我允许一个长一点的超时时间 3 秒，将会成功的从 c2接收到值，并且打印出结果。</span></span><br><span class="line">	c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">		c2 &lt;- <span class="string">"result 2"</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> res := &lt;-c2:</span><br><span class="line">		fmt.Println(res)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">3</span>):</span><br><span class="line">		fmt.Println(<span class="string">"timeout 2"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非阻塞通道"><a href="#非阻塞通道" class="headerlink" title="非阻塞通道"></a>非阻塞通道</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规的通过通道发送和接收数据是阻塞的。然而，我们可以使用带一个 default 子句的 select 来实现非阻塞 的发送、接收，甚至是非阻塞的多路 select。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	signals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="comment">// 这里是一个非阻塞接收的例子。如果在 messages 中存在，然后 select 将这个值带入 &lt;-messages case中。如果不是，就直接到 default 分支中。</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> msg := &lt;-messages:</span><br><span class="line">		fmt.Println(<span class="string">"received message"</span>, msg)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"no message received"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 一个非阻塞发送的实现方法和上面一样。</span></span><br><span class="line">	msg := <span class="string">"hi"</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> messages &lt;- msg:</span><br><span class="line">		fmt.Println(<span class="string">"sent message"</span>, msg)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"no message sent"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 我们可以在 default 前使用多个 case 子句来实现一个多路的非阻塞的选择器。这里我们试图在 messages和 signals 上同时使用非阻塞的接受操作。</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> msg := &lt;-messages:</span><br><span class="line">		fmt.Println(<span class="string">"received message"</span>, msg)</span><br><span class="line">	<span class="keyword">case</span> sig := &lt;-signals:</span><br><span class="line">		fmt.Println(<span class="string">"received signal"</span>, sig)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"no activity"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通道的关闭"><a href="#通道的关闭" class="headerlink" title="通道的关闭"></a>通道的关闭</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭 一个通道意味着不能再向这个通道发送值了。这个特性可以用来给这个通道的接收方传达工作已经完成的信息。</span></span><br><span class="line"><span class="comment">// 在这个例子中，我们将使用一个 jobs 通道来传递 main() 中 Go协程任务执行的结束信息到一个工作 Go 协程中。当我们没有多余的任务给这个工作 Go 协程时，我们将 close 这个 jobs 通道。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="comment">// 这是工作 Go 协程。使用 j, more := &lt;- jobs 循环的从jobs 接收数据。在接收的这个特殊的二值形式的值中，如果 jobs 已经关闭了，并且通道中所有的值都已经接收完毕，那么 more 的值将是 false。当我们完成所有的任务时，将使用这个特性通过 done 通道去进行通知。</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			j, more := &lt;-jobs</span><br><span class="line">			<span class="keyword">if</span> more &#123;</span><br><span class="line">				fmt.Println(<span class="string">"received job"</span>, j)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">"received all jobs"</span>)</span><br><span class="line">				done &lt;- <span class="literal">true</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 这里使用 jobs 发送 3 个任务到工作函数中，然后关闭 jobs。</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++ &#123;</span><br><span class="line">		jobs &lt;- j</span><br><span class="line">		fmt.Println(<span class="string">"sent job"</span>, j)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(jobs)</span><br><span class="line">	fmt.Println(<span class="string">"sent all jobs"</span>)</span><br><span class="line">	<span class="comment">// 我们使用前面学到的通道同步方法等待任务结束。</span></span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通道遍历"><a href="#通道遍历" class="headerlink" title="通道遍历"></a>通道遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在前面的例子中，我们讲过 for 和 range为基本的数据结构提供了迭代的功能。我们也可以使用这个语法来遍历从通道中取得的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 我们将遍历在 queue 通道中的两个值。</span></span><br><span class="line">	queue := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">	queue &lt;- <span class="string">"one"</span></span><br><span class="line">	queue &lt;- <span class="string">"two"</span></span><br><span class="line">	<span class="built_in">close</span>(queue)</span><br><span class="line">	<span class="comment">// 这个 range 迭代从 queue 中得到的每个值。因为我们在前面 close 了这个通道，这个迭代会在接收完 2 个值之后结束。如果我们没有 close 它，我们将在这个循环中继续阻塞执行，等待接收第三个值</span></span><br><span class="line">	<span class="keyword">for</span> elem := <span class="keyword">range</span> queue &#123;</span><br><span class="line">		fmt.Println(elem)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个例子也让我们看到，一个非空的通道也是可以关闭的，但是通道中剩下的值仍然可以被接收到。</span></span><br></pre></td></tr></table></figure>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定时器表示在未来某一时刻的独立事件。你告诉定时器需要等待的时间，然后它将提供一个用于通知的通道。这里的定时器将等待 2 秒。</span></span><br><span class="line">	timer1 := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">	<span class="comment">// &lt;-timer1.C 直到这个定时器的通道 C 明确的发送了定时器失效的值之前，将一直阻塞。</span></span><br><span class="line">	&lt;-timer1.C</span><br><span class="line">	fmt.Println(<span class="string">"Timer 1 expired"</span>)</span><br><span class="line">	<span class="comment">// 如果你需要的仅仅是单纯的等待，你需要使用 time.Sleep。定时器是有用原因之一就是你可以在定时器失效之前，取消这个定时器。这是一个例子</span></span><br><span class="line">	timer2 := time.NewTimer(time.Second)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-timer2.C</span><br><span class="line">		fmt.Println(<span class="string">"Timer 2 expired"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	stop2 := timer2.Stop()</span><br><span class="line">	<span class="keyword">if</span> stop2 &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Timer 2 stopped"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打点器"><a href="#打点器" class="headerlink" title="打点器"></a>打点器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打点器和定时器的机制有点相似：一个通道用来发送数据。这里我们在这个通道上使用内置的 range 来迭代值每隔500ms 发送一次的值。</span></span><br><span class="line">	ticker := time.NewTicker(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> t := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Tick at"</span>, t)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 打点器可以和定时器一样被停止。一旦一个打点停止了，将不能再从它的通道中接收到值。我们将在运行后 1600ms停止这个打点器。</span></span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">1600</span>)</span><br><span class="line">	ticker.Stop()</span><br><span class="line">	fmt.Println(<span class="string">"Ticker stopped"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="工作池"><a href="#工作池" class="headerlink" title="工作池"></a>工作池</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是我们将要在多个并发实例中支持的任务了。这些执行者将从 jobs 通道接收任务，并且通过 results 发送对应的结果。我们将让每个任务间隔 1s 来模仿一个耗时的任务。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, results <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> j := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">		fmt.Println(<span class="string">"worker"</span>, id, <span class="string">"processing job"</span>, j)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		results &lt;- j * <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 为了使用 worker 工作池并且收集他们的结果，我们需要2 个通道。</span></span><br><span class="line">	jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">	results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="comment">// 这里启动了 3 个 worker，初始是阻塞的，因为还没有传递任务。</span></span><br><span class="line">	<span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= <span class="number">3</span>; w++ &#123;</span><br><span class="line">		<span class="keyword">go</span> worker(w, jobs, results)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里我们发送 9 个 jobs，然后 close 这些通道来表示这些就是所有的任务了。</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++ &#123;</span><br><span class="line">		jobs &lt;- j</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(jobs)</span><br><span class="line">	<span class="comment">// 最后，我们收集所有这些任务的返回值。</span></span><br><span class="line">	<span class="keyword">for</span> a := <span class="number">1</span>; a &lt;= <span class="number">9</span>; a++ &#123;</span><br><span class="line">		&lt;-results</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行这个程序，显示 9 个任务被多个 worker 执行。整个程序处理所有的任务仅执行了 3s 而不是 9s，是因为 3 个 worker是并行的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="速率限制-未懂"><a href="#速率限制-未懂" class="headerlink" title="速率限制(未懂)"></a>速率限制(未懂)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 首先我们将看一下基本的速率限制。假设我们想限制我们接收请求的处理，我们将这些请求发送给一个相同的通道。</span></span><br><span class="line">	requests := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		requests &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(requests)</span><br><span class="line">	<span class="comment">// 这个 limiter 通道将每 200ms 接收一个值。这个是速率限制任务中的管理器。</span></span><br><span class="line">	limiter := time.Tick(time.Millisecond * <span class="number">200</span>)</span><br><span class="line">	<span class="comment">// 通过在每次请求前阻塞 limiter 通道的一个接收，我们限制自己每 200ms 执行一次请求。</span></span><br><span class="line">	<span class="keyword">for</span> req := <span class="keyword">range</span> requests &#123;</span><br><span class="line">		&lt;-limiter</span><br><span class="line">		fmt.Println(<span class="string">"request"</span>, req, time.Now())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 有时候我们想临时进行速率限制，并且不影响整体的速率控制我们可以通过通道缓冲来实现。这个 burstyLimiter 通道用来进行 3 次临时的脉冲型速率限制。</span></span><br><span class="line">	burstyLimiter := <span class="built_in">make</span>(<span class="keyword">chan</span> time.Time, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 想将通道填充需要临时改变3次的值，做好准备。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		burstyLimiter &lt;- time.Now()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 每 200 ms 我们将添加一个新的值到 burstyLimiter中，直到达到 3 个的限制。</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> t := <span class="keyword">range</span> time.Tick(time.Millisecond * <span class="number">200</span>) &#123;</span><br><span class="line">			burstyLimiter &lt;- t</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 现在模拟超过 5 个的接入请求。它们中刚开始的 3 个将由于受 burstyLimiter 的“脉冲”影响。</span></span><br><span class="line">	burstyRequests := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		burstyRequests &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(burstyRequests)</span><br><span class="line">	<span class="keyword">for</span> req := <span class="keyword">range</span> burstyRequests &#123;</span><br><span class="line">		&lt;-burstyLimiter</span><br><span class="line">		fmt.Println(<span class="string">"request"</span>, req, time.Now())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 运行程序，我们看到第一批请求意料之中的大约每 200ms 处理一次。</span></span><br><span class="line">	<span class="comment">// 第二批请求，我们直接连续处理了 3 次，这是由于这个“脉冲”速率控制，然后大约每 200ms 处理其余的 2 个。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原子计数器"><a href="#原子计数器" class="headerlink" title="原子计数器"></a>原子计数器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 我们将使用一个无符号整型数来表示（永远是正整数）这个计数器。</span></span><br><span class="line">	<span class="keyword">var</span> ops <span class="keyword">uint64</span> = <span class="number">0</span></span><br><span class="line">	<span class="comment">// 为了模拟并发更新，我们启动 50 个 Go 协程，对计数器每隔 1ms （译者注：应为非准确时间）进行一次加一操作。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="comment">// 使用 AddUint64 来让计数器自动增加，使用&amp; 语法来给出 ops 的内存地址。</span></span><br><span class="line">				atomic.AddUint64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">				<span class="comment">// 允许其它 Go 协程的执行</span></span><br><span class="line">				runtime.Gosched()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等待一秒，让 ops 的自加操作执行一会。</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="comment">// 为了在计数器还在被其它 Go 协程更新时，安全的使用它，我们通过 LoadUint64 将当前值的拷贝提取到 opsFinal中。和上面一样，我们需要给这个函数所取值的内存地址 &amp;ops</span></span><br><span class="line">	opsFinal := atomic.LoadUint64(&amp;ops)</span><br><span class="line">	fmt.Println(<span class="string">"ops:"</span>, opsFinal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="互斥锁-未懂"><a href="#互斥锁-未懂" class="headerlink" title="互斥锁(未懂)"></a>互斥锁(未懂)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在我们的例子中，state 是一个 map。</span></span><br><span class="line">	<span class="keyword">var</span> state = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="comment">// 这里的 mutex 将同步对 state 的访问。</span></span><br><span class="line">	<span class="keyword">var</span> mutex = &amp;sync.Mutex&#123;&#125;</span><br><span class="line">	<span class="comment">// we'll see later, ops will count how manyoperations we perform against the state.为了比较基于互斥锁的处理方式和我们后面将要看到的其他方式，ops 将记录我们对 state 的操作次数。</span></span><br><span class="line">	<span class="keyword">var</span> ops <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line">	<span class="comment">// 这里我们运行 100 个 Go 协程来重复读取 state。</span></span><br><span class="line">	<span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="number">100</span>; r++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			total := <span class="number">0</span></span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="comment">// 每次循环读取，我们使用一个键来进行访问，Lock() 这个 mutex 来确保对 state 的独占访问，读取选定的键的值，Unlock() 这个mutex，并且 ops 值加 1。</span></span><br><span class="line">				key := rand.Intn(<span class="number">5</span>)</span><br><span class="line">				mutex.Lock()</span><br><span class="line">				total += state[key]</span><br><span class="line">				mutex.Unlock()</span><br><span class="line">				atomic.AddInt64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">				<span class="comment">// 为了确保这个 Go 协程不会在调度中饿死，我们在每次操作后明确的使用 runtime.Gosched()进行释放。这个释放一般是自动处理的，像例如每个通道操作后或者 time.Sleep 的阻塞调用后相似，但是在这个例子中我们需要手动的处理。</span></span><br><span class="line">				runtime.Gosched()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 同样的，我们运行 10 个 Go 协程来模拟写入操作，使用和读取相同的模式。</span></span><br><span class="line">	<span class="keyword">for</span> w := <span class="number">0</span>; w &lt; <span class="number">10</span>; w++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				key := rand.Intn(<span class="number">5</span>)</span><br><span class="line">				val := rand.Intn(<span class="number">100</span>)</span><br><span class="line">				mutex.Lock()</span><br><span class="line">				state[key] = val</span><br><span class="line">				mutex.Unlock()</span><br><span class="line">				atomic.AddInt64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">				runtime.Gosched()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 让这 10 个 Go 协程对 state 和 mutex 的操作运行 1 s。</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="comment">// 获取并输出最终的操作计数。</span></span><br><span class="line">	opsFinal := atomic.LoadInt64(&amp;ops)</span><br><span class="line">	fmt.Println(<span class="string">"ops:"</span>, opsFinal)</span><br><span class="line">	<span class="comment">// 对 state 使用一个最终的锁，显示它是如何结束的。</span></span><br><span class="line">	mutex.Lock()</span><br><span class="line">	fmt.Println(<span class="string">"state:"</span>, state)</span><br><span class="line">	mutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="go状态协程-未读"><a href="#go状态协程-未读" class="headerlink" title="go状态协程(未读)"></a><code>go</code>状态协程(未读)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这个例子中，state 将被一个单独的 Go 协程拥有。这就能够保证数据在并行读取时不会混乱。为了对 state 进行读取或者写入，其他的 Go 协程将发送一条数据到拥有的 Go协程中，然后接收对应的回复。结构体 readOp 和 writeOp封装这些请求，并且是拥有 Go 协程响应的一个方式。</span></span><br><span class="line"><span class="keyword">type</span> readOp <span class="keyword">struct</span> &#123;</span><br><span class="line">	key  <span class="keyword">int</span></span><br><span class="line">	resp <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> writeOp <span class="keyword">struct</span> &#123;</span><br><span class="line">	key  <span class="keyword">int</span></span><br><span class="line">	val  <span class="keyword">int</span></span><br><span class="line">	resp <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 和前面一样，我们将计算我们执行操作的次数。</span></span><br><span class="line">	<span class="keyword">var</span> ops <span class="keyword">int64</span></span><br><span class="line">	<span class="comment">// reads 和 writes 通道分别将被其他 Go 协程用来发布读和写请求。</span></span><br><span class="line">	reads := <span class="built_in">make</span>(<span class="keyword">chan</span> *readOp)</span><br><span class="line">	writes := <span class="built_in">make</span>(<span class="keyword">chan</span> *writeOp)</span><br><span class="line">	<span class="comment">// 这个就是拥有 state 的那个 Go 协程，和前面例子中的map一样，不过这里是被这个状态协程私有的。这个 Go 协程反复响应到达的请求。先响应到达的请求，然后返回一个值到响应通道 resp 来表示操作成功（或者是 reads 中请求的值）</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> state = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> read := &lt;-reads:</span><br><span class="line">				read.resp &lt;- state[read.key]</span><br><span class="line">			<span class="keyword">case</span> write := &lt;-writes:</span><br><span class="line">				state[write.key] = write.val</span><br><span class="line">				write.resp &lt;- <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 启动 100 个 Go 协程通过 reads 通道发起对 state 所有者Go 协程的读取请求。每个读取请求需要构造一个 readOp，发送它到 reads 通道中，并通过给定的 resp 通道接收结果。</span></span><br><span class="line">	<span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="number">100</span>; r++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				read := &amp;readOp&#123;</span><br><span class="line">					key:  rand.Intn(<span class="number">5</span>),</span><br><span class="line">					resp: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)&#125;</span><br><span class="line">				reads &lt;- read</span><br><span class="line">				&lt;-read.resp</span><br><span class="line">				atomic.AddInt64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 用相同的方法启动 10 个写操作。</span></span><br><span class="line">	<span class="keyword">for</span> w := <span class="number">0</span>; w &lt; <span class="number">10</span>; w++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				write := &amp;writeOp&#123;</span><br><span class="line">					key:  rand.Intn(<span class="number">5</span>),</span><br><span class="line">					val:  rand.Intn(<span class="number">100</span>),</span><br><span class="line">					resp: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)&#125;</span><br><span class="line">				writes &lt;- write</span><br><span class="line">				&lt;-write.resp</span><br><span class="line">				atomic.AddInt64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 让 Go 协程们跑 1s。</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="comment">// 最后，获取并报告 ops 值。</span></span><br><span class="line">	opsFinal := atomic.LoadInt64(&amp;ops)</span><br><span class="line">	fmt.Println(<span class="string">"ops:"</span>, opsFinal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文件需要经常进行错误检查，这个帮助方法可以精简下面的错误检查过程。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(e error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 也许大部分基本的文件读取任务是将文件内容读取到内存中。</span></span><br><span class="line">	dat, err := ioutil.ReadFile(<span class="string">"/tmp/dat"</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	fmt.Print(<span class="keyword">string</span>(dat))</span><br><span class="line">	<span class="comment">// 你经常会想对于一个文件是怎么读并且读取到哪一部分进行更多的控制。对于这个任务，从使用 os.Open打开一个文件获取一个 os.File 值开始。</span></span><br><span class="line">	f, err := os.Open(<span class="string">"/tmp/dat"</span>)</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	check(err)</span><br><span class="line">	<span class="comment">// 从文件开始位置读取一些字节。这里最多读取 5 个字节，并且这也是我们实际读取的字节数。</span></span><br><span class="line">	b1 := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br><span class="line">	n1, err := f.Read(b1)</span><br><span class="line">	check(err)</span><br><span class="line">	fmt.Printf(<span class="string">"%d bytes: %s\n"</span>, n1, <span class="keyword">string</span>(b1))</span><br><span class="line">	<span class="comment">// 你也可以 Seek 到一个文件中已知的位置并从这个位置开始进行读取。</span></span><br><span class="line">	o2, err := f.Seek(<span class="number">6</span>, <span class="number">0</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	b2 := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line">	n2, err := f.Read(b2)</span><br><span class="line">	check(err)</span><br><span class="line">	fmt.Printf(<span class="string">"%d bytes @ %d: %s\n"</span>, n2, o2, <span class="keyword">string</span>(b2))</span><br><span class="line">	<span class="comment">// io 包提供了一些可以帮助我们进行文件读取的函数。例如，上面的读取可以使用 ReadAtLeast 得到一个更健壮的实现。</span></span><br><span class="line">	o3, err := f.Seek(<span class="number">6</span>, <span class="number">0</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	b3 := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line">	n3, err := io.ReadAtLeast(f, b3, <span class="number">2</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	fmt.Printf(<span class="string">"%d bytes @ %d: %s\n"</span>, n3, o3, <span class="keyword">string</span>(b3))</span><br><span class="line">	<span class="comment">// 没有内置的回转支持，但是使用 Seek(0, 0) 实现。</span></span><br><span class="line">	_, err = f.Seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	<span class="comment">// bufio 包实现了带缓冲的读取，这不仅对有很多小的读取操作的能提升性能，也提供了很多附加的读取函数。</span></span><br><span class="line">	r4 := bufio.NewReader(f)</span><br><span class="line">	b4, err := r4.Peek(<span class="number">5</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	fmt.Printf(<span class="string">"5 bytes: %s\n"</span>, <span class="keyword">string</span>(b4))</span><br><span class="line">	<span class="comment">// 任务结束后要关闭这个文件（通常这个操作应该在 Open操作后立即使用 defer 来完成）。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 开始，这里是展示如写入一个字符串（或者只是一些字节）到一个文件。</span></span><br><span class="line">	d1 := []<span class="keyword">byte</span>(<span class="string">"hello\ngo\n"</span>)</span><br><span class="line">	err := ioutil.WriteFile(<span class="string">"/tmp/dat1"</span>, d1, <span class="number">0644</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	<span class="comment">// 对于更细粒度的写入，先打开一个文件。</span></span><br><span class="line">	f, err := os.Create(<span class="string">"/tmp/dat2"</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	<span class="comment">// 打开文件后，习惯立即使用 defer 调用文件的 Close操作。</span></span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	<span class="comment">// 你可以写入你想写入的字节切片</span></span><br><span class="line">	d2 := []<span class="keyword">byte</span>&#123;<span class="number">115</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">10</span>&#125;</span><br><span class="line">	n2, err := f.Write(d2)</span><br><span class="line">	check(err)</span><br><span class="line">	fmt.Printf(<span class="string">"wrote %d bytes\n"</span>, n2)</span><br><span class="line">	<span class="comment">// WriteString 也是可用的。</span></span><br><span class="line">	n3, err := f.WriteString(<span class="string">"writes\n"</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"wrote %d bytes\n"</span>, n3)</span><br><span class="line">	<span class="comment">// 调用 Sync 来将缓冲区的信息写入磁盘。</span></span><br><span class="line">	f.Sync()</span><br><span class="line">	<span class="comment">// bufio 提供了和我们前面看到的带缓冲的读取器一样的带缓冲的写入器。</span></span><br><span class="line">	w := bufio.NewWriter(f)</span><br><span class="line">	n4, err := w.WriteString(<span class="string">"buffered\n"</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"wrote %d bytes\n"</span>, n4)</span><br><span class="line">	<span class="comment">// 使用 Flush 来确保所有缓存的操作已写入底层写入器。</span></span><br><span class="line">	w.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="行过滤器"><a href="#行过滤器" class="headerlink" title="行过滤器"></a>行过滤器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在读取标准输入流的输入，处理该输入，然后将得到一些的结果输出到标准输出的程序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 对 os.Stdin 使用一个带缓冲的 scanner，让我们可以直接使用方便的 Scan 方法来直接读取一行，每次调用该方法可以让 scanner 读取下一行。</span></span><br><span class="line">	scanner := bufio.NewScanner(os.Stdin)</span><br><span class="line">	<span class="comment">// Text 返回当前的 token，现在是输入的下一行。</span></span><br><span class="line">	<span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">		ucl := strings.ToUpper(scanner.Text())</span><br><span class="line">		<span class="comment">// 写出大写的行。</span></span><br><span class="line">		fmt.Println(ucl)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 检查 Scan 的错误。文件结束符是可以接受的，并且不会被 Scan 当作一个错误。</span></span><br><span class="line">	<span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintln(os.Stderr, <span class="string">"error:"</span>, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令行参数是指定程序运行参数的一个常见方式。例如，go run hello.go，程序 go 使用了 run 和 hello.go 两个参数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// os.Args 提供原始命令行参数访问功能。注意，切片中的第一个参数是该程序的路径，并且 os.Args[1:]保存所有程序的的参数。</span></span><br><span class="line">	argsWithProg := os.Args</span><br><span class="line">	argsWithoutProg := os.Args[<span class="number">1</span>:]</span><br><span class="line">	<span class="comment">// 你可以使用标准的索引位置方式取得单个参数的值。</span></span><br><span class="line">	arg := os.Args[<span class="number">3</span>]</span><br><span class="line">	fmt.Println(argsWithProg)    <span class="comment">// [./command-line-arguments a b c d]</span></span><br><span class="line">	fmt.Println(argsWithoutProg) <span class="comment">// [a b c d]</span></span><br><span class="line">	fmt.Println(arg)             <span class="comment">// c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要实验命令行参数，最好先使用 go build 编译一个可执行二进制文件</span></span><br><span class="line"><span class="comment">// $ go build command-line-arguments.go</span></span><br><span class="line"><span class="comment">// $ ./command-line-arguments a b c d</span></span><br></pre></td></tr></table></figure>
<h3 id="命令行标志-未懂"><a href="#命令行标志-未懂" class="headerlink" title="命令行标志(未懂)"></a>命令行标志(未懂)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 基本的标记声明仅支持字符串、整数和布尔值选项。这里我们声明一个默认值为 "foo" 的字符串标志 word并带有一个简短的描述。</span></span><br><span class="line">	<span class="comment">// 这里的 flag.String 函数返回一个字符串指针（不是一个字符串值），在下面我们会看到是如何使用这个指针的。</span></span><br><span class="line">	wordPtr := flag.String(<span class="string">"word"</span>, <span class="string">"foo"</span>, <span class="string">"a string"</span>)</span><br><span class="line">	<span class="comment">// 使用和声明 word 标志相同的方法来声明 numb 和 fork 标志。</span></span><br><span class="line">	numbPtr := flag.Int(<span class="string">"numb"</span>, <span class="number">42</span>, <span class="string">"an int"</span>)</span><br><span class="line">	boolPtr := flag.Bool(<span class="string">"fork"</span>, <span class="literal">false</span>, <span class="string">"a bool"</span>)</span><br><span class="line">	<span class="comment">// 用程序中已有的参数来声明一个标志也是可以的。注意在标志声明函数中需要使用该参数的指针。</span></span><br><span class="line">	<span class="keyword">var</span> svar <span class="keyword">string</span></span><br><span class="line">	flag.StringVar(&amp;svar, <span class="string">"svar"</span>, <span class="string">"bar"</span>, <span class="string">"a string var"</span>)</span><br><span class="line">	<span class="comment">// 所有标志都声明完成以后，调用 flag.Parse() 来执行命令行解析。</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// 这里我们将仅输出解析的选项以及后面的位置参数。注意，我们需要使用类似 *wordPtr 这样的语法来对指针解引用，从而得到选项的实际值。</span></span><br><span class="line">	fmt.Println(<span class="string">"word:"</span>, *wordPtr)</span><br><span class="line">	fmt.Println(<span class="string">"numb:"</span>, *numbPtr)</span><br><span class="line">	fmt.Println(<span class="string">"fork:"</span>, *boolPtr)</span><br><span class="line">	fmt.Println(<span class="string">"svar:"</span>, svar)</span><br><span class="line">	fmt.Println(<span class="string">"tail:"</span>, flag.Args())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试这个程序前，最好将这个程序编译成二进制文件，然后再运行这个程序。</span></span><br><span class="line"><span class="comment">// $ go build command-line-flags.go</span></span><br><span class="line"><span class="comment">// word: opt</span></span><br><span class="line"><span class="comment">// numb: 7</span></span><br><span class="line"><span class="comment">// fork: true</span></span><br><span class="line"><span class="comment">// svar: flag</span></span><br><span class="line"><span class="comment">// tail: []</span></span><br><span class="line"><span class="comment">// 注意到，如果你省略一个标志，那么这个标志的值自动的设定为他的默认值。</span></span><br><span class="line"><span class="comment">// $ ./command-line-flags -word=opt</span></span><br><span class="line"><span class="comment">// word: opt</span></span><br><span class="line"><span class="comment">// numb: 42</span></span><br><span class="line"><span class="comment">// fork: false</span></span><br><span class="line"><span class="comment">// svar: bar</span></span><br><span class="line"><span class="comment">// tail: []</span></span><br><span class="line"><span class="comment">// 位置参数可以出现在任何标志后面。</span></span><br><span class="line"><span class="comment">// $ ./command-line-flags -word=opt a1 a2 a3</span></span><br><span class="line"><span class="comment">// word: opt</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// tail: [a1 a2 a3]</span></span><br><span class="line"><span class="comment">// 注意，flag 包需要所有的标志出现位置参数之前（否则，这个标志将会被解析为位置参数）。</span></span><br><span class="line"><span class="comment">// $ ./command-line-flags -word=opt a1 a2 a3 -numb=7</span></span><br><span class="line"><span class="comment">// word: opt</span></span><br><span class="line"><span class="comment">// numb: 42</span></span><br><span class="line"><span class="comment">// fork: false</span></span><br><span class="line"><span class="comment">// svar: bar</span></span><br><span class="line"><span class="comment">// trailing: [a1 a2 a3 -numb=7]</span></span><br><span class="line"><span class="comment">// 使用 -h 或者 --help 标志来得到自动生成的这个命令行程序的帮助文本。</span></span><br><span class="line"><span class="comment">// $ ./command-line-flags -h</span></span><br><span class="line"><span class="comment">// Usage of ./command-line-flags:</span></span><br><span class="line"><span class="comment">//   -fork=false: a bool</span></span><br><span class="line"><span class="comment">//   -numb=42: an int</span></span><br><span class="line"><span class="comment">//   -svar="bar": a string var</span></span><br><span class="line"><span class="comment">//   -word="foo": a string</span></span><br><span class="line"><span class="comment">// 如果你提供一个没有使用 flag 包指定的标志，程序会输出一个错误信息，并再次显示帮助文本。</span></span><br><span class="line"><span class="comment">// $ ./command-line-flags -wat</span></span><br><span class="line"><span class="comment">// flag provided but not defined: -wat</span></span><br><span class="line"><span class="comment">// Usage of ./command-line-flags:</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="环境变量-未懂"><a href="#环境变量-未懂" class="headerlink" title="环境变量(未懂)"></a>环境变量(未懂)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用 os.Setenv 来设置一个键值队。使用 os.Getenv获取一个键对应的值。如果键不存在，将会返回一个空字符串。</span></span><br><span class="line">	os.Setenv(<span class="string">"FOO"</span>, <span class="string">"1"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"FOO:"</span>, os.Getenv(<span class="string">"FOO"</span>))</span><br><span class="line">	fmt.Println(<span class="string">"BAR:"</span>, os.Getenv(<span class="string">"BAR"</span>))</span><br><span class="line">	<span class="comment">// 使用 os.Environ 来列出所有环境变量键值队。这个函数会返回一个 KEY=value 形式的字符串切片。你可以使用strings.Split 来得到键和值。这里我们打印所有的键。</span></span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="keyword">for</span> _, e := <span class="keyword">range</span> os.Environ() &#123;</span><br><span class="line">		pair := strings.Split(e, <span class="string">"="</span>)</span><br><span class="line">		fmt.Println(pair[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行这个程序，显示我们在程序中设置的 FOO 的值，然而没有设置的 BAR 是空的。</span></span><br><span class="line"><span class="comment">// $ go run environment-variables.go</span></span><br><span class="line"><span class="comment">// FOO: 1</span></span><br><span class="line"><span class="comment">// BAR:</span></span><br><span class="line"><span class="comment">// 键的列表是由你的电脑情况而定的。</span></span><br><span class="line"><span class="comment">// TERM_PROGRAM</span></span><br><span class="line"><span class="comment">// PATH</span></span><br><span class="line"><span class="comment">// SHELL</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 如果我们在运行前设置了 BAR 的值，那么运行程序将会获取到这个值。</span></span><br><span class="line"><span class="comment">// $ BAR=2 go run environment-variables.go</span></span><br><span class="line"><span class="comment">// FOO: 1</span></span><br><span class="line"><span class="comment">// BAR: 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="执行外部进程"><a href="#执行外部进程" class="headerlink" title="执行外部进程"></a>执行外部进程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 我们将从一个简单的命令开始，没有参数或者输入，仅打印一些信息到标准输出流。exec.Command 函数帮助我们创建一个表示这个外部进程的对象。</span></span><br><span class="line">	dateCmd := exec.Command(<span class="string">"date"</span>)</span><br><span class="line">	<span class="comment">// .Output 是另一个帮助我们处理运行一个命令的常见情况的函数，它等待命令运行完成，并收集命令的输出。如果没有出错，dateOut 将获取到日期信息的字节。</span></span><br><span class="line">	dateOut, err := dateCmd.Output()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"&gt; date"</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(dateOut))</span><br><span class="line">	<span class="comment">// 下面我们将看看一个稍复杂的例子，我们将从外部进程的stdin 输入数据并从 stdout 收集结果。</span></span><br><span class="line">	grepCmd := exec.Command(<span class="string">"grep"</span>, <span class="string">"hello"</span>)</span><br><span class="line">	<span class="comment">// 这里我们明确的获取输入/输出管道，运行这个进程，写入一些输入信息，读取输出的结果，最后等待程序运行结束。</span></span><br><span class="line">	grepIn, _ := grepCmd.StdinPipe()</span><br><span class="line">	grepOut, _ := grepCmd.StdoutPipe()</span><br><span class="line">	grepCmd.Start()</span><br><span class="line">	grepIn.Write([]<span class="keyword">byte</span>(<span class="string">"hello grep\ngoodbye grep"</span>))</span><br><span class="line">	grepIn.Close()</span><br><span class="line">	grepBytes, _ := ioutil.ReadAll(grepOut)</span><br><span class="line">	grepCmd.Wait()</span><br><span class="line">	<span class="comment">// 上面的例子中，我们忽略了错误检测，但是你可以使用if err != nil 的方式来进行错误检查，我们也只收集StdoutPipe 的结果，但是你可以使用相同的方法收集StderrPipe 的结果。</span></span><br><span class="line">	fmt.Println(<span class="string">"&gt; grep hello"</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(grepBytes))</span><br><span class="line">	<span class="comment">// 注意，当我们需要提供一个明确的命令和参数数组来生成命令，和能够只需要提供一行命令行字符串相比，你想使用通过一个字符串生成一个完整的命令，那么你可以使用 bash命令的 -c 选项：</span></span><br><span class="line">	lsCmd := exec.Command(<span class="string">"bash"</span>, <span class="string">"-c"</span>, <span class="string">"ls -a -l -h"</span>)</span><br><span class="line">	lsOut, err := lsCmd.Output()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"&gt; ls -a -l -h"</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(lsOut))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="替换执行进程"><a href="#替换执行进程" class="headerlink" title="替换执行进程"></a>替换执行进程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 有时候只想 用其他的（也许是非 Go 程序）来完全替代当前的 Go 进程</span></span><br><span class="line">	<span class="comment">// 在我们的例子中，我们将执行 ls 命令。Go 需要提供我 们需要执行的可执行文件的绝对路径，所以我们将使用 exec.LookPath 来得到它（大概是 /bin/ls）。</span></span><br><span class="line">	binary, lookErr := exec.LookPath(<span class="string">"ls"</span>)</span><br><span class="line">	<span class="keyword">if</span> lookErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(lookErr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Exec 需要的参数是切片的形式的（不是放在一起的一个大字 符串）。我们给 ls 一些基本的参数。注意，第一个参数需要 是程序名。</span></span><br><span class="line">	args := []<span class="keyword">string</span>&#123;<span class="string">"ls"</span>, <span class="string">"-a"</span>, <span class="string">"-l"</span>, <span class="string">"-h"</span>&#125;</span><br><span class="line">	<span class="comment">// Exec 同样需要使用环境变量。 这里我们仅提供当前的环境变量。</span></span><br><span class="line">	env := os.Environ()</span><br><span class="line">	<span class="comment">// 这里是 os.Exec 调用。如果这个调用成功，那么我们的 进程将在这里被替换成 /bin/ls -a -l -h 进程。如果存 在错误，那么我们将会得到一个返回值。</span></span><br><span class="line">	execErr := syscall.Exec(binary, args, env)</span><br><span class="line">	<span class="keyword">if</span> execErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(execErr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 运行程序时，它会替换为 ls</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Go 通过向一个通道发送 os.Signal 值来进行信号通知。我们 将创建一个通道来接收这些通知（同时还创建一个用于在程序可 以结束时进行通知的通道）。</span></span><br><span class="line">	sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// signal.Notify 注册这个给定的通道用于接收特定信号。</span></span><br><span class="line">	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	<span class="comment">// 这个 Go 协程执行一个阻塞的信号接收操作。当它得到一个 值时，它将打印这个值，然后通知程序可以退出。</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		sig := &lt;-sigs</span><br><span class="line">		fmt.Println()</span><br><span class="line">		fmt.Println(sig)</span><br><span class="line">		done &lt;- <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 程序将在这里进行等待，直到它得到了期望的信号（也就 是上面的 Go 协程发送的 done 值）然后退出。</span></span><br><span class="line">	fmt.Println(<span class="string">"awaiting signal"</span>)</span><br><span class="line">	&lt;-done</span><br><span class="line">	fmt.Println(<span class="string">"exiting"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们运行这个程序时，它将一直等待一个信号。使用 ctrl-C （终端显示为 ^C），我们可以发送一个 SIGINT 信号，这会 使程序打印 interrupt 然后退出。</span></span><br><span class="line"><span class="comment">// $ go run signals.go</span></span><br><span class="line"><span class="comment">// awaiting signal</span></span><br><span class="line"><span class="comment">// ^C</span></span><br><span class="line"><span class="comment">// interrupt</span></span><br><span class="line"><span class="comment">// exiting</span></span><br></pre></td></tr></table></figure>
<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当使用 os.Exit 时 defer 将不会 执行，所以这里的 fmt.Println 将永远不会被调用。</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"!"</span>)</span><br><span class="line">	<span class="comment">// 退出并且退出状态为 3。</span></span><br><span class="line">	os.Exit(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/go/">go</a></div><div class="post-nav"><a href="/2017/11/22/前端测试初探/" class="next">前端测试初探</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.2"><script src="/js/gitment.browser.js?v=0.0.2"></script><script>var gitment = new Gitment({
  owner: 'blossom91',
  repo: 'blossom91.github.io',
  oauth: {
    client_id: '7d6e0c7d1f3a71ae0658',
    client_secret: '12bf717efd08498927437024badb4baa732e6bf7',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂货铺/">杂货铺</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/ps/" style="font-size: 15px;">ps</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/go/" style="font-size: 15px;">go</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/19/go语言学习/">go语言学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/22/前端测试初探/">前端测试初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/12/mysql学习/">mysql学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/01/node-js学习/">node.js学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/24/go依赖管理工具govendor/">go依赖管理工具govendor</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/17/服务器响应状态码大全/">服务器响应状态码大全</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/05/正则表达式学习/">正则表达式学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/26/photoshop简单学习/">photoshop简单学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/18/css学习/">css学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/08/shell常用命令/">shell常用命令</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.bilibili.com/" title="bilibili" target="_blank">bilibili</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">blossom |</a> 豫ICP备17040049号</div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.2" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.2" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.2"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.2"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.2"></script></div></body></html>