---
title: 正则表达式学习
toc: true
mathjax: true
comments: true
date: 2017-10-05 14:15:18
updated:
tags:
categories:
---

对于这个东西,我并不想多说,不求掌握,只求别人写的能看懂,本文参考了[菜鸟教程](http://www.runoob.com/regexp/regexp-tutorial.html)与[慕课网](http://www.imooc.com/learn/706),感谢分享

<!-- more -->

### 基础

下面来简单了解一下相关解释

#### 元字符

元字符就是特殊字符，就是正则里面有特殊含义的字符如果要查找这些符号原义,需要进行转义,即加上反斜杠`\`

|     字符      | 描述                                                                               |
| :-----------: | :--------------------------------------------------------------------------------- |
|       g       | 全局匹配                                                                           |
|       i       | 忽略大小写,默认大小写敏感                                                          |
|       m       | 多行搜索                                                                           |
|   (assert)    | 分组功能,匹配 `assert` 并获取这一匹配。所获取的匹配可以从产生的 `Matches` 集合得到 |
|     [xyz]     | 字符集合,匹配所包含的任意一个字符`[abc]`可以匹配`plain`中的 `a`                    |
|    [^xyz]     | 负值字符集合,匹配未包含的任意字符                                                  |
|     [a-z]     | 字符范围。匹配指定范围内的任意字符 表示小写字母集合                                |
|    [^a-z]     | 负值字符范围,匹配任何不在指定范围内的任意字符 表示非小写字母集合                   |
|      \w       | 匹配字母,数字,下划线.等价于`[A-Za-z0-9_]`                                          |
|      \W       | 匹配非字母,数字,下划线.等价于`[^A-Za-z0-9_]`                                       |
|      \d       | 匹配一个数字字符,等价于 `[0-9]`                                                    |
|      \D       | 匹配一个非数字字符,等价于 `[^0-9]`                                                 |
|      \s       | 匹配任何空白字符,包括空格,制表符,换页符等.等价于`[ \f\n\r\t\v]`                    |
|      \S       | 匹配任何非空白字符,等价于`[^ \f\n\r\t\v]`                                          |
|       .       | 匹配除换行符 `\n` 之外的任何单字符                                                 |
|     x\|y      | 匹配 x 或 y `(z\|f)ood` 则匹配 `zood" 或 "food`                                    |
| exp(?:assert) | 断言匹配 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用        |
| exp(?=assert) | 非获取匹配,正向匹配`Windows(?=95\|98\|NT\|2000)`能匹配`Windows2000`中的`Windows`   |
| exp(?!assert) | 非获取匹配,反向匹配`Windows(?!95\|98\|NT\|2000)`能匹配`Windows3.1`中的`Windows`    |

#### 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配

| 字符  | 描述                                                                       |
| :---: | :------------------------------------------------------------------------- |
|  \*   | 匹配前面的子表达式零次或多次 `*` 等价于`{0,}`                              |
|   +   | 匹配前面的子表达式一次或多次 `+` 等价于`{1,}`                              |
|   ?   | 匹配前面的子表达式零次或一次 `?` 等价于`{0,1}`                             |
|  {n}  | `n` 是一个非负整数。匹配确定的 `n`次                                       |
| {n,}  | `n` 是一个非负整数。至少匹配`n` 次 `o{1,}` 等价于 `o+` `o{0,}` 等价于 `o*` |
| {n,m} | 均为非负整数,其中`n <= m`最少匹配 n 次且最多匹配 m 次 `o{0,1}'`等价于 `o?` |

---

**`*、+`限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个`?`就可以实现非贪婪或最小匹配**

```
<H1>Chapter 1 - 介绍正则表达式</H1>
```

```shell
# 贪婪: 匹配整句
/<.*>/
# 非贪婪: 只配置开始结束标签
/<.*?>/
```

#### 定位符

定位符使您能够将正则表达式固定到行首或行尾或固定到一个单词的开头或者结尾

| 字符 |             描述             |
| :--: | :--------------------------: |
|  ^   |   匹配输入字符串开始的位置   |
|  $   |   匹配输入字符串结尾的位置   |
|  \b  | 匹配一个字边界，即字开头结尾 |
|  \B  |         非字边界匹配         |

#### 反向引用

对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 `1` 开始，最多可存储 `99` 个捕获的子表达式。每个缓冲区都可以使用`\n` 访问，其中 `n` 为一个标识特定缓冲区的一位或两位十进制数

可以使用非捕获元字符 `?:、?= 或 ?!` 来重写捕获，忽略对相关匹配的保存

### JavaScript 中的正则

对于`JavaScript`来说,捕获访问符合是`$1,$2...`

一些常用方法

split: 把字符串按照规则分成数组 平时的使用,也是把输入的字符串转换成正则来生效的

```
'a1b4c-f.'.split(/[\d-\.]/)    //["a", "b", "c", "f", ""]
```

replace: 替换符合匹配规定的字符串 可通过`$n`获取子匹配 平时的使用,也是把输入的字符串转换成正则来生效的

```
'2015-12-25'.replace(/(\d{4})-(\d{2})-(\d{2})/,'$2-$3-$1')   // 12-25-2015

// match: 匹配的字符串  a1, a2, a3: 匹配的字表达式值,没有字表达式就没有这个参数 index: match位置 origin: 被检查的字符串
'a1b2c3d4e5'.replace(/(\d)(\w)(\d)/g, function(match, a1, a2, a3, index, origin) {
    return a1 + a3
})
// 虽然匹配到的是数字,但a1 a3 都是字符串 所以 返回  "a13c34e5"
```

test: 检查是否存在匹配 返回`bool` 当全局匹配的时候 `reg.lastIndex`会因为变动而存在一些问题,需要注意

```
/\d(\w)/.test('asdsad21321')   // true
```

exec: 检查匹配 无匹配返回`null` 有匹配返回一个数组 `index`匹配文本的第一个位置`input`被检查的字符串 全局匹配同样存在问题

```
/\d(\w)/.exec('asdsad21321')   //  ["21", "1", index: 6, input: "asdsad21321"]
```

search : 忽略全局符合`g` 返回符合查询的`index`

```
'aasf134'.search(s)               //2
```

match: 非全局模式下与`exec`返回的内容一样 全局模式下,返回所有匹配的字符串数组 没有`input,index` `match`无视`lastIndex`属性

```
'$1az2bb3cy4dd5ee'.match(/\d(\w)(\w)\d/g)      //['1az2','3cy4']
```

### 常用例子

#### 校验数字的表达式

* 数字：**^[0-9]\*$**
* n 位的数字：**^\d{n}$**
* 至少 n 位的数字：**^\d{n,}$**
* m-n 位的数字：**^\d{m,n}$**
* 零和非零开头的数字：**^(0|[1-9][0-9]\*)$**
* 非零开头的最多带两位小数的数字：**^([1-9][0-9]\*)+(.[0-9]{1,2})?$**
* 带 1-2 位小数的正数或负数：**^(\-)?\d+(\.\d{1,2})$**
* 正数、负数、和小数：**^(\-|\+)?\d+(\.\d+)?$**
* 有两位小数的正实数：**^[0-9]+(\.[0-9]{2})?$**
* 有 1~3 位小数的正实数：**^[0-9]+(\.[0-9]{1,3})?$**
* 非零的正整数：**^[1-9]\d\*$ 或 ^([1-9][0-9]\*){1,3}$ 或 ^\+?[1-9][0-9]\*$**
* 非零的负整数：**^\-[1-9][]0-9"\*$ 或 ^-[1-9]\d\*$**
* 非负整数：**^\d+$ 或 ^[1-9]\d\*|0$**
* 非正整数：**^-[1-9]\d\*|0$ 或 ^((-\d+)|(0+))$**
* 非负浮点数：**^\d+(\.\d+)?$ 或 ^[1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*|0?\.0+|0$**
* 非正浮点数：**^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*))|0?\.0+|0$**
* 正浮点数：**^[1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*$ 或 ^(([0-9]+\.[0-9]\*[1-9][0-9]\*)|([0-9]\*[1-9][0-9]\*\.[0-9]+)|([0-9]\*[1-9][0-9]\*))$**
* 负浮点数：**^-([1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*)$ 或 ^(-(([0-9]+\.[0-9]\*[1-9][0-9]\*)|([0-9]\*[1-9][0-9]\*\.[0-9]+)|([0-9]\*[1-9][0-9]\*)))$**
* 浮点数：**^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d\*\.\d\*|0\.\d\*[1-9]\d\*|0?\.0+|0)$**

#### 校验字符的表达式

* 汉字：**^[\u4e00-\u9fa5]{0,}$**
* 英文和数字：**^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$**
* 长度为 3-20 的所有字符：**^.{3,20}$**
* 由 26 个英文字母组成的字符串：**^[A-Za-z]+$**
* 由 26 个大写英文字母组成的字符串：**^[A-Z]+$**
* 由 26 个小写英文字母组成的字符串：**^[a-z]+$**
* 由数字和 26 个英文字母组成的字符串：**^[A-Za-z0-9]+$**
* 由数字、26 个英文字母或者下划线组成的字符串：**^\w+$ 或 ^\w{3,20}$**
* 中文、英文、数字包括下划线：**^[\u4E00-\u9FA5A-Za-z0-9_]+$**
* 中文、英文、数字但不包括下划线等符号：**^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$**
* 可以输入含有\^%&',;=?$\"等字符：**[^%&',;=?$\x22]+**
* 禁止输入含有\~的字符：**[^~\x22]+**

#### 特殊需求表达式

* Email 地址：**^\w+([-+.]\w+)\*@\w+([-.]\w+)\*\.\w+([-.]\w+)\*$**
* 域名：**[a-zA-Z0-9][-a-za-z0-9]{0,62}(/.[a-zA-Z0-9][-a-za-z0-9]{0,62})+/.?**
* InternetURL：**[a-zA-z]+://[^\s]\* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]\*)?$**
* 手机号码：**^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$**
* 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：**^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$**
* 国内电话号码(0511-4405222、021-87888822)：**\d{3}-\d{8}|\d{4}-\d{7}**
* 电话号码正则表达式（支持手机号码，3-4 位区号，7-8 位直播号码，1－4 位分机号）: **((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$)**
* 身份证号(15 位、18 位数字)，最后一位是校验位，可能为数字或字符 X：**(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)**
* 帐号是否合法(字母开头，允许 5-16 字节，允许字母数字下划线)：**^[a-zA-Z][a-za-z0-9_]{4,15}$**
* 密码(以字母开头，长度在 6~18 之间，只能包含字母、数字和下划线)：**^[a-zA-Z]\w{5,17}$**
* 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：**^(?=.\*\d)(?=.\*[a-z])(?=.\*[A-Z]).{8,10}$**
* 日期格式：**^\d{4}-\d{1,2}-\d{1,2}**
* 一年的 12 个月(01 ～ 09 和 1 ～ 12)：**^(0?[1-9]|1[0-2])$**
* 一个月的 31 天(01 ～ 09 和 1 ～ 31)：**^((0?[1-9])|((1|2)[0-9])|30|31)$**
* 钱的输入格式：
  1. 有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：**^[1-9][0-9]\*$**
  2. 这表示任意一个不以 0 开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：**^(0|[1-9][0-9]\*)$**
  3. 一个 0 或者一个不以 0 开头的数字.我们还可以允许开头有一个负号：**^(0|-?[1-9][0-9]\*)$**
  4. 这表示一个 0 或者一个可能为负的开头不为 0 的数字.让用户以 0 开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：**^[0-9]+(.[0-9]+)?$**
  5. 必须说明的是,小数点后面至少应该有 1 位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：**^[0-9]+(.[0-9]{2})?$**
  6. 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：**^[0-9]+(.[0-9]{1,2})?$**
  7. 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：**^[0-9]{1,3}(,[0-9]{3})\*(.[0-9]{1,2})?$**
  8. 1 到 3 个数字,后面跟着任意个 逗号+3 个数字,逗号成为可选,而不是必须：**^([0-9]+|[0-9]{1,3}(,[0-9]{3})\*)(.[0-9]{1,2})?$**
  9. 备注：这就是最终结果了,别忘了`+`可以用`*`替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里
* xml 文件：**^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|m][l|L]$**
* 中文字符的正则表达式：**[\u4e00-\u9fa5]**
* 双字节字符：**[^\x00-\xff]** (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计 2，ASCII 字符计 1))
* 空白行的正则表达式：**\n\s\*\r** (可以用来删除空白行)
* HTML 标记的正则表达式：**<(\S\*?)[^>]\*>.\*?|<.\*? />**( 首尾空白字符的正则表达式：**^\s\*|\s\*$**或**(^\s\*)|(\s\*$)** (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
* 腾讯 QQ 号：**[1-9][0-9]{4,}** (腾讯 QQ 号从 10000 开始)
* 中国邮政编码：**[1-9]\d{5}(?!\d)** (中国邮政编码为 6 位数字)
* IP 地址：**((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))**
