<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blossom</title>
  
  <subtitle>good good study and day day up</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zhaohang.site/"/>
  <updated>2018-01-06T01:54:59.000Z</updated>
  <id>http://www.zhaohang.site/</id>
  
  <author>
    <name>blossom</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go语言学习</title>
    <link href="http://www.zhaohang.site/2017/12/19/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.zhaohang.site/2017/12/19/go语言学习/</id>
    <published>2017-12-19T09:37:34.000Z</published>
    <updated>2018-01-06T01:54:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>go</code>的学习,感谢<a href="https://gobyexample.xgwang.me/" target="_blank" rel="noopener">Go By Example</a>、<a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md" target="_blank" rel="noopener">go 网络编程</a>与<a href="http://books.studygolang.com/The-Golang-Standard-Library-by-Example/" target="_blank" rel="noopener">go 语言标准库</a>,随着学习的深入,此文章持续更新…</p><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量  </span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span> = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">var</span> b, c <span class="keyword">int</span> =  <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="comment">// 只允许函数中这样声明</span></span><br><span class="line">f := <span class="string">"world"</span></span><br><span class="line"><span class="comment">// 常量(只允许布尔型、数字型（整数型、浮点型和复数）和字符串型)</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="string">"hello, world"</span></span><br><span class="line"><span class="comment">// 同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明</span></span><br><span class="line"><span class="comment">// 关键字iota，这个关键字用来声明enum的时候采用，它默认开始值是0，const中每增加一行加1</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span>  <span class="comment">//0</span></span><br><span class="line">    b = <span class="literal">iota</span>  <span class="comment">//1</span></span><br><span class="line">    c = <span class="literal">iota</span>  <span class="comment">//2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> v = <span class="literal">iota</span> <span class="comment">// 每遇到一个const关键字，iota就会重置，此时v == 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    h, i, j = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//h=0,i=0,j=0 iota在同一行值相同</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素</span></span><br><span class="line">doubleArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;[<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的声明可以简化，直接忽略内部的类型</span></span><br><span class="line">easyArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><code>go</code>语言中字符串是不可变的,想改变可以这样实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello"</span></span><br><span class="line">c := []<span class="keyword">byte</span>(s)  <span class="comment">// 将字符串 s 转换为 []byte 类型</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="string">'c'</span></span><br><span class="line">s2 := <span class="keyword">string</span>(c)  <span class="comment">// 再转换回 string 类型</span></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, s2)</span><br></pre></td></tr></table></figure><p>这样修改,字符串虽不能更改，但可进行切片操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello"</span></span><br><span class="line">s = <span class="string">"c"</span> + s[<span class="number">1</span>:]</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, s)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>strings.Contains(&quot;test&quot;, &quot;es&quot;)</code></td><td style="text-align:left">是否包含:<code>true</code></td></tr><tr><td style="text-align:left"><code>strings.Count(&quot;test&quot;, &quot;t&quot;)</code></td><td style="text-align:left">包含数量:<code>2</code></td></tr><tr><td style="text-align:left"><code>strings.HasPrefix(&quot;test&quot;, &quot;te&quot;)</code></td><td style="text-align:left">前缀:<code>true</code></td></tr><tr><td style="text-align:left"><code>strings.HasSuffix(&quot;test&quot;, &quot;st&quot;)</code></td><td style="text-align:left">后缀:<code>true</code></td></tr><tr><td style="text-align:left"><code>strings.Index(&quot;test&quot;, &quot;e&quot;)</code></td><td style="text-align:left">index:<code>1</code></td></tr><tr><td style="text-align:left"><code>strings.Join([]string{&quot;a&quot;, &quot;b&quot;, &quot;b&quot;}, &quot;-&quot;)</code></td><td style="text-align:left">join:<code>a-b-b</code></td></tr><tr><td style="text-align:left"><code>strings.Repeat(&quot;a&quot;, 5)</code></td><td style="text-align:left">复制:<code>aaaaa</code></td></tr><tr><td style="text-align:left"><code>strings.Replace(&quot;foo&quot;, &quot;o&quot;, &quot;0&quot;, -1)</code></td><td style="text-align:left">替换:<code>f00</code></td></tr><tr><td style="text-align:left"><code>strings.Replace(&quot;foo&quot;, &quot;o&quot;, &quot;0&quot;, 1)</code></td><td style="text-align:left">替换 1 次:<code>f0o</code></td></tr><tr><td style="text-align:left"><code>strings.Split(&quot;a-b-c-d-e&quot;, &quot;-&quot;)</code></td><td style="text-align:left">split:<code>[a b c d e]</code></td></tr><tr><td style="text-align:left"><code>strings.ToLower(&quot;TEST&quot;)</code></td><td style="text-align:left">转小写:<code>test</code></td></tr><tr><td style="text-align:left"><code>strings.ToUpper(&quot;test&quot;)</code></td><td style="text-align:left">转大写:<code>TEST</code></td></tr><tr><td style="text-align:left"><code>len(&quot;hello&quot;)</code></td><td style="text-align:left">长度:<code>5</code></td></tr><tr><td style="text-align:left"><code>&quot;hello&quot;[1]</code></td><td style="text-align:left">索引取值:<code>101</code></td></tr></tbody></table><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// fmt.Printf  通过 os.Stdout打印格式化的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Sprintf 格式化并返回一个字符串而不带任何输出</span></span><br><span class="line">s := fmt.Sprintf(<span class="string">"a %s"</span>, <span class="string">"string"</span>)</span><br><span class="line">fmt.Println(s)   <span class="comment">// a string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Fprintf 格式化并输出到 io.Writers而不是 os.Stdout</span></span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"an %s\n"</span>, <span class="string">"error"</span>)  <span class="comment">// an error</span></span><br><span class="line"></span><br><span class="line">p := point&#123;x:<span class="number">1</span>, y:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>fmt.Printf(&quot;%v\n&quot;, p)</code></td><td style="text-align:left">打印结构体<code>{1 2}</code></td></tr><tr><td style="text-align:left"><code>fmt.Printf(&quot;%+v\n&quot;, p)</code></td><td style="text-align:left">打印结构体的字段名<code>{x:1 y:2}</code></td></tr><tr><td style="text-align:left"><code>fmt.Printf(&quot;%#v\n&quot;, p)</code></td><td style="text-align:left">打印 Go 语法表示<code>main.point{x:1, y:2}</code></td></tr><tr><td style="text-align:left"><code>fmt.Printf(&quot;%T\n&quot;, p)</code></td><td style="text-align:left">打印值的类型<code>main.point</code></td></tr><tr><td style="text-align:left"><code>fmt.Printf(&quot;%t\n&quot;, true)</code></td><td style="text-align:left">格式化布尔值<code>true</code></td></tr><tr><td style="text-align:left"><code>fmt.Printf(&quot;%d\n&quot;, 123)</code></td><td style="text-align:left">整数标准的十进制格式化<code>123</code></td></tr><tr><td style="text-align:left"><code>fmt.Printf(&quot;%b\n&quot;, 14)</code></td><td style="text-align:left">整数二进制<code>1110</code></td></tr><tr><td style="text-align:left"><code>fmt.Printf(&quot;%c\n&quot;, 33)</code></td><td style="text-align:left">整数输出给定整数的对应字符<code>!</code></td></tr><tr><td style="text-align:left"><code>fmt.Printf(&quot;%x\n&quot;, 456)</code></td><td style="text-align:left">整数十六进制<code>1c8</code></td></tr><tr><td style="text-align:left"><code>fmt.Printf(&quot;%f\n&quot;, 78.9)</code></td><td style="text-align:left">浮点数十进制格式化<code>78.900000</code></td></tr><tr><td style="text-align:left"><code>fmt.Printf(&quot;%e\n&quot;, 123400000.0)</code></td><td style="text-align:left">浮点型格式化科学技科学记数法<code>1.234000e+08</code></td></tr><tr><td style="text-align:left"><code>fmt.Printf(&quot;%E\n&quot;, 123400000.0)</code></td><td style="text-align:left">浮点型格式化科学技科学记数法<code>1.234000E+08</code></td></tr><tr><td style="text-align:left"><code>fmt.Printf(&quot;%s\n&quot;, &quot;\&quot;string\&quot;&quot;)</code></td><td style="text-align:left">基本的字符串输出<code>&quot;string&quot;</code></td></tr><tr><td style="text-align:left"><code>fmt.Printf(&quot;%q\n&quot;, &quot;\&quot;string\&quot;&quot;)</code></td><td style="text-align:left">Go 源代码中那样带有双引号的输出<code>&quot;\&quot;string\&quot;&quot;</code></td></tr><tr><td style="text-align:left"><code>fmt.Printf(&quot;%x\n&quot;, &quot;hex this&quot;)</code></td><td style="text-align:left">base-16 编码的字符串<code>6865782074686973</code></td></tr><tr><td style="text-align:left"><code>fmt.Printf(&quot;%p\n&quot;, &amp;p)</code></td><td style="text-align:left">输出一个指针的值<code>0x42135100</code></td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当输出数字的时候，你将经常想要控制输出结果的宽度和精度，可以使用在 % 后面使用数字来控制输出宽度。默认结果使用右对齐并且通过空格来填充空白部分。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%6d|%6d|\n"</span>, <span class="number">12</span>, <span class="number">345</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也可以指定浮点型的输出宽度，同时也可以通过 宽度.精度 的语法来指定输出的精度。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%6.2f|%6.2f|\n"</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要左对齐，使用 - 标志。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%-6.2f|%-6.2f|\n"</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也许也想控制字符串输出时的宽度，特别是要确保他们在类表格输出时的对齐。这是基本的右对齐宽度表示。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%6s|%6s|\n"</span>, <span class="string">"foo"</span>, <span class="string">"b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要左对齐，和数字一样，使用 - 标志。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%-6s|%-6s|\n"</span>, <span class="string">"foo"</span>, <span class="string">"b"</span>)</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 经典的初始化/条件/后续形式 for 循环。 同样也支持跳过循环</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">7</span>; j &lt;= <span class="number">9</span>; j++ &#123;</span><br><span class="line">    fmt.Println(j)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不带条件的 for 循环将一直执行，直到在循环体内使用了 break 或者 return 来跳出循环。</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"loop"</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if-else"><a href="#if-else" class="headerlink" title="if/else"></a>if/else</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">7</span>%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"7 is even"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"7 is odd"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在条件语句之前可以有一个语句；任何在这里声明的变量都可以在所有的条件分支中使用。</span></span><br><span class="line"><span class="keyword">if</span> num := <span class="number">9</span>; num &lt; <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(num, <span class="string">"is negative"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> num &lt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(num, <span class="string">"has 1 digit"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(num, <span class="string">"has multiple digits"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个 case 语句中，你可以使用逗号来分隔多个表达式。在这个例子中，我们很好的使用了可选的default 分支。</span></span><br><span class="line"><span class="keyword">switch</span> time.Now().Weekday() &#123;</span><br><span class="line"><span class="keyword">case</span> time.Saturday, time.Sunday:</span><br><span class="line">    fmt.Println(<span class="string">"it's the weekend"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"it's a weekday"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不带表达式的 switch 是实现 if/else 逻辑的另一种方式。这里展示了 case 表达式是如何使用非常量的。</span></span><br><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">    fmt.Println(<span class="string">"it's before noon"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"it's after noon"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里我们创建了一个数组 a 来存放刚好 5 个 int。元素的类型和长度都是数组类型的一部分。数组默认是零值的，对于 int 数组来说也就是 0。</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(<span class="string">"emp:"</span>, a)</span><br><span class="line"><span class="comment">// 我们可以使用 array[index] = value 语法来设置数组指定位置的值，或者用 array[index] 得到值。</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(<span class="string">"set:"</span>, a)</span><br><span class="line">fmt.Println(<span class="string">"get:"</span>, a[<span class="number">4</span>])</span><br><span class="line"><span class="comment">// 使用内置函数 len 返回数组的长度</span></span><br><span class="line">fmt.Println(<span class="string">"len:"</span>, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="comment">// 使用这个语法在一行内初始化一个数组</span></span><br><span class="line">b := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"dcl:"</span>, b)</span><br><span class="line"><span class="comment">// 数组的存储类型是单一的，但是你可以组合这些数据来构造多维的数据结构。</span></span><br><span class="line"><span class="keyword">var</span> twoD [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">        twoD[i][j] = i + j</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"2d: "</span>, twoD)</span><br></pre></td></tr></table></figure><h3 id="切片slice"><a href="#切片slice" class="headerlink" title="切片slice"></a>切片<code>slice</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不像数组，slice 的类型仅由它所包含的元素决定（不像数组中还需要元素的个数）。要创建一个长度非零的空slice，需要使用内建的方法 make。这里我们创建了一个长度为3的 string 类型 slice（初始化为零值）。</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">"emp:"</span>, s)</span><br><span class="line"><span class="comment">// 我们可以和数组一样设置和得到值</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">"a"</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">"b"</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="string">"c"</span></span><br><span class="line">fmt.Println(<span class="string">"set:"</span>, s)</span><br><span class="line">fmt.Println(<span class="string">"get:"</span>, s[<span class="number">2</span>])</span><br><span class="line"><span class="comment">// 如你所料，len 返回 slice 的长度</span></span><br><span class="line">fmt.Println(<span class="string">"len:"</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="comment">// 作为基本操作的补充，slice 支持比数组更多的操作。其中一个是内建的 append，它返回一个包含了一个或者多个新值的 slice。注意我们接受返回由 append返回的新的 slice 值。</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"d"</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"e"</span>, <span class="string">"f"</span>)</span><br><span class="line">fmt.Println(<span class="string">"apd:"</span>, s)</span><br><span class="line"><span class="comment">// Slice 也可以被 copy。这里我们创建一个空的和 s 有相同长度的 slice c，并且将 s 复制给 c。</span></span><br><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="built_in">copy</span>(c, s)</span><br><span class="line">fmt.Println(<span class="string">"cpy:"</span>, c)</span><br><span class="line"><span class="comment">// Slice 支持通过 slice[low:high] 语法进行“切片”操作。例如，这里得到一个包含元素 s[2], s[3],s[4] 的 slice。</span></span><br><span class="line">l := s[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Println(<span class="string">"sl1:"</span>, l)</span><br><span class="line"><span class="comment">// 这个 slice 从 s[0] 到（但是包含）s[5]。</span></span><br><span class="line">l = s[:<span class="number">5</span>]</span><br><span class="line">fmt.Println(<span class="string">"sl2:"</span>, l)</span><br><span class="line"><span class="comment">// 这个 slice 从（包含）s[2] 到 slice 的后一个值。</span></span><br><span class="line">l = s[<span class="number">2</span>:]</span><br><span class="line">fmt.Println(<span class="string">"sl3:"</span>, l)</span><br><span class="line"><span class="comment">// 我们可以在一行代码中声明并初始化一个 slice 变量。</span></span><br><span class="line">t := []<span class="keyword">string</span>&#123;<span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"dcl:"</span>, t)</span><br><span class="line"><span class="comment">// Slice 可以组成多维数据结构。内部的 slice 长度可以不同，这和多位数组不同。</span></span><br><span class="line">twoD := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    innerLen := i + <span class="number">1</span></span><br><span class="line">    twoD[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, innerLen)</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; innerLen; j++ &#123;</span><br><span class="line">        twoD[i][j] = i + j</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"2d: "</span>, twoD)</span><br></pre></td></tr></table></figure><h3 id="关系数组map"><a href="#关系数组map" class="headerlink" title="关系数组map"></a>关系数组<code>map</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要创建一个空 map，需要使用内建的 make:make(map[key-type]val-type).</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 使用典型的 make[key] = val 语法来设置键值对。</span></span><br><span class="line">m[<span class="string">"k1"</span>] = <span class="number">7</span></span><br><span class="line">m[<span class="string">"k2"</span>] = <span class="number">13</span></span><br><span class="line"><span class="comment">// 使用例如 Println 来打印一个 map 将会输出所有的键值对。</span></span><br><span class="line">fmt.Println(<span class="string">"map:"</span>, m)</span><br><span class="line"><span class="comment">// 使用 name[key] 来获取一个键的值</span></span><br><span class="line">v1 := m[<span class="string">"k1"</span>]</span><br><span class="line">fmt.Println(<span class="string">"v1: "</span>, v1)</span><br><span class="line"><span class="comment">// 当对一个 map 调用内建的 len 时，返回的是键值对数目</span></span><br><span class="line">fmt.Println(<span class="string">"len:"</span>, <span class="built_in">len</span>(m))</span><br><span class="line"><span class="comment">// 内建的 delete 可以从一个 map 中移除键值对</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"k2"</span>)</span><br><span class="line">fmt.Println(<span class="string">"map:"</span>, m)</span><br><span class="line"><span class="comment">// 当从一个 map 中取值时，可选的第二返回值指示这个键是在这个 map 中。这可以用来消除键不存在和键有零值，像 0 或者 "" 而产生的歧义。</span></span><br><span class="line">num, prs := m[<span class="string">"k1"</span>]</span><br><span class="line">fmt.Println(<span class="string">"prs:"</span>, prs, num)</span><br><span class="line"><span class="comment">// 你也可以通过这个语法在同一行申明和初始化一个新的map。</span></span><br><span class="line">n := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"foo"</span>: <span class="number">1</span>, <span class="string">"bar"</span>: <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"map:"</span>, n)</span><br></pre></td></tr></table></figure><h3 id="遍历Rang"><a href="#遍历Rang" class="headerlink" title="遍历Rang"></a>遍历<code>Rang</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里我们使用 range 来统计一个 slice 的元素个数。数组也可以采用这种方法。</span></span><br><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">    sum += num</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"sum:"</span>, sum)</span><br><span class="line"><span class="comment">// range 在数组和 slice 中都同样提供每个项的索引和值。上面我们不需要索引，所以我们使用 空值定义符_ 来忽略它。有时候我们实际上是需要这个索引的。</span></span><br><span class="line"><span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"index:"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// range 在 map 中迭代键值对。</span></span><br><span class="line">kvs := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"a"</span>: <span class="string">"apple"</span>, <span class="string">"b"</span>: <span class="string">"banana"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s -&gt; %s\n"</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// range 在字符串中迭代 unicode 编码。第一个返回值是rune 的起始字节位置，然后第二个是 rune 自己。</span></span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> <span class="string">"go"</span> &#123;</span><br><span class="line">    fmt.Println(i, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 首先我们来看一下基本数据类型到 JSON 字符串的编码过程。这里是一些原子值的例子。</span></span><br><span class="line">    bolB, _ := json.Marshal(<span class="literal">true</span>)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(bolB))</span><br><span class="line">    intB, _ := json.Marshal(<span class="number">1</span>)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(intB))</span><br><span class="line">    fltB, _ := json.Marshal(<span class="number">2.34</span>)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(fltB))</span><br><span class="line">    strB, _ := json.Marshal(<span class="string">"gopher"</span>)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(strB))</span><br><span class="line">    <span class="comment">// 这里是一些切片和 map 编码成 JSON 数组和对象的例子。</span></span><br><span class="line">    slcD := []<span class="keyword">string</span>&#123;<span class="string">"apple"</span>, <span class="string">"peach"</span>, <span class="string">"pear"</span>&#125;</span><br><span class="line">    slcB, _ := json.Marshal(slcD)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(slcB))</span><br><span class="line">    mapD := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"apple"</span>: <span class="number">5</span>, <span class="string">"lettuce"</span>: <span class="number">7</span>&#125;</span><br><span class="line">    mapB, _ := json.Marshal(mapD)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(mapB))</span><br><span class="line">    <span class="comment">// JSON 包可以自动的编码你的自定义类型。编码仅输出可导出的字段，并且默认使用他们的名字作为 JSON 数据的键。</span></span><br><span class="line">    res1D := &amp;Response1&#123;</span><br><span class="line">        Page:   <span class="number">1</span>,</span><br><span class="line">        Fruits: []<span class="keyword">string</span>&#123;<span class="string">"apple"</span>, <span class="string">"peach"</span>, <span class="string">"pear"</span>&#125;&#125;</span><br><span class="line">    res1B, _ := json.Marshal(res1D)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(res1B))</span><br><span class="line">    <span class="comment">// 你可以给结构字段声明标签来自定义编码的 JSON 数据键名称。在上面 Response2 的定义可以作为这个标签这个的一个例子。</span></span><br><span class="line">    res2D := Response2&#123;</span><br><span class="line">        Page:   <span class="number">1</span>,</span><br><span class="line">        Fruits: []<span class="keyword">string</span>&#123;<span class="string">"apple"</span>, <span class="string">"peach"</span>, <span class="string">"pear"</span>&#125;&#125;</span><br><span class="line">    res2B, _ := json.Marshal(res2D)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(res2B))</span><br><span class="line">    <span class="comment">// 现在来看看解码 JSON 数据为 Go 值的过程。这里是一个普通数据结构的解码例子。</span></span><br><span class="line">    byt := []<span class="keyword">byte</span>(<span class="string">`&#123;"num":6.13,"strs":["a","b"]&#125;`</span>)</span><br><span class="line">    <span class="comment">// 我们需要提供一个 JSON 包可以存放解码数据的变量。这里的 map[string]interface&#123;&#125; 将保存一个 string 为键，值为任意值的map。</span></span><br><span class="line">    <span class="keyword">var</span> dat <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 这里就是实际的解码和相关的错误检查。</span></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(byt, &amp;dat); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(dat)</span><br><span class="line">    <span class="comment">// 为了使用解码 map 中的值，我们需要将他们进行适当的类型转换。例如这里我们将 num 的值转换成 float64类型。</span></span><br><span class="line">    num := dat[<span class="string">"num"</span>].(<span class="keyword">float64</span>)</span><br><span class="line">    fmt.Println(num)</span><br><span class="line">    <span class="comment">// 访问嵌套的值需要一系列的转化。</span></span><br><span class="line">    strs := dat[<span class="string">"strs"</span>].([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    str1 := strs[<span class="number">0</span>].(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(str1)</span><br><span class="line">    <span class="comment">// 我们也可以解码 JSON 值到自定义类型。这个功能的好处就是可以为我们的程序带来额外的类型安全加强，并且消除在访问数据时的类型断言。</span></span><br><span class="line">    str := <span class="string">`&#123;"page": 1, "fruits": ["apple", "peach"]&#125;`</span></span><br><span class="line">    res := &amp;Response2&#123;&#125;</span><br><span class="line">    json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;res)</span><br><span class="line">    fmt.Println(res)</span><br><span class="line">    fmt.Println(res.Fruits[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">// 在上面的例子中，我们经常使用 byte 和 string 作为使用标准输出时数据和 JSON 表示之间的中间值。我们也可以和os.Stdout 一样，直接将 JSON 编码直接输出至 os.Writer流中，或者作为 HTTP 响应体。</span></span><br><span class="line">    enc := json.NewEncoder(os.Stdout)</span><br><span class="line">    d := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"apple"</span>: <span class="number">5</span>, <span class="string">"lettuce"</span>: <span class="number">7</span>&#125;</span><br><span class="line">    enc.Encode(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是一个函数，接受两个 int 并且以 int 返回它们的和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// Go 需要明确的返回值，例如，它不会自动返回最后一个表达式的值</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 正如你期望的那样，通过 name(args) 来调用一个函数，</span></span><br><span class="line">    res := plus(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    fmt.Println(<span class="string">"1+2 ="</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (int, int) 在这个函数中标志着这个函数返回 2 个 int。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">vals</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>, <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里我们通过多赋值 操作来使用这两个不同的返回值。</span></span><br><span class="line">    a, b := vals()</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    fmt.Println(b)</span><br><span class="line">    <span class="comment">// 如果你仅仅想返回值的一部分的话，你可以使用空白定义符 _。</span></span><br><span class="line">    _, c := vals()</span><br><span class="line">    fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变参函数"><a href="#变参函数" class="headerlink" title="变参函数"></a>变参函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数使用任意数目的 int 作为参数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Print(nums, <span class="string">" "</span>)</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        total += num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(total)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 变参函数使用常规的调用方式，除了参数比较特殊。</span></span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 如果你的 slice 已经有了多个值，想把它们作为变参使用，你要这样调用 func(slice...)。</span></span><br><span class="line">    nums := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sum(nums...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个 intSeq 函数返回另一个在 intSeq 函数体内定义的匿名函数。这个返回的函数使用闭包的方式 隐藏 变量 i。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSeq</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 我们调用 intSeq 函数，将返回值（也是一个函数）赋给nextInt。这个函数的值包含了自己的值 i，这样在每次调用 nextInt 时都会更新 i 的值。</span></span><br><span class="line">    nextInt := intSeq()</span><br><span class="line">    <span class="comment">// 通过多次调用 nextInt 来看看闭包的效果。</span></span><br><span class="line">    fmt.Println(nextInt())</span><br><span class="line">    fmt.Println(nextInt())</span><br><span class="line">    fmt.Println(nextInt())</span><br><span class="line">    <span class="comment">// 为了确认这个状态对于这个特定的函数是唯一的，我们重新创建并测试一下。</span></span><br><span class="line">    newInts := intSeq()</span><br><span class="line">    fmt.Println(newInts())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// face 函数在到达 face(0) 前一直调用自身。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fact</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * fact(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(fact(<span class="number">7</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们将通过两个函数：zeroval 和 zeroptr 来比较指针和值类型的不同。zeroval 有一个 int 型参数，所以使用值传递。zeroval 将从调用它的那个函数中得到一个 ival形参的拷贝。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zeroval</span><span class="params">(ival <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ival = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zeroptr 有一和上面不同的 *int 参数，意味着它用了一个 int指针。函数体内的 *iptr 接着解引用 这个指针，从它内存地址得到这个地址对应的当前值。对一个解引用的指针赋值将会改变这个指针引用的真实地址的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zeroptr</span><span class="params">(iptr *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *iptr = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    fmt.Println(<span class="string">"initial:"</span>, i)</span><br><span class="line">    zeroval(i)</span><br><span class="line">    fmt.Println(<span class="string">"zeroval:"</span>, i)</span><br><span class="line">    <span class="comment">// 通过 &amp;i 语法来取得 i 的内存地址，例如一个变量i 的指针。</span></span><br><span class="line">    zeroptr(&amp;i)</span><br><span class="line">    fmt.Println(<span class="string">"zeroptr:"</span>, i)</span><br><span class="line">    <span class="comment">// 指针也是可以被打印的。</span></span><br><span class="line">    fmt.Println(<span class="string">"pointer:"</span>, &amp;i)</span><br><span class="line">        <span class="comment">// 又可以获取到值了</span></span><br><span class="line">    fmt.Println(<span class="string">"pointer:"</span>, *&amp;i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zeroval 在 main 函数中不能改变 i 的值，但是zeroptr 可以，因为它有一个这个变量的内存地址的引用。</span></span><br><span class="line"><span class="comment">// 对于空指针   var  ptr *int    ptr == nil</span></span><br></pre></td></tr></table></figure><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用这个语法创建了一个新的结构体元素。</span></span><br><span class="line">    fmt.Println(person&#123;<span class="string">"Bob"</span>, <span class="number">20</span>&#125;)</span><br><span class="line">    <span class="comment">// 你可以在初始化一个结构体元素时指定字段名字。</span></span><br><span class="line">    fmt.Println(person&#123;name: <span class="string">"Alice"</span>, age: <span class="number">30</span>&#125;)</span><br><span class="line">    <span class="comment">// 省略的字段将被初始化为零值。</span></span><br><span class="line">    fmt.Println(person&#123;name: <span class="string">"Fred"</span>&#125;)</span><br><span class="line">    <span class="comment">// &amp; 前缀生成一个结构体指针。</span></span><br><span class="line">    fmt.Println(&amp;person&#123;name: <span class="string">"Ann"</span>, age: <span class="number">40</span>&#125;)</span><br><span class="line">    <span class="comment">// 使用点来访问结构体字段。</span></span><br><span class="line">    s := person&#123;name: <span class="string">"Sean"</span>, age: <span class="number">50</span>&#125;</span><br><span class="line">    fmt.Println(s.name)</span><br><span class="line">    <span class="comment">// 也可以对结构体指针使用. - 指针会被自动解引用。</span></span><br><span class="line">    sp := &amp;s</span><br><span class="line">    fmt.Println(sp.age)</span><br><span class="line">    <span class="comment">// 结构体是可变的。</span></span><br><span class="line">    sp.age = <span class="number">51</span></span><br><span class="line">    fmt.Println(sp.age)</span><br><span class="line">    fmt.Println(s.age) <span class="comment">// 51</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 area 方法有一个接收器类型 rect。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rect)</span> <span class="title">area</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以为值类型或者指针类型的接收器定义方法。这里是一个值类型接收器的例子。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*r.width + <span class="number">2</span>*r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := rect&#123;width: <span class="number">10</span>, height: <span class="number">5</span>&#125;</span><br><span class="line">    <span class="comment">// 这里我们调用上面为结构体定义的两个方法。</span></span><br><span class="line">    fmt.Println(<span class="string">"area: "</span>, r.area())</span><br><span class="line">    fmt.Println(<span class="string">"perim:"</span>, r.perim())</span><br><span class="line">    <span class="comment">// Go 自动处理方法调用时的值和指针之间的转化。你可以使用指针来调用方法来避免在方法调用时产生一个拷贝，或者让方法能够改变接受的数据。</span></span><br><span class="line">    rp := &amp;r</span><br><span class="line">    fmt.Println(<span class="string">"area: "</span>, rp.area())</span><br><span class="line">    fmt.Println(<span class="string">"perim:"</span>, rp.perim())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口 是方法特征的命名集合。</span></span><br><span class="line"><span class="comment">// 这里是一个几何体的基本接口。</span></span><br><span class="line"><span class="keyword">type</span> geometry <span class="keyword">interface</span> &#123;</span><br><span class="line">    area() <span class="keyword">float64</span></span><br><span class="line">    perim() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在我们的例子中，我们将让 rect 和 circle 实现这个接口</span></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要在 Go 中实现一个接口，我们只需要实现接口中的所有方法。这里我们让 rect 实现了 geometry 接口。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*r.width + <span class="number">2</span>*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// circle 的实现。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一个变量是接口类型，那么我们可以调用这个被命名的接口中的方法。这里有一个一通用的 measure 函数，利用这个特性，它可以用在任何 geometry 上。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measure</span><span class="params">(g geometry)</span></span> &#123;</span><br><span class="line">    fmt.Println(g)</span><br><span class="line">    fmt.Println(g.area())</span><br><span class="line">    fmt.Println(g.perim())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := rect&#123;width: <span class="number">3</span>, height: <span class="number">4</span>&#125;</span><br><span class="line">    c := circle&#123;radius: <span class="number">5</span>&#125;</span><br><span class="line">    <span class="comment">// 结构体类型 circle 和 rect 都实现了 geometry接口，所以我们可以使用它们的实例作为 measure 的参数。</span></span><br><span class="line">    measure(r)</span><br><span class="line">    measure(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取-interface-变量存储的类型"><a href="#获取-interface-变量存储的类型" class="headerlink" title="获取 interface 变量存储的类型"></a>获取 interface 变量存储的类型</h3><p><code>interface</code>的变量里面可以存储任意类型的数值(该类型实现了<code>interface</code>)<br>那么获取这个变量里面实际保存的对象类型可以使用下列方法</p><ul><li>Comma-ok 断言<br>Go 语言里面有一个语法，可以直接判断是否是该类型的变量： value, ok = element.(T)，这里 value 就是变量的值，ok 是一个 bool 类型，element 是 interface 变量，T 是断言的类型。如果 element 里面确实存储了 T 类型的数值，那么 ok 返回 true，否则返回 false。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> List []Element</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了String方法，实现了fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"(name: "</span> + p.name + <span class="string">" - age: "</span> + strconv.Itoa(p.age) + <span class="string">" years)"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">    list[<span class="number">0</span>] = <span class="number">1</span>       <span class="comment">// an int</span></span><br><span class="line">    list[<span class="number">1</span>] = <span class="string">"Hello"</span> <span class="comment">// a string</span></span><br><span class="line">    list[<span class="number">2</span>] = Person&#123;<span class="string">"Dennis"</span>, <span class="number">70</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, element := <span class="keyword">range</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> value, ok := element.(<span class="keyword">int</span>); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"list[%d] is an int and its value is %d\n"</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"list[%d] is a string and its value is %s\n"</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(Person); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"list[%d] is a Person and its value is %s\n"</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"list[%d] is of a different type\n"</span>, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>switch 测试</li></ul><p>因为用到了很多的 if 所以自然有<code>switch</code><br>这里有一点需要强调的是：<code>element.(type)</code>语法不能在 switch 外的任何逻辑里面使用，如果你要在 switch 外面判断一个类型就使用<code>comma-ok</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">    list[<span class="number">0</span>] = <span class="number">1</span>       <span class="comment">//an int</span></span><br><span class="line">    list[<span class="number">1</span>] = <span class="string">"Hello"</span> <span class="comment">//a string</span></span><br><span class="line">    list[<span class="number">2</span>] = Person&#123;<span class="string">"Dennis"</span>, <span class="number">70</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, element := <span class="keyword">range</span> list &#123;</span><br><span class="line">        <span class="keyword">switch</span> value := element.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"list[%d] is an int and its value is %d\n"</span>, index, value)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"list[%d] is a string and its value is %s\n"</span>, index, value)</span><br><span class="line">        <span class="keyword">case</span> Person:</span><br><span class="line">            fmt.Printf(<span class="string">"list[%d] is a Person and its value is %s\n"</span>, index, value)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"list[%d] is of a different type"</span>, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射-不太懂"><a href="#反射-不太懂" class="headerlink" title="反射(不太懂)"></a>反射(不太懂)</h3><p>暂时觉得这个可以判断结构类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStruct)</span> <span class="title">GetName</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    this.name = str</span><br><span class="line">    <span class="keyword">return</span> this.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 备注: reflect.Indirect -&gt; 如果是指针则返回 Elem()</span></span><br><span class="line">    <span class="comment">// 首先，reflect包有两个数据类型我们必须知道，一个是Type，一个是Value。</span></span><br><span class="line">    <span class="comment">// Type就是定义的类型的一个数据类型，Value是值的类型</span></span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    s := <span class="string">"this is string"</span></span><br><span class="line">    <span class="comment">// 获取对象类型 (string)</span></span><br><span class="line">    fmt.Println(reflect.TypeOf(s))</span><br><span class="line">    <span class="comment">// 获取对象值 (this is string)</span></span><br><span class="line">    fmt.Println(reflect.ValueOf(s))</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">    <span class="comment">// 获取对象值 (&lt;float64 Value&gt;)</span></span><br><span class="line">    fmt.Println(reflect.ValueOf(x))</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    a := &amp;MyStruct&#123;name: <span class="string">"nljb"</span>&#125;</span><br><span class="line">    <span class="comment">// 返回对象的方法的数量 (1)</span></span><br><span class="line">    fmt.Println(reflect.TypeOf(a).NumMethod())</span><br><span class="line">    <span class="comment">// 遍历对象中的方法</span></span><br><span class="line">    <span class="keyword">for</span> m := <span class="number">0</span>; m &lt; reflect.TypeOf(a).NumMethod(); m++ &#123;</span><br><span class="line">        method := reflect.TypeOf(a).Method(m)</span><br><span class="line">        fmt.Println(method.Type)         <span class="comment">// func(*main.MyStruct) string</span></span><br><span class="line">        fmt.Println(method.Name)         <span class="comment">// GetName</span></span><br><span class="line">        fmt.Println(method.Type.NumIn()) <span class="comment">// 参数个数</span></span><br><span class="line">        fmt.Println(method.Type.In(<span class="number">1</span>))   <span class="comment">// 参数类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取对象值 (&lt;*main.MyStruct Value&gt;)</span></span><br><span class="line">    fmt.Println(reflect.ValueOf(a))</span><br><span class="line">    <span class="comment">// 获取对象名称</span></span><br><span class="line">    fmt.Println(reflect.Indirect(reflect.ValueOf(a)).Type().Name())</span><br><span class="line">    <span class="comment">// 参数</span></span><br><span class="line">    i := <span class="string">"Hello"</span></span><br><span class="line">    v := <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>)</span><br><span class="line">    v = <span class="built_in">append</span>(v, reflect.ValueOf(i))</span><br><span class="line">    <span class="comment">// 通过对象值中的方法名称调用方法 ([nljb]) (返回数组因为Go支持多值返回)</span></span><br><span class="line">    fmt.Println(reflect.ValueOf(a).MethodByName(<span class="string">"GetName"</span>).Call(v))</span><br><span class="line">    <span class="comment">// 通过对值中的子对象名称获取值 (nljb)</span></span><br><span class="line">    fmt.Println(reflect.Indirect(reflect.ValueOf(a)).FieldByName(<span class="string">"name"</span>))</span><br><span class="line">    <span class="comment">// 是否可以改变这个值 (false)</span></span><br><span class="line">    fmt.Println(reflect.Indirect(reflect.ValueOf(a)).FieldByName(<span class="string">"name"</span>).CanSet())</span><br><span class="line">    <span class="comment">// 是否可以改变这个值 (true)</span></span><br><span class="line">    fmt.Println(reflect.Indirect(reflect.ValueOf(&amp;(a.name))).CanSet())</span><br><span class="line">    <span class="comment">// 不可改变 (false)</span></span><br><span class="line">    fmt.Println(reflect.Indirect(reflect.ValueOf(s)).CanSet())</span><br><span class="line">    <span class="comment">// 可以改变</span></span><br><span class="line">    <span class="comment">// reflect.Indirect(reflect.ValueOf(&amp;s)).SetString("jbnl")</span></span><br><span class="line">    fmt.Println(reflect.Indirect(reflect.ValueOf(&amp;s)).CanSet())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照惯例，错误通常是最后一个返回值并且是 error 类型，一个内建的接口。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(arg <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> arg == <span class="number">42</span> &#123;</span><br><span class="line">        <span class="comment">// errors.New 构造一个使用给定的错误信息的基本error 值。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"can't work with 42"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回错误值为 nil 代表没有错误。</span></span><br><span class="line">    <span class="keyword">return</span> arg + <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过实现 Error 方法来自定义 error 类型是可以的。这里使用自定义错误类型来表示上面的参数错误。</span></span><br><span class="line"><span class="keyword">type</span> argError <span class="keyword">struct</span> &#123;</span><br><span class="line">    arg  <span class="keyword">int</span></span><br><span class="line">    prob <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *argError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d - %s"</span>, e.arg, e.prob)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(arg <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> arg == <span class="number">42</span> &#123;</span><br><span class="line">        <span class="comment">// 在这个例子中，我们使用 &amp;argError 语法来建立一个新的结构体，并提供了 arg 和 prob 这个两个字段的值。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, &amp;argError&#123;arg, <span class="string">"can't work with it"</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arg + <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 下面的两个循环测试了各个返回错误的函数。注意在 if行内的错误检查代码，在 Go 中是一个普遍的用法。</span></span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">42</span>&#125; &#123;</span><br><span class="line">        <span class="keyword">if</span> r, e := f1(i); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"f1 failed:"</span>, e)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"f1 worked:"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">42</span>&#125; &#123;</span><br><span class="line">        <span class="keyword">if</span> r, e := f2(i); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"f2 failed:"</span>, e)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"f2 worked:"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 你如果想在程序中使用一个自定义错误类型中的数据，你需要通过类型断言来得到这个错误类型的实例。</span></span><br><span class="line">    _, e := f2(<span class="number">42</span>)</span><br><span class="line">    <span class="keyword">if</span> ae, ok := e.(*argError); ok &#123;</span><br><span class="line">        fmt.Println(ae.arg)</span><br><span class="line">        fmt.Println(ae.prob)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 排序方法是正对内置数据类型的；这里是一个字符串的例子。注意排序是原地更新的，所以他会改变给定的序列并且不返回一个新值。</span></span><br><span class="line">    strs := []<span class="keyword">string</span>&#123;<span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>&#125;</span><br><span class="line">    sort.Strings(strs)</span><br><span class="line">    fmt.Println(<span class="string">"Strings:"</span>, strs)</span><br><span class="line">    <span class="comment">// 一个 int 排序的例子。</span></span><br><span class="line">    ints := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sort.Ints(ints)</span><br><span class="line">    fmt.Println(<span class="string">"Ints:   "</span>, ints)</span><br><span class="line">    <span class="comment">// 我们也可以使用 sort 来检查一个序列是不是已经是排好序的。</span></span><br><span class="line">    s := sort.IntsAreSorted(ints)</span><br><span class="line">    fmt.Println(<span class="string">"Sorted: "</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了在 Go 中使用自定义函数进行排序，我们需要一个对应的类型。这里我们创建一个为内置 []string 类型的别名的ByLength 类型，</span></span><br><span class="line"><span class="keyword">type</span> ByLength []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在类型中实现了 sort.Interface 的 Len，Less和 Swap 方法，这样我们就可以使用 sort 包的通用Sort 方法了，Len 和 Swap 通常在各个类型中都差不多，Less 将控制实际的自定义排序逻辑。在我们的例子中，我们想按字符串长度增加的顺序来排序，所以这里使用了 len(s[i]) 和 len(s[j])。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByLength)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByLength)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByLength)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s[i]) &lt; <span class="built_in">len</span>(s[j])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一切都准备好了，我们现在可以通过将原始的 fruits 切片转型成 ByLength 来实现我们的自定排序了。然后对这个转型的切片使用 sort.Sort 方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fruits := []<span class="keyword">string</span>&#123;<span class="string">"peach"</span>, <span class="string">"banana"</span>, <span class="string">"kiwi"</span>&#125;</span><br><span class="line">    sort.Sort(ByLength(fruits))</span><br><span class="line">    fmt.Println(fruits)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 我们将在这个网站中使用 panic 来检查预期外的错误。这个是唯一一个为 panic 准备的例子。</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"a problem"</span>)</span><br><span class="line">    <span class="comment">// panic 的一个基本用法就是在一个函数返回了错误值但是我们并不知道（或者不想）处理时终止运行。这里是一个在创建一个新文件时返回异常错误时的panic 用法。</span></span><br><span class="line">    _, err := os.Create(<span class="string">"/tmp/file"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们想要创建一个文件，向它进行写操作，然后在结束时关闭它。这里展示了如何通过 defer 来做到这一切。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在 closeFile 后得到一个文件对象，我们使用 defer通过 closeFile 来关闭这个文件。这会在封闭函数（main）结束时执行，就是 writeFile 结束后。</span></span><br><span class="line">    f := createFile(<span class="string">"/tmp/defer.txt"</span>)</span><br><span class="line">    <span class="keyword">defer</span> closeFile(f)</span><br><span class="line">    writeFile(f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createFile</span><span class="params">(p <span class="keyword">string</span>)</span> *<span class="title">os</span>.<span class="title">File</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"creating"</span>)</span><br><span class="line">    f, err := os.Create(p)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">(f *os.File)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"writing"</span>)</span><br><span class="line">    fmt.Fprintln(f, <span class="string">"data"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closeFile</span><span class="params">(f *os.File)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"closing"</span>)</span><br><span class="line">    f.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := fmt.Println</span><br><span class="line">    <span class="comment">// 得到当前时间。</span></span><br><span class="line">    now := time.Now()</span><br><span class="line">    p(now)</span><br><span class="line">    <span class="comment">// 通过提供年月日等信息，你可以构建一个 time。时间总是关联着位置信息，例如时区。</span></span><br><span class="line">    then := time.Date(</span><br><span class="line">        <span class="number">2009</span>, <span class="number">11</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">34</span>, <span class="number">58</span>, <span class="number">651387237</span>, time.UTC)</span><br><span class="line">    p(then)</span><br><span class="line">    <span class="comment">// 你可以提取出时间的各个组成部分。</span></span><br><span class="line">    p(then.Year())</span><br><span class="line">    p(then.Month())</span><br><span class="line">    p(then.Day())</span><br><span class="line">    p(then.Hour())</span><br><span class="line">    p(then.Minute())</span><br><span class="line">    p(then.Second())</span><br><span class="line">    p(then.Nanosecond())</span><br><span class="line">    p(then.Location())</span><br><span class="line">    <span class="comment">// 输出是星期一到日的 Weekday 也是支持的。</span></span><br><span class="line">    p(then.Weekday())</span><br><span class="line">    <span class="comment">// 这些方法来比较两个时间，分别测试一下是否是之前，之后或者是同一时刻，精确到秒。</span></span><br><span class="line">    p(then.Before(now))</span><br><span class="line">    p(then.After(now))</span><br><span class="line">    p(then.Equal(now))</span><br><span class="line">    <span class="comment">// 方法 Sub 返回一个 Duration 来表示两个时间点的间隔时间。</span></span><br><span class="line">    diff := now.Sub(then)</span><br><span class="line">    p(diff)</span><br><span class="line">    <span class="comment">// 我们计算出不同单位下的时间长度值。</span></span><br><span class="line">    p(diff.Hours())</span><br><span class="line">    p(diff.Minutes())</span><br><span class="line">    p(diff.Seconds())</span><br><span class="line">    p(diff.Nanoseconds())</span><br><span class="line">    <span class="comment">// 你可以使用 Add 将时间后移一个时间间隔，或者使用一个 - 来将时间前移一个时间间隔。</span></span><br><span class="line">    p(then.Add(diff))</span><br><span class="line">    p(then.Add(-diff))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 分别使用带 Unix 或者 UnixNano 的 time.Now来获取从自协调世界时起到现在的秒数或者纳秒数。</span></span><br><span class="line">    now := time.Now()</span><br><span class="line">    secs := now.Unix()</span><br><span class="line">    nanos := now.UnixNano()</span><br><span class="line">    fmt.Println(now)</span><br><span class="line">    <span class="comment">// 注意 UnixMillis 是不存在的，所以要得到毫秒数的话，你要自己手动的从纳秒转化一下。</span></span><br><span class="line">    millis := nanos / <span class="number">1000000</span></span><br><span class="line">    fmt.Println(secs)</span><br><span class="line">    fmt.Println(millis)</span><br><span class="line">    fmt.Println(nanos)</span><br><span class="line">    <span class="comment">// 你也可以将协调世界时起的整数秒或者纳秒转化到相应的时间。</span></span><br><span class="line">    fmt.Println(time.Unix(secs, <span class="number">0</span>))</span><br><span class="line">    fmt.Println(time.Unix(<span class="number">0</span>, nanos))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间的格式化与解析"><a href="#时间的格式化与解析" class="headerlink" title="时间的格式化与解析"></a>时间的格式化与解析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := fmt.Println</span><br><span class="line">    <span class="comment">// 这里是一个基本的按照 RFC3339 进行格式化的例子，使用对应模式常量。</span></span><br><span class="line">    t := time.Now()</span><br><span class="line">    p(t.Format(time.RFC3339))</span><br><span class="line">    <span class="comment">// 时间解析使用同 Format 相同的形式值。</span></span><br><span class="line">    t1, e := time.Parse(</span><br><span class="line">        time.RFC3339,</span><br><span class="line">        <span class="string">"2012-11-01T22:08:41+00:00"</span>)</span><br><span class="line">    p(t1)</span><br><span class="line">    <span class="comment">// Format 和 Parse 使用基于例子的形式来决定日期格式，一般你只要使用 time 包中提供的模式常量就行了，但是你也可以实现自定义模式。模式必须使用时间 Mon Jan 2 15:04:05 MST 2006来指定给定时间/字符串的格式化/解析方式。时间一定要按照如下所示：2006为年，15 为小时，Monday 代表星期几，等等。</span></span><br><span class="line">    p(t.Format(<span class="string">"3:04PM"</span>))</span><br><span class="line">    p(t.Format(<span class="string">"Mon Jan _2 15:04:05 2006"</span>))</span><br><span class="line">    p(t.Format(<span class="string">"2006-01-02T15:04:05.999999-07:00"</span>))</span><br><span class="line">    form := <span class="string">"3 04 PM"</span></span><br><span class="line">    t2, e := time.Parse(form, <span class="string">"8 41 PM"</span>)</span><br><span class="line">    p(t2)</span><br><span class="line">    <span class="comment">// 对于纯数字表示的时间，你也可以使用标准的格式化字符串来提出出时间值得组成。</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d-%02d-%02dT%02d:%02d:%02d-00:00\n"</span>,</span><br><span class="line">        t.Year(), t.Month(), t.Day(),</span><br><span class="line">        t.Hour(), t.Minute(), t.Second())</span><br><span class="line">    <span class="comment">// Parse 函数在输入的时间格式不正确是会返回一个错误。</span></span><br><span class="line">    ansic := <span class="string">"Mon Jan _2 15:04:05 2006"</span></span><br><span class="line">    _, e = time.Parse(ansic, <span class="string">"8:41PM"</span>)</span><br><span class="line">    p(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数字解析"><a href="#数字解析" class="headerlink" title="数字解析"></a>数字解析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用 ParseFloat 解析浮点数，这里的 64 表示表示解析的数的位数。</span></span><br><span class="line">    f, _ := strconv.ParseFloat(<span class="string">"1.234"</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(f)</span><br><span class="line">    <span class="comment">// 在使用 ParseInt 解析整形数时，例子中的参数 0 表示自动推断字符串所表示的数字的进制。64 表示返回的整形数是以 64 位存储的。</span></span><br><span class="line">    i, _ := strconv.ParseInt(<span class="string">"123"</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    <span class="comment">// ParseInt 会自动识别出十六进制数。</span></span><br><span class="line">    d, _ := strconv.ParseInt(<span class="string">"0x1c8"</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(d)</span><br><span class="line">    <span class="comment">// ParseUint 也是可用的。</span></span><br><span class="line">    u, _ := strconv.ParseUint(<span class="string">"789"</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(u)</span><br><span class="line">    <span class="comment">// Atoi 是一个基础的 10 进制整型数转换函数。</span></span><br><span class="line">    k, _ := strconv.Atoi(<span class="string">"135"</span>)</span><br><span class="line">    fmt.Println(k)</span><br><span class="line">    <span class="comment">// 在输入错误时，解析函数会返回一个错误。</span></span><br><span class="line">    _, e := strconv.Atoi(<span class="string">"wat"</span>)</span><br><span class="line">    fmt.Println(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="url-解析"><a href="#url-解析" class="headerlink" title="url 解析"></a>url 解析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 我们将解析这个 URL 示例，它包含了一个 scheme，认证信息，主机名，端口，路径，查询参数和片段。</span></span><br><span class="line">    s := <span class="string">"postgres://user:pass@host.com:5432/path?k=v#f"</span></span><br><span class="line">    <span class="comment">// 解析这个 URL 并确保解析没有出错。</span></span><br><span class="line">    u, err := url.Parse(s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接访问 scheme。</span></span><br><span class="line">    fmt.Println(u.Scheme) <span class="comment">// postgres</span></span><br><span class="line">    <span class="comment">// User 包含了所有的认证信息，这里调用 Username和 Password 来获取独立值。</span></span><br><span class="line">    fmt.Println(u.User)            <span class="comment">// user:pass</span></span><br><span class="line">    fmt.Println(u.User.Username()) <span class="comment">// user</span></span><br><span class="line">    p, _ := u.User.Password()</span><br><span class="line">    fmt.Println(p) <span class="comment">// pass</span></span><br><span class="line">    <span class="comment">// Host 同时包括主机名和端口信息，如过端口存在的话，使用 strings.Split() 从 Host 中手动提取端口。</span></span><br><span class="line">    fmt.Println(u.Host) <span class="comment">// host.com:5432</span></span><br><span class="line">    h := strings.Split(u.Host, <span class="string">":"</span>)</span><br><span class="line">    fmt.Println(h[<span class="number">0</span>]) <span class="comment">// host.com</span></span><br><span class="line">    fmt.Println(h[<span class="number">1</span>]) <span class="comment">// 5432</span></span><br><span class="line">    <span class="comment">// 这里我们提出路径和查询片段信息。</span></span><br><span class="line">    fmt.Println(u.Path)     <span class="comment">// /path</span></span><br><span class="line">    fmt.Println(u.Fragment) <span class="comment">// f</span></span><br><span class="line">    <span class="comment">// 要得到字符串中的 k=v 这种格式的查询参数，可以使用 RawQuery 函数。你也可以将查询参数解析为一个map。</span></span><br><span class="line">    <span class="comment">// 已解析的查询参数 map 以查询字符串为键，对应值字符串切片为值，所以如何只想得到一个键对应的第一个值，将索引位置设置为 [0] 就行了。</span></span><br><span class="line">    fmt.Println(u.RawQuery) <span class="comment">// k=v</span></span><br><span class="line">    m, _ := url.ParseQuery(u.RawQuery)</span><br><span class="line">    fmt.Println(m)         <span class="comment">// map[k:[v]]</span></span><br><span class="line">    fmt.Println(m[<span class="string">"k"</span>][<span class="number">0</span>]) <span class="comment">// v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 例如，rand.Intn 返回一个随机的整数 n，0 &lt;= n &lt;= 100。</span></span><br><span class="line">    fmt.Print(rand.Intn(<span class="number">100</span>), <span class="string">","</span>)</span><br><span class="line">    fmt.Print(rand.Intn(<span class="number">100</span>))</span><br><span class="line">    fmt.Println()</span><br><span class="line">    <span class="comment">// rand.Float64 返回一个64位浮点数 f，0.0 &lt;= f &lt;= 1.0。</span></span><br><span class="line">    fmt.Println(rand.Float64())</span><br><span class="line">    <span class="comment">// 这个技巧可以用来生成其他范围的随机浮点数，例如5.0 &lt;= f &lt;= 10.0</span></span><br><span class="line">    fmt.Print((rand.Float64()*<span class="number">5</span>)+<span class="number">5</span>, <span class="string">","</span>)</span><br><span class="line">    fmt.Print((rand.Float64() * <span class="number">5</span>) + <span class="number">5</span>)</span><br><span class="line">    fmt.Println()</span><br><span class="line">    <span class="comment">// 默认情况下，给定的种子是确定的，每次都会产生相同的随机数数字序列。要产生变化的序列，需要给定一个变化的种子。需要注意的是，如果你出于加密目的，需要使用随机数的话，请使用 crypto/rand 包，此方法不够安全。</span></span><br><span class="line">    s1 := rand.NewSource(time.Now().UnixNano())</span><br><span class="line">    r1 := rand.New(s1)</span><br><span class="line">    <span class="comment">// 调用上面返回的 rand.Source 的函数和调用 rand 包中函数是相同的。</span></span><br><span class="line">    fmt.Print(r1.Intn(<span class="number">100</span>), <span class="string">","</span>)</span><br><span class="line">    fmt.Print(r1.Intn(<span class="number">100</span>))</span><br><span class="line">    fmt.Println()</span><br><span class="line">    <span class="comment">// 如果使用相同的种子生成的随机数生成器，将会产生相同的随机数序列。</span></span><br><span class="line">    s2 := rand.NewSource(<span class="number">42</span>)</span><br><span class="line">    r2 := rand.New(s2)</span><br><span class="line">    fmt.Print(r2.Intn(<span class="number">100</span>), <span class="string">","</span>)</span><br><span class="line">    fmt.Print(r2.Intn(<span class="number">100</span>))</span><br><span class="line">    fmt.Println()</span><br><span class="line">    s3 := rand.NewSource(<span class="number">42</span>)</span><br><span class="line">    r3 := rand.New(s3)</span><br><span class="line">    fmt.Print(r3.Intn(<span class="number">100</span>), <span class="string">","</span>)</span><br><span class="line">    fmt.Print(r3.Intn(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SHA1-散列"><a href="#SHA1-散列" class="headerlink" title="SHA1 散列"></a>SHA1 散列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"sha1"</span></span><br><span class="line">    <span class="comment">// 产生一个散列值得方式是 sha1.New()，sha1.Write(bytes)，然后 sha1.Sum([]byte&#123;&#125;)。这里我们从一个新的散列开始。</span></span><br><span class="line">    h := sha1.New()</span><br><span class="line">    <span class="comment">// 写入要处理的字节。如果是一个字符串，需要使用[]byte(s) 来强制转换成字节数组。</span></span><br><span class="line">    h.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">    <span class="comment">// 这个用来得到最终的散列值的字符切片。Sum 的参数可以用来都现有的字符切片追加额外的字节切片：一般不需要要。</span></span><br><span class="line">    bs := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// SHA1 值经常以 16 进制输出，例如在 git commit 中。使用%x 来将散列结果格式化为 16 进制字符串。</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">    fmt.Printf(<span class="string">"%x\n"</span>, bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BASE64-编码"><a href="#BASE64-编码" class="headerlink" title="BASE64 编码"></a>BASE64 编码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这是将要编解码的字符串。</span></span><br><span class="line">    data := <span class="string">"abc123!?$*&amp;()'-=@~"</span></span><br><span class="line">    <span class="comment">// Go 同时支持标准的和 URL 兼容的 base64 格式。编码需要使用 []byte 类型的参数，所以要将字符串转成此类型。</span></span><br><span class="line">    <span class="comment">// 标准 base64 编码和 URL 兼容 base64 编码的编码字符串存在稍许不同（后缀为 + 和 -），但是两者都可以正确解码为原始字符串。</span></span><br><span class="line">    sEnc := base64.StdEncoding.EncodeToString([]<span class="keyword">byte</span>(data))</span><br><span class="line">    fmt.Println(sEnc)</span><br><span class="line">    <span class="comment">// 解码可能会返回错误，如果不确定输入信息格式是否正确，那么，你就需要进行错误检查了。</span></span><br><span class="line">    sDec, _ := base64.StdEncoding.DecodeString(sEnc)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(sDec))</span><br><span class="line">    fmt.Println()</span><br><span class="line">    <span class="comment">// 使用 URL 兼容的 base64 格式进行编解码。</span></span><br><span class="line">    uEnc := base64.URLEncoding.EncodeToString([]<span class="keyword">byte</span>(data))</span><br><span class="line">    fmt.Println(uEnc)</span><br><span class="line">    uDec, _ := base64.URLEncoding.DecodeString(uEnc)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(uDec))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(from <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Println(from, <span class="string">":"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 假设我们有一个函数叫做 f(s)。我们使用一般的方式调并同时运行。</span></span><br><span class="line">    f(<span class="string">"direct"</span>)</span><br><span class="line">    <span class="comment">// 使用 go f(s) 在一个 Go 协程中调用这个函数。这个新的 Go 协程将会并行的执行这个函数调用。</span></span><br><span class="line">    <span class="keyword">go</span> f(<span class="string">"goroutine"</span>)</span><br><span class="line">    <span class="comment">// 你也可以为匿名函数启动一个 Go 协程。</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(msg)</span><br><span class="line">    &#125;(<span class="string">"going"</span>)</span><br><span class="line">    <span class="comment">// 现在这两个 Go 协程在独立的 Go 协程中异步的运行，所以我们需要等它们执行结束。这里的 Scanln 代码需要我们在程序退出前按下任意键结束。</span></span><br><span class="line">    <span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">    fmt.Scanln(&amp;input)</span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">    <span class="comment">// 当我们运行这个程序时，将首先看到阻塞式调用的输出，然后是两个 Go 协程的交替输出。这种交替的情况表示 Go 运行时是以异步的方式运行协程的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通道 是连接多个 Go 协程的管道。你可以从一个 Go 协程将值发送到通道，然后在别的 Go 协程中接收。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用 make(chan val-type) 创建一个新的通道。通道类型就是他们需要传递值的类型。</span></span><br><span class="line">    messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="comment">// 使用 channel &lt;- 语法 发送 一个新的值到通道中。这里我们在一个新的 Go 协程中发送 "ping" 到上面创建的messages 通道中。</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; messages &lt;- <span class="string">"ping"</span> &#125;()</span><br><span class="line">    <span class="comment">// 使用 &lt;-channel 语法从通道中 接收 一个值。这里将接收我们在上面发送的 "ping" 消息并打印出来。</span></span><br><span class="line">    msg := &lt;-messages</span><br><span class="line">    fmt.Println(msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们运行程序时，通过通道，消息 "ping" 成功的从一个 Go 协程传到另一个中。</span></span><br><span class="line"><span class="comment">// 默认发送和接收操作是阻塞的，直到发送方和接收方都准备完毕。这个特性允许我们，不使用任何其它的同步操作，来在程序结尾等待消息 "ping"。</span></span><br></pre></td></tr></table></figure><h3 id="通道缓冲"><a href="#通道缓冲" class="headerlink" title="通道缓冲"></a>通道缓冲</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认通道是 无缓冲 的，这意味着只有在对应的接收（&lt;- chan）通道准备好接收时，才允许进行发送（chan &lt;-）。可缓存通道允许在没有对应接收方的情况下，缓存限定数量的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里我们 make 了一个通道，最多允许缓存 2 个值。</span></span><br><span class="line">    messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 因为这个通道是有缓冲区的，即使没有一个对应的并发接收方，我们仍然可以发送这些值。</span></span><br><span class="line">    messages &lt;- <span class="string">"buffered"</span></span><br><span class="line">    messages &lt;- <span class="string">"channel"</span></span><br><span class="line">    <span class="comment">// 然后我们可以像前面一样接收这两个值。</span></span><br><span class="line">    fmt.Println(&lt;-messages)</span><br><span class="line">    fmt.Println(&lt;-messages)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通道同步"><a href="#通道同步" class="headerlink" title="通道同步"></a>通道同步</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们可以使用通道来同步 Go 协程间的执行状态。这里是一个使用阻塞的接受方式来等待一个 Go 协程的运行结束。</span></span><br><span class="line"><span class="comment">// 这是一个我们将要在 Go 协程中运行的函数。done 通道将被用于通知其他 Go 协程这个函数已经工作完毕。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">"working..."</span>)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">    <span class="comment">// 发送一个值来通知我们已经完工啦。</span></span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 运行一个 worker Go协程，并给予用于通知的通道。</span></span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> worker(done)</span><br><span class="line">    <span class="comment">// 程序将在接收到通道中 worker 发出的通知前一直阻塞。</span></span><br><span class="line">    &lt;-done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你把 &lt;- done 这行代码从程序中移除，程序甚至会在 worker还没开始运行时就结束了</span></span><br></pre></td></tr></table></figure><h3 id="通道方向"><a href="#通道方向" class="headerlink" title="通道方向"></a>通道方向</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ping 函数定义了一个只允许发送数据的通道。尝试使用这个通道来接收数据将会得到一个编译时错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping</span><span class="params">(pings <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>, msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    pings &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pong 函数允许通道（pings）来接收数据，另一通道（pongs）来发送数据。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pong</span><span class="params">(pings &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>, pongs <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    msg := &lt;-pings</span><br><span class="line">    pongs &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pings := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">    pongs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">    ping(pings, <span class="string">"passed message"</span>)</span><br><span class="line">    pong(pings, pongs)</span><br><span class="line">    fmt.Println(&lt;-pongs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通道选择器"><a href="#通道选择器" class="headerlink" title="通道选择器"></a>通道选择器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在我们的例子中，我们将从两个通道中选择。</span></span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="comment">// 各个通道将在若干时间后接收一个值，这个用来模拟例如并行的 Go 协程中阻塞的 RPC 操作</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">        c1 &lt;- <span class="string">"one"</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">        c2 &lt;- <span class="string">"two"</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 我们使用 select 关键字来同时等待这两个值，并打印各自接收到的值。</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">            fmt.Println(<span class="string">"received"</span>, msg1)</span><br><span class="line">        <span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">            fmt.Println(<span class="string">"received"</span>, msg2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在我们的例子中，假如我们执行一个外部调用，并在 2 秒后通过通道 c1 返回它的执行结果。</span></span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">        c1 &lt;- <span class="string">"result 1"</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 这里是使用 select 实现一个超时操作。res := &lt;- c1 等待结果，&lt;-Time.After 等待超时时间 1 秒后发送的值。由于 select 默认处理第一个已准备好的接收操作，如果这个操作超过了允许的 1 秒的话，将会执行超时 case。</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c1:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>):</span><br><span class="line">        fmt.Println(<span class="string">"timeout 1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果我允许一个长一点的超时时间 3 秒，将会成功的从 c2接收到值，并且打印出结果。</span></span><br><span class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">        c2 &lt;- <span class="string">"result 2"</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c2:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">3</span>):</span><br><span class="line">        fmt.Println(<span class="string">"timeout 2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非阻塞通道"><a href="#非阻塞通道" class="headerlink" title="非阻塞通道"></a>非阻塞通道</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规的通过通道发送和接收数据是阻塞的。然而，我们可以使用带一个 default 子句的 select 来实现非阻塞 的发送、接收，甚至是非阻塞的多路 select。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    signals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="comment">// 这里是一个非阻塞接收的例子。如果在 messages 中存在，然后 select 将这个值带入 &lt;-messages case中。如果不是，就直接到 default 分支中。</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg := &lt;-messages:</span><br><span class="line">        fmt.Println(<span class="string">"received message"</span>, msg)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"no message received"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一个非阻塞发送的实现方法和上面一样。</span></span><br><span class="line">    msg := <span class="string">"hi"</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> messages &lt;- msg:</span><br><span class="line">        fmt.Println(<span class="string">"sent message"</span>, msg)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"no message sent"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我们可以在 default 前使用多个 case 子句来实现一个多路的非阻塞的选择器。这里我们试图在 messages和 signals 上同时使用非阻塞的接受操作。</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg := &lt;-messages:</span><br><span class="line">        fmt.Println(<span class="string">"received message"</span>, msg)</span><br><span class="line">    <span class="keyword">case</span> sig := &lt;-signals:</span><br><span class="line">        fmt.Println(<span class="string">"received signal"</span>, sig)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"no activity"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通道的关闭"><a href="#通道的关闭" class="headerlink" title="通道的关闭"></a>通道的关闭</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭 一个通道意味着不能再向这个通道发送值了。这个特性可以用来给这个通道的接收方传达工作已经完成的信息。</span></span><br><span class="line"><span class="comment">// 在这个例子中，我们将使用一个 jobs 通道来传递 main() 中 Go协程任务执行的结束信息到一个工作 Go 协程中。当我们没有多余的任务给这个工作 Go 协程时，我们将 close 这个 jobs 通道。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="comment">// 这是工作 Go 协程。使用 j, more := &lt;- jobs 循环的从jobs 接收数据。在接收的这个特殊的二值形式的值中，如果 jobs 已经关闭了，并且通道中所有的值都已经接收完毕，那么 more 的值将是 false。当我们完成所有的任务时，将使用这个特性通过 done 通道去进行通知。</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            j, more := &lt;-jobs</span><br><span class="line">            <span class="keyword">if</span> more &#123;</span><br><span class="line">                fmt.Println(<span class="string">"received job"</span>, j)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"received all jobs"</span>)</span><br><span class="line">                done &lt;- <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 这里使用 jobs 发送 3 个任务到工作函数中，然后关闭 jobs。</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++ &#123;</span><br><span class="line">        jobs &lt;- j</span><br><span class="line">        fmt.Println(<span class="string">"sent job"</span>, j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line">    fmt.Println(<span class="string">"sent all jobs"</span>)</span><br><span class="line">    <span class="comment">// 我们使用前面学到的通道同步方法等待任务结束。</span></span><br><span class="line">    &lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通道遍历"><a href="#通道遍历" class="headerlink" title="通道遍历"></a>通道遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在前面的例子中，我们讲过 for 和 range为基本的数据结构提供了迭代的功能。我们也可以使用这个语法来遍历从通道中取得的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 我们将遍历在 queue 通道中的两个值。</span></span><br><span class="line">    queue := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">    queue &lt;- <span class="string">"one"</span></span><br><span class="line">    queue &lt;- <span class="string">"two"</span></span><br><span class="line">    <span class="built_in">close</span>(queue)</span><br><span class="line">    <span class="comment">// 这个 range 迭代从 queue 中得到的每个值。因为我们在前面 close 了这个通道，这个迭代会在接收完 2 个值之后结束。如果我们没有 close 它，我们将在这个循环中继续阻塞执行，等待接收第三个值</span></span><br><span class="line">    <span class="keyword">for</span> elem := <span class="keyword">range</span> queue &#123;</span><br><span class="line">        fmt.Println(elem)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个例子也让我们看到，一个非空的通道也是可以关闭的，但是通道中剩下的值仍然可以被接收到。</span></span><br></pre></td></tr></table></figure><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定时器表示在未来某一时刻的独立事件。你告诉定时器需要等待的时间，然后它将提供一个用于通知的通道。这里的定时器将等待 2 秒。</span></span><br><span class="line">    timer1 := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// &lt;-timer1.C 直到这个定时器的通道 C 明确的发送了定时器失效的值之前，将一直阻塞。</span></span><br><span class="line">    &lt;-timer1.C</span><br><span class="line">    fmt.Println(<span class="string">"Timer 1 expired"</span>)</span><br><span class="line">    <span class="comment">// 如果你需要的仅仅是单纯的等待，你需要使用 time.Sleep。定时器是有用原因之一就是你可以在定时器失效之前，取消这个定时器。这是一个例子</span></span><br><span class="line">    timer2 := time.NewTimer(time.Second)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-timer2.C</span><br><span class="line">        fmt.Println(<span class="string">"Timer 2 expired"</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    stop2 := timer2.Stop()</span><br><span class="line">    <span class="keyword">if</span> stop2 &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Timer 2 stopped"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打点器"><a href="#打点器" class="headerlink" title="打点器"></a>打点器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打点器和定时器的机制有点相似：一个通道用来发送数据。这里我们在这个通道上使用内置的 range 来迭代值每隔500ms 发送一次的值。</span></span><br><span class="line">    ticker := time.NewTicker(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> t := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Tick at"</span>, t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 打点器可以和定时器一样被停止。一旦一个打点停止了，将不能再从它的通道中接收到值。我们将在运行后 1600ms停止这个打点器。</span></span><br><span class="line">    time.Sleep(time.Millisecond * <span class="number">1600</span>)</span><br><span class="line">    ticker.Stop()</span><br><span class="line">    fmt.Println(<span class="string">"Ticker stopped"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工作池"><a href="#工作池" class="headerlink" title="工作池"></a>工作池</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是我们将要在多个并发实例中支持的任务了。这些执行者将从 jobs 通道接收任务，并且通过 results 发送对应的结果。我们将让每个任务间隔 1s 来模仿一个耗时的任务。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, results <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">        fmt.Println(<span class="string">"worker"</span>, id, <span class="string">"processing job"</span>, j)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        results &lt;- j * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 为了使用 worker 工作池并且收集他们的结果，我们需要2 个通道。</span></span><br><span class="line">    jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">    results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="comment">// 这里启动了 3 个 worker，初始是阻塞的，因为还没有传递任务。</span></span><br><span class="line">    <span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= <span class="number">3</span>; w++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(w, jobs, results)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里我们发送 9 个 jobs，然后 close 这些通道来表示这些就是所有的任务了。</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++ &#123;</span><br><span class="line">        jobs &lt;- j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line">    <span class="comment">// 最后，我们收集所有这些任务的返回值。</span></span><br><span class="line">    <span class="keyword">for</span> a := <span class="number">1</span>; a &lt;= <span class="number">9</span>; a++ &#123;</span><br><span class="line">        &lt;-results</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行这个程序，显示 9 个任务被多个 worker 执行。整个程序处理所有的任务仅执行了 3s 而不是 9s，是因为 3 个 worker是并行的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="速率限制-未懂"><a href="#速率限制-未懂" class="headerlink" title="速率限制(未懂)"></a>速率限制(未懂)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 首先我们将看一下基本的速率限制。假设我们想限制我们接收请求的处理，我们将这些请求发送给一个相同的通道。</span></span><br><span class="line">    requests := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        requests &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(requests)</span><br><span class="line">    <span class="comment">// 这个 limiter 通道将每 200ms 接收一个值。这个是速率限制任务中的管理器。</span></span><br><span class="line">    limiter := time.Tick(time.Millisecond * <span class="number">200</span>)</span><br><span class="line">    <span class="comment">// 通过在每次请求前阻塞 limiter 通道的一个接收，我们限制自己每 200ms 执行一次请求。</span></span><br><span class="line">    <span class="keyword">for</span> req := <span class="keyword">range</span> requests &#123;</span><br><span class="line">        &lt;-limiter</span><br><span class="line">        fmt.Println(<span class="string">"request"</span>, req, time.Now())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有时候我们想临时进行速率限制，并且不影响整体的速率控制我们可以通过通道缓冲来实现。这个 burstyLimiter 通道用来进行 3 次临时的脉冲型速率限制。</span></span><br><span class="line">    burstyLimiter := <span class="built_in">make</span>(<span class="keyword">chan</span> time.Time, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 想将通道填充需要临时改变3次的值，做好准备。</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        burstyLimiter &lt;- time.Now()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每 200 ms 我们将添加一个新的值到 burstyLimiter中，直到达到 3 个的限制。</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> t := <span class="keyword">range</span> time.Tick(time.Millisecond * <span class="number">200</span>) &#123;</span><br><span class="line">            burstyLimiter &lt;- t</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 现在模拟超过 5 个的接入请求。它们中刚开始的 3 个将由于受 burstyLimiter 的“脉冲”影响。</span></span><br><span class="line">    burstyRequests := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        burstyRequests &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(burstyRequests)</span><br><span class="line">    <span class="keyword">for</span> req := <span class="keyword">range</span> burstyRequests &#123;</span><br><span class="line">        &lt;-burstyLimiter</span><br><span class="line">        fmt.Println(<span class="string">"request"</span>, req, time.Now())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 运行程序，我们看到第一批请求意料之中的大约每 200ms 处理一次。</span></span><br><span class="line">    <span class="comment">// 第二批请求，我们直接连续处理了 3 次，这是由于这个“脉冲”速率控制，然后大约每 200ms 处理其余的 2 个。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原子计数器"><a href="#原子计数器" class="headerlink" title="原子计数器"></a>原子计数器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 我们将使用一个无符号整型数来表示（永远是正整数）这个计数器。</span></span><br><span class="line">    <span class="keyword">var</span> ops <span class="keyword">uint64</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 为了模拟并发更新，我们启动 50 个 Go 协程，对计数器每隔 1ms （译者注：应为非准确时间）进行一次加一操作。</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="comment">// 使用 AddUint64 来让计数器自动增加，使用&amp; 语法来给出 ops 的内存地址。</span></span><br><span class="line">                atomic.AddUint64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 允许其它 Go 协程的执行</span></span><br><span class="line">                runtime.Gosched()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待一秒，让 ops 的自加操作执行一会。</span></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    <span class="comment">// 为了在计数器还在被其它 Go 协程更新时，安全的使用它，我们通过 LoadUint64 将当前值的拷贝提取到 opsFinal中。和上面一样，我们需要给这个函数所取值的内存地址 &amp;ops</span></span><br><span class="line">    opsFinal := atomic.LoadUint64(&amp;ops)</span><br><span class="line">    fmt.Println(<span class="string">"ops:"</span>, opsFinal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥锁-未懂"><a href="#互斥锁-未懂" class="headerlink" title="互斥锁(未懂)"></a>互斥锁(未懂)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在我们的例子中，state 是一个 map。</span></span><br><span class="line">    <span class="keyword">var</span> state = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="comment">// 这里的 mutex 将同步对 state 的访问。</span></span><br><span class="line">    <span class="keyword">var</span> mutex = &amp;sync.Mutex&#123;&#125;</span><br><span class="line">    <span class="comment">// we'll see later, ops will count how manyoperations we perform against the state.为了比较基于互斥锁的处理方式和我们后面将要看到的其他方式，ops 将记录我们对 state 的操作次数。</span></span><br><span class="line">    <span class="keyword">var</span> ops <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 这里我们运行 100 个 Go 协程来重复读取 state。</span></span><br><span class="line">    <span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="number">100</span>; r++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            total := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="comment">// 每次循环读取，我们使用一个键来进行访问，Lock() 这个 mutex 来确保对 state 的独占访问，读取选定的键的值，Unlock() 这个mutex，并且 ops 值加 1。</span></span><br><span class="line">                key := rand.Intn(<span class="number">5</span>)</span><br><span class="line">                mutex.Lock()</span><br><span class="line">                total += state[key]</span><br><span class="line">                mutex.Unlock()</span><br><span class="line">                atomic.AddInt64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 为了确保这个 Go 协程不会在调度中饿死，我们在每次操作后明确的使用 runtime.Gosched()进行释放。这个释放一般是自动处理的，像例如每个通道操作后或者 time.Sleep 的阻塞调用后相似，但是在这个例子中我们需要手动的处理。</span></span><br><span class="line">                runtime.Gosched()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同样的，我们运行 10 个 Go 协程来模拟写入操作，使用和读取相同的模式。</span></span><br><span class="line">    <span class="keyword">for</span> w := <span class="number">0</span>; w &lt; <span class="number">10</span>; w++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                key := rand.Intn(<span class="number">5</span>)</span><br><span class="line">                val := rand.Intn(<span class="number">100</span>)</span><br><span class="line">                mutex.Lock()</span><br><span class="line">                state[key] = val</span><br><span class="line">                mutex.Unlock()</span><br><span class="line">                atomic.AddInt64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">                runtime.Gosched()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让这 10 个 Go 协程对 state 和 mutex 的操作运行 1 s。</span></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    <span class="comment">// 获取并输出最终的操作计数。</span></span><br><span class="line">    opsFinal := atomic.LoadInt64(&amp;ops)</span><br><span class="line">    fmt.Println(<span class="string">"ops:"</span>, opsFinal)</span><br><span class="line">    <span class="comment">// 对 state 使用一个最终的锁，显示它是如何结束的。</span></span><br><span class="line">    mutex.Lock()</span><br><span class="line">    fmt.Println(<span class="string">"state:"</span>, state)</span><br><span class="line">    mutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="go状态协程-未读"><a href="#go状态协程-未读" class="headerlink" title="go状态协程(未读)"></a><code>go</code>状态协程(未读)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这个例子中，state 将被一个单独的 Go 协程拥有。这就能够保证数据在并行读取时不会混乱。为了对 state 进行读取或者写入，其他的 Go 协程将发送一条数据到拥有的 Go协程中，然后接收对应的回复。结构体 readOp 和 writeOp封装这些请求，并且是拥有 Go 协程响应的一个方式。</span></span><br><span class="line"><span class="keyword">type</span> readOp <span class="keyword">struct</span> &#123;</span><br><span class="line">    key  <span class="keyword">int</span></span><br><span class="line">    resp <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> writeOp <span class="keyword">struct</span> &#123;</span><br><span class="line">    key  <span class="keyword">int</span></span><br><span class="line">    val  <span class="keyword">int</span></span><br><span class="line">    resp <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 和前面一样，我们将计算我们执行操作的次数。</span></span><br><span class="line">    <span class="keyword">var</span> ops <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// reads 和 writes 通道分别将被其他 Go 协程用来发布读和写请求。</span></span><br><span class="line">    reads := <span class="built_in">make</span>(<span class="keyword">chan</span> *readOp)</span><br><span class="line">    writes := <span class="built_in">make</span>(<span class="keyword">chan</span> *writeOp)</span><br><span class="line">    <span class="comment">// 这个就是拥有 state 的那个 Go 协程，和前面例子中的map一样，不过这里是被这个状态协程私有的。这个 Go 协程反复响应到达的请求。先响应到达的请求，然后返回一个值到响应通道 resp 来表示操作成功（或者是 reads 中请求的值）</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> state = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> read := &lt;-reads:</span><br><span class="line">                read.resp &lt;- state[read.key]</span><br><span class="line">            <span class="keyword">case</span> write := &lt;-writes:</span><br><span class="line">                state[write.key] = write.val</span><br><span class="line">                write.resp &lt;- <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 启动 100 个 Go 协程通过 reads 通道发起对 state 所有者Go 协程的读取请求。每个读取请求需要构造一个 readOp，发送它到 reads 通道中，并通过给定的 resp 通道接收结果。</span></span><br><span class="line">    <span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="number">100</span>; r++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                read := &amp;readOp&#123;</span><br><span class="line">                    key:  rand.Intn(<span class="number">5</span>),</span><br><span class="line">                    resp: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)&#125;</span><br><span class="line">                reads &lt;- read</span><br><span class="line">                &lt;-read.resp</span><br><span class="line">                atomic.AddInt64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用相同的方法启动 10 个写操作。</span></span><br><span class="line">    <span class="keyword">for</span> w := <span class="number">0</span>; w &lt; <span class="number">10</span>; w++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                write := &amp;writeOp&#123;</span><br><span class="line">                    key:  rand.Intn(<span class="number">5</span>),</span><br><span class="line">                    val:  rand.Intn(<span class="number">100</span>),</span><br><span class="line">                    resp: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)&#125;</span><br><span class="line">                writes &lt;- write</span><br><span class="line">                &lt;-write.resp</span><br><span class="line">                atomic.AddInt64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让 Go 协程们跑 1s。</span></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    <span class="comment">// 最后，获取并报告 ops 值。</span></span><br><span class="line">    opsFinal := atomic.LoadInt64(&amp;ops)</span><br><span class="line">    fmt.Println(<span class="string">"ops:"</span>, opsFinal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文件需要经常进行错误检查，这个帮助方法可以精简下面的错误检查过程。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(e error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 也许大部分基本的文件读取任务是将文件内容读取到内存中。</span></span><br><span class="line">    dat, err := ioutil.ReadFile(<span class="string">"/tmp/dat"</span>)</span><br><span class="line">    check(err)</span><br><span class="line">    fmt.Print(<span class="keyword">string</span>(dat))</span><br><span class="line">    <span class="comment">// 你经常会想对于一个文件是怎么读并且读取到哪一部分进行更多的控制。对于这个任务，从使用 os.Open打开一个文件获取一个 os.File 值开始。</span></span><br><span class="line">    f, err := os.Open(<span class="string">"/tmp/dat"</span>)</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    check(err)</span><br><span class="line">    <span class="comment">// 从文件开始位置读取一些字节。这里最多读取 5 个字节，并且这也是我们实际读取的字节数。</span></span><br><span class="line">    b1 := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br><span class="line">    n1, err := f.Read(b1)</span><br><span class="line">    check(err)</span><br><span class="line">    fmt.Printf(<span class="string">"%d bytes: %s\n"</span>, n1, <span class="keyword">string</span>(b1))</span><br><span class="line">    <span class="comment">// 你也可以 Seek 到一个文件中已知的位置并从这个位置开始进行读取。</span></span><br><span class="line">    o2, err := f.Seek(<span class="number">6</span>, <span class="number">0</span>)</span><br><span class="line">    check(err)</span><br><span class="line">    b2 := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line">    n2, err := f.Read(b2)</span><br><span class="line">    check(err)</span><br><span class="line">    fmt.Printf(<span class="string">"%d bytes @ %d: %s\n"</span>, n2, o2, <span class="keyword">string</span>(b2))</span><br><span class="line">    <span class="comment">// io 包提供了一些可以帮助我们进行文件读取的函数。例如，上面的读取可以使用 ReadAtLeast 得到一个更健壮的实现。</span></span><br><span class="line">    o3, err := f.Seek(<span class="number">6</span>, <span class="number">0</span>)</span><br><span class="line">    check(err)</span><br><span class="line">    b3 := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line">    n3, err := io.ReadAtLeast(f, b3, <span class="number">2</span>)</span><br><span class="line">    check(err)</span><br><span class="line">    fmt.Printf(<span class="string">"%d bytes @ %d: %s\n"</span>, n3, o3, <span class="keyword">string</span>(b3))</span><br><span class="line">    <span class="comment">// 没有内置的回转支持，但是使用 Seek(0, 0) 实现。</span></span><br><span class="line">    _, err = f.Seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    check(err)</span><br><span class="line">    <span class="comment">// bufio 包实现了带缓冲的读取，这不仅对有很多小的读取操作的能提升性能，也提供了很多附加的读取函数。</span></span><br><span class="line">    r4 := bufio.NewReader(f)</span><br><span class="line">    b4, err := r4.Peek(<span class="number">5</span>)</span><br><span class="line">    check(err)</span><br><span class="line">    fmt.Printf(<span class="string">"5 bytes: %s\n"</span>, <span class="keyword">string</span>(b4))</span><br><span class="line">    <span class="comment">// 任务结束后要关闭这个文件（通常这个操作应该在 Open操作后立即使用 defer 来完成）。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 开始，这里是展示如写入一个字符串（或者只是一些字节）到一个文件。</span></span><br><span class="line">    d1 := []<span class="keyword">byte</span>(<span class="string">"hello\ngo\n"</span>)</span><br><span class="line">    err := ioutil.WriteFile(<span class="string">"/tmp/dat1"</span>, d1, <span class="number">0644</span>)</span><br><span class="line">    check(err)</span><br><span class="line">    <span class="comment">// 对于更细粒度的写入，先打开一个文件。</span></span><br><span class="line">    f, err := os.Create(<span class="string">"/tmp/dat2"</span>)</span><br><span class="line">    check(err)</span><br><span class="line">    <span class="comment">// 打开文件后，习惯立即使用 defer 调用文件的 Close操作。</span></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    <span class="comment">// 你可以写入你想写入的字节切片</span></span><br><span class="line">    d2 := []<span class="keyword">byte</span>&#123;<span class="number">115</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">10</span>&#125;</span><br><span class="line">    n2, err := f.Write(d2)</span><br><span class="line">    check(err)</span><br><span class="line">    fmt.Printf(<span class="string">"wrote %d bytes\n"</span>, n2)</span><br><span class="line">    <span class="comment">// WriteString 也是可用的。</span></span><br><span class="line">    n3, err := f.WriteString(<span class="string">"writes\n"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"wrote %d bytes\n"</span>, n3)</span><br><span class="line">    <span class="comment">// 调用 Sync 来将缓冲区的信息写入磁盘。</span></span><br><span class="line">    f.Sync()</span><br><span class="line">    <span class="comment">// bufio 提供了和我们前面看到的带缓冲的读取器一样的带缓冲的写入器。</span></span><br><span class="line">    w := bufio.NewWriter(f)</span><br><span class="line">    n4, err := w.WriteString(<span class="string">"buffered\n"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"wrote %d bytes\n"</span>, n4)</span><br><span class="line">    <span class="comment">// 使用 Flush 来确保所有缓存的操作已写入底层写入器。</span></span><br><span class="line">    w.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="行过滤器"><a href="#行过滤器" class="headerlink" title="行过滤器"></a>行过滤器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在读取标准输入流的输入，处理该输入，然后将得到一些的结果输出到标准输出的程序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 对 os.Stdin 使用一个带缓冲的 scanner，让我们可以直接使用方便的 Scan 方法来直接读取一行，每次调用该方法可以让 scanner 读取下一行。</span></span><br><span class="line">    scanner := bufio.NewScanner(os.Stdin)</span><br><span class="line">    <span class="comment">// Text 返回当前的 token，现在是输入的下一行。</span></span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        ucl := strings.ToUpper(scanner.Text())</span><br><span class="line">        <span class="comment">// 写出大写的行。</span></span><br><span class="line">        fmt.Println(ucl)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 Scan 的错误。文件结束符是可以接受的，并且不会被 Scan 当作一个错误。</span></span><br><span class="line">    <span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintln(os.Stderr, <span class="string">"error:"</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令行参数是指定程序运行参数的一个常见方式。例如，go run hello.go，程序 go 使用了 run 和 hello.go 两个参数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// os.Args 提供原始命令行参数访问功能。注意，切片中的第一个参数是该程序的路径，并且 os.Args[1:]保存所有程序的的参数。</span></span><br><span class="line">    argsWithProg := os.Args</span><br><span class="line">    argsWithoutProg := os.Args[<span class="number">1</span>:]</span><br><span class="line">    <span class="comment">// 你可以使用标准的索引位置方式取得单个参数的值。</span></span><br><span class="line">    arg := os.Args[<span class="number">3</span>]</span><br><span class="line">    fmt.Println(argsWithProg)    <span class="comment">// [./command-line-arguments a b c d]</span></span><br><span class="line">    fmt.Println(argsWithoutProg) <span class="comment">// [a b c d]</span></span><br><span class="line">    fmt.Println(arg)             <span class="comment">// c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要实验命令行参数，最好先使用 go build 编译一个可执行二进制文件</span></span><br><span class="line"><span class="comment">// $ go build command-line-arguments.go</span></span><br><span class="line"><span class="comment">// $ ./command-line-arguments a b c d</span></span><br></pre></td></tr></table></figure><h3 id="命令行标志-未懂"><a href="#命令行标志-未懂" class="headerlink" title="命令行标志(未懂)"></a>命令行标志(未懂)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 基本的标记声明仅支持字符串、整数和布尔值选项。这里我们声明一个默认值为 "foo" 的字符串标志 word并带有一个简短的描述。</span></span><br><span class="line">    <span class="comment">// 这里的 flag.String 函数返回一个字符串指针（不是一个字符串值），在下面我们会看到是如何使用这个指针的。</span></span><br><span class="line">    wordPtr := flag.String(<span class="string">"word"</span>, <span class="string">"foo"</span>, <span class="string">"a string"</span>)</span><br><span class="line">    <span class="comment">// 使用和声明 word 标志相同的方法来声明 numb 和 fork 标志。</span></span><br><span class="line">    numbPtr := flag.Int(<span class="string">"numb"</span>, <span class="number">42</span>, <span class="string">"an int"</span>)</span><br><span class="line">    boolPtr := flag.Bool(<span class="string">"fork"</span>, <span class="literal">false</span>, <span class="string">"a bool"</span>)</span><br><span class="line">    <span class="comment">// 用程序中已有的参数来声明一个标志也是可以的。注意在标志声明函数中需要使用该参数的指针。</span></span><br><span class="line">    <span class="keyword">var</span> svar <span class="keyword">string</span></span><br><span class="line">    flag.StringVar(&amp;svar, <span class="string">"svar"</span>, <span class="string">"bar"</span>, <span class="string">"a string var"</span>)</span><br><span class="line">    <span class="comment">// 所有标志都声明完成以后，调用 flag.Parse() 来执行命令行解析。</span></span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="comment">// 这里我们将仅输出解析的选项以及后面的位置参数。注意，我们需要使用类似 *wordPtr 这样的语法来对指针解引用，从而得到选项的实际值。</span></span><br><span class="line">    fmt.Println(<span class="string">"word:"</span>, *wordPtr)</span><br><span class="line">    fmt.Println(<span class="string">"numb:"</span>, *numbPtr)</span><br><span class="line">    fmt.Println(<span class="string">"fork:"</span>, *boolPtr)</span><br><span class="line">    fmt.Println(<span class="string">"svar:"</span>, svar)</span><br><span class="line">    fmt.Println(<span class="string">"tail:"</span>, flag.Args())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试这个程序前，最好将这个程序编译成二进制文件，然后再运行这个程序。</span></span><br><span class="line"><span class="comment">// $ go build command-line-flags.go</span></span><br><span class="line"><span class="comment">// word: opt</span></span><br><span class="line"><span class="comment">// numb: 7</span></span><br><span class="line"><span class="comment">// fork: true</span></span><br><span class="line"><span class="comment">// svar: flag</span></span><br><span class="line"><span class="comment">// tail: []</span></span><br><span class="line"><span class="comment">// 注意到，如果你省略一个标志，那么这个标志的值自动的设定为他的默认值。</span></span><br><span class="line"><span class="comment">// $ ./command-line-flags -word=opt</span></span><br><span class="line"><span class="comment">// word: opt</span></span><br><span class="line"><span class="comment">// numb: 42</span></span><br><span class="line"><span class="comment">// fork: false</span></span><br><span class="line"><span class="comment">// svar: bar</span></span><br><span class="line"><span class="comment">// tail: []</span></span><br><span class="line"><span class="comment">// 位置参数可以出现在任何标志后面。</span></span><br><span class="line"><span class="comment">// $ ./command-line-flags -word=opt a1 a2 a3</span></span><br><span class="line"><span class="comment">// word: opt</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// tail: [a1 a2 a3]</span></span><br><span class="line"><span class="comment">// 注意，flag 包需要所有的标志出现位置参数之前（否则，这个标志将会被解析为位置参数）。</span></span><br><span class="line"><span class="comment">// $ ./command-line-flags -word=opt a1 a2 a3 -numb=7</span></span><br><span class="line"><span class="comment">// word: opt</span></span><br><span class="line"><span class="comment">// numb: 42</span></span><br><span class="line"><span class="comment">// fork: false</span></span><br><span class="line"><span class="comment">// svar: bar</span></span><br><span class="line"><span class="comment">// trailing: [a1 a2 a3 -numb=7]</span></span><br><span class="line"><span class="comment">// 使用 -h 或者 --help 标志来得到自动生成的这个命令行程序的帮助文本。</span></span><br><span class="line"><span class="comment">// $ ./command-line-flags -h</span></span><br><span class="line"><span class="comment">// Usage of ./command-line-flags:</span></span><br><span class="line"><span class="comment">//   -fork=false: a bool</span></span><br><span class="line"><span class="comment">//   -numb=42: an int</span></span><br><span class="line"><span class="comment">//   -svar="bar": a string var</span></span><br><span class="line"><span class="comment">//   -word="foo": a string</span></span><br><span class="line"><span class="comment">// 如果你提供一个没有使用 flag 包指定的标志，程序会输出一个错误信息，并再次显示帮助文本。</span></span><br><span class="line"><span class="comment">// $ ./command-line-flags -wat</span></span><br><span class="line"><span class="comment">// flag provided but not defined: -wat</span></span><br><span class="line"><span class="comment">// Usage of ./command-line-flags:</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="环境变量-未懂"><a href="#环境变量-未懂" class="headerlink" title="环境变量(未懂)"></a>环境变量(未懂)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用 os.Setenv 来设置一个键值队。使用 os.Getenv获取一个键对应的值。如果键不存在，将会返回一个空字符串。</span></span><br><span class="line">    os.Setenv(<span class="string">"FOO"</span>, <span class="string">"1"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"FOO:"</span>, os.Getenv(<span class="string">"FOO"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"BAR:"</span>, os.Getenv(<span class="string">"BAR"</span>))</span><br><span class="line">    <span class="comment">// 使用 os.Environ 来列出所有环境变量键值队。这个函数会返回一个 KEY=value 形式的字符串切片。你可以使用strings.Split 来得到键和值。这里我们打印所有的键。</span></span><br><span class="line">    fmt.Println()</span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> os.Environ() &#123;</span><br><span class="line">        pair := strings.Split(e, <span class="string">"="</span>)</span><br><span class="line">        fmt.Println(pair[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行这个程序，显示我们在程序中设置的 FOO 的值，然而没有设置的 BAR 是空的。</span></span><br><span class="line"><span class="comment">// $ go run environment-variables.go</span></span><br><span class="line"><span class="comment">// FOO: 1</span></span><br><span class="line"><span class="comment">// BAR:</span></span><br><span class="line"><span class="comment">// 键的列表是由你的电脑情况而定的。</span></span><br><span class="line"><span class="comment">// TERM_PROGRAM</span></span><br><span class="line"><span class="comment">// PATH</span></span><br><span class="line"><span class="comment">// SHELL</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 如果我们在运行前设置了 BAR 的值，那么运行程序将会获取到这个值。</span></span><br><span class="line"><span class="comment">// $ BAR=2 go run environment-variables.go</span></span><br><span class="line"><span class="comment">// FOO: 1</span></span><br><span class="line"><span class="comment">// BAR: 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="执行外部进程"><a href="#执行外部进程" class="headerlink" title="执行外部进程"></a>执行外部进程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 我们将从一个简单的命令开始，没有参数或者输入，仅打印一些信息到标准输出流。exec.Command 函数帮助我们创建一个表示这个外部进程的对象。</span></span><br><span class="line">    dateCmd := exec.Command(<span class="string">"date"</span>)</span><br><span class="line">    <span class="comment">// .Output 是另一个帮助我们处理运行一个命令的常见情况的函数，它等待命令运行完成，并收集命令的输出。如果没有出错，dateOut 将获取到日期信息的字节。</span></span><br><span class="line">    dateOut, err := dateCmd.Output()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"&gt; date"</span>)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(dateOut))</span><br><span class="line">    <span class="comment">// 下面我们将看看一个稍复杂的例子，我们将从外部进程的stdin 输入数据并从 stdout 收集结果。</span></span><br><span class="line">    grepCmd := exec.Command(<span class="string">"grep"</span>, <span class="string">"hello"</span>)</span><br><span class="line">    <span class="comment">// 这里我们明确的获取输入/输出管道，运行这个进程，写入一些输入信息，读取输出的结果，最后等待程序运行结束。</span></span><br><span class="line">    grepIn, _ := grepCmd.StdinPipe()</span><br><span class="line">    grepOut, _ := grepCmd.StdoutPipe()</span><br><span class="line">    grepCmd.Start()</span><br><span class="line">    grepIn.Write([]<span class="keyword">byte</span>(<span class="string">"hello grep\ngoodbye grep"</span>))</span><br><span class="line">    grepIn.Close()</span><br><span class="line">    grepBytes, _ := ioutil.ReadAll(grepOut)</span><br><span class="line">    grepCmd.Wait()</span><br><span class="line">    <span class="comment">// 上面的例子中，我们忽略了错误检测，但是你可以使用if err != nil 的方式来进行错误检查，我们也只收集StdoutPipe 的结果，但是你可以使用相同的方法收集StderrPipe 的结果。</span></span><br><span class="line">    fmt.Println(<span class="string">"&gt; grep hello"</span>)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(grepBytes))</span><br><span class="line">    <span class="comment">// 注意，当我们需要提供一个明确的命令和参数数组来生成命令，和能够只需要提供一行命令行字符串相比，你想使用通过一个字符串生成一个完整的命令，那么你可以使用 bash命令的 -c 选项：</span></span><br><span class="line">    lsCmd := exec.Command(<span class="string">"bash"</span>, <span class="string">"-c"</span>, <span class="string">"ls -a -l -h"</span>)</span><br><span class="line">    lsOut, err := lsCmd.Output()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"&gt; ls -a -l -h"</span>)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(lsOut))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="替换执行进程"><a href="#替换执行进程" class="headerlink" title="替换执行进程"></a>替换执行进程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 有时候只想 用其他的（也许是非 Go 程序）来完全替代当前的 Go 进程</span></span><br><span class="line">    <span class="comment">// 在我们的例子中，我们将执行 ls 命令。Go 需要提供我 们需要执行的可执行文件的绝对路径，所以我们将使用 exec.LookPath 来得到它（大概是 /bin/ls）。</span></span><br><span class="line">    binary, lookErr := exec.LookPath(<span class="string">"ls"</span>)</span><br><span class="line">    <span class="keyword">if</span> lookErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(lookErr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Exec 需要的参数是切片的形式的（不是放在一起的一个大字 符串）。我们给 ls 一些基本的参数。注意，第一个参数需要 是程序名。</span></span><br><span class="line">    args := []<span class="keyword">string</span>&#123;<span class="string">"ls"</span>, <span class="string">"-a"</span>, <span class="string">"-l"</span>, <span class="string">"-h"</span>&#125;</span><br><span class="line">    <span class="comment">// Exec 同样需要使用环境变量。 这里我们仅提供当前的环境变量。</span></span><br><span class="line">    env := os.Environ()</span><br><span class="line">    <span class="comment">// 这里是 os.Exec 调用。如果这个调用成功，那么我们的 进程将在这里被替换成 /bin/ls -a -l -h 进程。如果存 在错误，那么我们将会得到一个返回值。</span></span><br><span class="line">    execErr := syscall.Exec(binary, args, env)</span><br><span class="line">    <span class="keyword">if</span> execErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(execErr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 运行程序时，它会替换为 ls</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Go 通过向一个通道发送 os.Signal 值来进行信号通知。我们 将创建一个通道来接收这些通知（同时还创建一个用于在程序可 以结束时进行通知的通道）。</span></span><br><span class="line">    sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// signal.Notify 注册这个给定的通道用于接收特定信号。</span></span><br><span class="line">    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">    <span class="comment">// 这个 Go 协程执行一个阻塞的信号接收操作。当它得到一个 值时，它将打印这个值，然后通知程序可以退出。</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sig := &lt;-sigs</span><br><span class="line">        fmt.Println()</span><br><span class="line">        fmt.Println(sig)</span><br><span class="line">        done &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 程序将在这里进行等待，直到它得到了期望的信号（也就 是上面的 Go 协程发送的 done 值）然后退出。</span></span><br><span class="line">    fmt.Println(<span class="string">"awaiting signal"</span>)</span><br><span class="line">    &lt;-done</span><br><span class="line">    fmt.Println(<span class="string">"exiting"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们运行这个程序时，它将一直等待一个信号。使用 ctrl-C （终端显示为 ^C），我们可以发送一个 SIGINT 信号，这会 使程序打印 interrupt 然后退出。</span></span><br><span class="line"><span class="comment">// $ go run signals.go</span></span><br><span class="line"><span class="comment">// awaiting signal</span></span><br><span class="line"><span class="comment">// ^C</span></span><br><span class="line"><span class="comment">// interrupt</span></span><br><span class="line"><span class="comment">// exiting</span></span><br></pre></td></tr></table></figure><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当使用 os.Exit 时 defer 将不会 执行，所以这里的 fmt.Println 将永远不会被调用。</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"!"</span>)</span><br><span class="line">    <span class="comment">// 退出并且退出状态为 3。</span></span><br><span class="line">    os.Exit(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;go&lt;/code&gt;的学习,感谢&lt;a href=&quot;https://gobyexample.xgwang.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go By Example&lt;/a&gt;、&lt;a href=&quot;https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;go 网络编程&lt;/a&gt;与&lt;a href=&quot;http://books.studygolang.com/The-Golang-Standard-Library-by-Example/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;go 语言标准库&lt;/a&gt;,随着学习的深入,此文章持续更新…&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://www.zhaohang.site/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="go" scheme="http://www.zhaohang.site/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>前端测试初探</title>
    <link href="http://www.zhaohang.site/2017/11/22/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E5%88%9D%E6%8E%A2/"/>
    <id>http://www.zhaohang.site/2017/11/22/前端测试初探/</id>
    <published>2017-11-22T15:10:12.000Z</published>
    <updated>2018-01-05T13:34:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直知道前端也是有测试的,但理解很肤浅,今天下定决心摸索一遍到底什么是前端自动化测试…</p><a id="more"></a><blockquote><p>本例子通过<code>vue-cli</code>生成的<code>unit</code>与<code>e2e</code>来探讨…</p></blockquote><h3 id="基础名词"><a href="#基础名词" class="headerlink" title="基础名词"></a>基础名词</h3><p>一些前端测试的名词解释:</p><ul><li><p><a href="http://karma-runner.github.io/0.13/index.html" target="_blank" rel="noopener">karma</a>是一个基于<code>Node.js</code>的<code>JavaScript</code>测试执行过程管理工具，其在测试中的作用相当于开发构建中使用的<code>webpack</code></p></li><li><p><a href="https://github.com/webpack/karma-webpack" target="_blank" rel="noopener">karma-webpack</a>连接<code>karma</code>和<code>webpack</code>的桥梁。不经过<code>webpack</code>编译命令是文件是无法独立运行的，<code>karma</code>需要了解你的<code>webpack</code>配置，决定如何处理你的测试文件。</p></li><li><p><a href="https://github.com/karma-runner/karma-phantomjs-launcher" target="_blank" rel="noopener">karma-phantomjs-launcher</a>是<code>phantomjs</code>在<code>karma</code>中的启动器，由此引出了<a href="https://github.com/ariya/phantomjs" target="_blank" rel="noopener">PhantomJS</a>,一个基于 webkit 内核的无头浏览器，即没有 UI 界面，即它就是一个浏览器，只是其内的点击、翻页等人为相关操作需要程序设计实现。在查找相关资料时，也发现了其他的常规浏览器<code>launcher</code>，比如：<code>Chrome、Firefox、Safari、IE</code> 等，以应对不同浏览器或多浏览器的测试需求。见<a href="http://karma-runner.github.io/0.13/config/browsers.html" target="_blank" rel="noopener">Browsers</a></p></li><li><p><a href="https://github.com/demerzel3/karma-sourcemap-loader" target="_blank" rel="noopener">karma-sourcemap-loader</a>一个<code>Karma</code>插件，生成文件的<code>sourcemap</code></p></li><li><p><a href="https://github.com/karma-runner/karma-mocha" target="_blank" rel="noopener">karma-mocha</a>让你在<code>karma</code>中使用<a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a>一款功能丰富的<code>javascript</code>单元测试框架，它既可以运行在<code>nodejs</code>环境中，也可以运行在浏览器环境中</p></li><li><p><a href="https://github.com/domenic/sinon-chai" target="_blank" rel="noopener">karma-sinon-chai</a>让你在<code>karma</code>中使用<code>sinon-chai</code>断言库的插件, 提供丰富的断言方法,前置依赖有<code>sinon-chai</code>、<code>sinon</code>、<code>chai</code>…</p></li><li><p><a href="https://github.com/mlex/karma-spec-reporter" target="_blank" rel="noopener">karma-spec-reporter</a>用于将测试结果显示到控制台。</p></li><li><p><a href="https://github.com/karma-runner/karma-coverage" target="_blank" rel="noopener">karma-coverage</a>用来生成代码覆盖率。</p></li><li><p><a href="http://seleniumhq.github.io/selenium/docs/api/javascript/index.html" target="_blank" rel="noopener">Nightwatch</a>是一套基于 Node.js 的测试框架，使用 Selenium WebDriver API 以将 Web 应用测试自动化。它提供了简单的语法，支持使用 JavaScript 和 CSS 选择器，来编写运行在 Selenium 服务器上的端到端测试。</p></li></ul><h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><p><code>unit</code>目录结构,主要测试单元是一个个函数、方法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">└── unit</span><br><span class="line">    ├── coverage  代码覆盖率报告，src下面的index.html可以直接用浏览器打开</span><br><span class="line">    │   ├── lcov-report</span><br><span class="line">    │   │   ├── base.css</span><br><span class="line">    │   │   ├── index.html</span><br><span class="line">    │   │   ├── prettify.css</span><br><span class="line">    │   │   ├── prettify.js</span><br><span class="line">    │   │   ├── sort-arrow-sprite.png</span><br><span class="line">    │   │   ├── sorter.js</span><br><span class="line">    │   │   └── src</span><br><span class="line">    │   │       ├── App<span class="selector-class">.vue</span><span class="selector-class">.html</span></span><br><span class="line">    │   │       ├── components</span><br><span class="line">    │   │       │   ├── Hello<span class="selector-class">.vue</span><span class="selector-class">.html</span></span><br><span class="line">    │   │       │   └── index.html</span><br><span class="line">    │   │       └── index.html</span><br><span class="line">    │   └── lcov.info</span><br><span class="line">    ├── index<span class="selector-class">.js</span> 运行测试用例前先加载的文件，方便统计代码覆盖率</span><br><span class="line">    ├── karma<span class="selector-class">.conf</span><span class="selector-class">.js</span> karma的配置文件</span><br><span class="line">    └── specs 所有的测试用例都放在这里</span><br><span class="line">        └── Hello<span class="selector-class">.spec</span><span class="selector-class">.js</span></span><br></pre></td></tr></table></figure><p><code>karma.conf.js</code>内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    config.set(&#123;</span><br><span class="line">        <span class="comment">// 要启动的测试浏览器</span></span><br><span class="line">        browsers: [ <span class="string">'Chrome'</span>],</span><br><span class="line">        <span class="comment">// 测试框架</span></span><br><span class="line">        frameworks: [<span class="string">'mocha'</span>, <span class="string">'sinon-chai'</span>],</span><br><span class="line">        <span class="comment">// 测试报告处理</span></span><br><span class="line">        reporters: [<span class="string">'spec'</span>, <span class="string">'coverage'</span>],</span><br><span class="line">        <span class="comment">// 要测试的目标文件</span></span><br><span class="line">        files: [<span class="string">'./index.js'</span>],</span><br><span class="line">        <span class="comment">// 忽略的文件</span></span><br><span class="line">        exclude: [],</span><br><span class="line">        <span class="comment">// 预处理文件</span></span><br><span class="line">        preprocessors: &#123;</span><br><span class="line">            <span class="string">'./index.js'</span>: [<span class="string">'webpack'</span>, <span class="string">'sourcemap'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// webpack</span></span><br><span class="line">        webpack: webpackConfig,</span><br><span class="line">        webpackMiddleware: &#123;</span><br><span class="line">            noInfo: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// Coverage options</span></span><br><span class="line">        coverageReporter: &#123;</span><br><span class="line">            dir: <span class="string">'./coverage'</span>,</span><br><span class="line">            reporters: [</span><br><span class="line">                &#123; <span class="attr">type</span>: <span class="string">'lcov'</span>, <span class="attr">subdir</span>: <span class="string">'.'</span> &#125;,</span><br><span class="line">                &#123; <span class="attr">type</span>: <span class="string">'text-summary'</span> &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// true: 自动运行测试并退出</span></span><br><span class="line">        <span class="comment">// false: 监控文件持续测试</span></span><br><span class="line">        singleRun: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 以下是 vue-cli 没有生成的一些配置</span></span><br><span class="line">        <span class="comment">// 文件匹配的起始路径</span></span><br><span class="line">        <span class="comment">// basePath: '',</span></span><br><span class="line">        <span class="comment">// 服务器端口</span></span><br><span class="line">        <span class="comment">// port: 9876,</span></span><br><span class="line">        <span class="comment">// 输出着色</span></span><br><span class="line">        <span class="comment">// colors: true,</span></span><br><span class="line">        <span class="comment">// 日志级别</span></span><br><span class="line">        <span class="comment">// LOG_DISABLE || LOG_ERROR || LOG_WARN || LOG_INFO || LOG_DEBUG</span></span><br><span class="line">        <span class="comment">// logLevel: config.LOG_INFO,</span></span><br><span class="line">        <span class="comment">// 监控文件更改</span></span><br><span class="line">        <span class="comment">// autoWatch: true,</span></span><br><span class="line">        <span class="comment">// 超时处理，6s内没有捕获浏览器将终止进程</span></span><br><span class="line">        <span class="comment">// captureTimeout: 6000</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>index.js</code>入口文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载所有的测试用例、 testsContext.keys().forEach(testsContext)这种写法是webpack中的加载目录下所有文件的写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配的是specs目录，里面是存放的是测试用例</span></span><br><span class="line"><span class="keyword">const</span> testsContext = <span class="keyword">require</span>.context(<span class="string">'./specs'</span>, <span class="keyword">true</span>, /\.spec$/)</span><br><span class="line">testsContext.keys().<span class="keyword">forEach</span>(testsContext)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载所有代码文件，方便统计代码覆盖率</span></span><br><span class="line"><span class="comment">// 匹配的是src目录，除了main.js以外的所有文件。</span></span><br><span class="line"><span class="keyword">const</span> srcContext = <span class="keyword">require</span>.context(<span class="string">'../../src'</span>, <span class="keyword">true</span>, /^\.\/(?!main(\.js)?$)/)</span><br><span class="line">srcContext.keys().<span class="keyword">forEach</span>(srcContext)</span><br></pre></td></tr></table></figure><p><code>e2e</code>目录结构,测试的单元是一个个预期的行为表现,打开游览器,模拟测试</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── <span class="selector-tag">e2e</span></span><br><span class="line">│   ├── <span class="selector-tag">custom-assertions</span></span><br><span class="line">│   │   └── <span class="selector-tag">elementCount</span><span class="selector-class">.js</span> 自定义的断言方法</span><br><span class="line">│   ├── <span class="selector-tag">nightwatch</span><span class="selector-class">.conf</span><span class="selector-class">.js</span> <span class="selector-tag">nightwatch</span>的配置文件</span><br><span class="line">│   ├── <span class="selector-tag">reports</span></span><br><span class="line">│   │   ├── <span class="selector-tag">CHROME_60</span><span class="selector-class">.0</span><span class="selector-class">.3112</span><span class="selector-class">.101_Mac</span>\ <span class="selector-tag">OS</span>\ <span class="selector-tag">X_test</span><span class="selector-class">.xml</span></span><br><span class="line">│   │   └── <span class="selector-tag">CHROME_60</span><span class="selector-class">.0</span><span class="selector-class">.3112</span><span class="selector-class">.113_Mac</span>\ <span class="selector-tag">OS</span>\ <span class="selector-tag">X_test</span><span class="selector-class">.xml</span></span><br><span class="line">│   ├── <span class="selector-tag">runner</span><span class="selector-class">.js</span>  <span class="selector-tag">bootstrap</span>文件，起我们的页面<span class="selector-tag">server</span>和<span class="selector-tag">nightwatch</span>文件</span><br><span class="line">│   └── <span class="selector-tag">specs</span></span><br><span class="line">│       └── <span class="selector-tag">test</span><span class="selector-class">.js</span> 测试用例</span><br></pre></td></tr></table></figure><p><code>nightwatch.conf.js</code>内容</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">src_folders</span>: [<span class="string">'test/e2e/specs'</span>],</span><br><span class="line"><span class="attribute">output_folder</span>: <span class="string">'test/e2e/reports'</span>,</span><br><span class="line"><span class="attribute">custom_assertions_path</span>: [<span class="string">'test/e2e/custom-assertions'</span>],</span><br><span class="line">  <span class="comment">// 对selenium的配置</span></span><br><span class="line"><span class="attribute">selenium</span>: &#123;</span><br><span class="line">  <span class="attribute">start_process</span>: true,</span><br><span class="line">  <span class="attribute">server_path</span>: require(<span class="string">'selenium-server'</span>).path,</span><br><span class="line">  <span class="attribute">host</span>: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">  <span class="attribute">port</span>: <span class="number">4444</span>,</span><br><span class="line">  <span class="attribute">cli_args</span>: &#123;</span><br><span class="line">    <span class="string">'webdriver.chrome.driver'</span>: require(<span class="string">'chromedriver'</span>).path</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">  <span class="comment">// 测试环境的配置</span></span><br><span class="line"><span class="attribute">test_settings</span>: &#123;</span><br><span class="line">  <span class="attribute">default</span>: &#123;</span><br><span class="line">    <span class="attribute">selenium_port</span>: <span class="number">4444</span>,</span><br><span class="line">    <span class="attribute">selenium_host</span>: <span class="string">'localhost'</span>,</span><br><span class="line">    <span class="attribute">silent</span>: true,</span><br><span class="line">    <span class="attribute">globals</span>: &#123;</span><br><span class="line">      <span class="attribute">devServerURL</span>: <span class="string">'http://localhost:'</span> + (process.env.PORT || config.dev.port)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attribute">chrome</span>: &#123;</span><br><span class="line">    <span class="attribute">desiredCapabilities</span>: &#123;</span><br><span class="line">      <span class="attribute">browserName</span>: <span class="string">'chrome'</span>,</span><br><span class="line">      <span class="attribute">javascriptEnabled</span>: true,</span><br><span class="line">      <span class="attribute">acceptSslCerts</span>: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attribute">firefox</span>: &#123;</span><br><span class="line">    <span class="attribute">desiredCapabilities</span>: &#123;</span><br><span class="line">      <span class="attribute">browserName</span>: <span class="string">'firefox'</span>,</span><br><span class="line">      <span class="attribute">javascriptEnabled</span>: true,</span><br><span class="line">      <span class="attribute">acceptSslCerts</span>: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runner.js</code>入口文件内容,先起一个我们的网页服务然后再起 nightWatch 服务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'../../build/dev-server.js'</span>)</span><br><span class="line"></span><br><span class="line">server.ready.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 2. run the nightwatch test suite against it</span></span><br><span class="line">  <span class="comment">// to run in additional browsers:</span></span><br><span class="line">  <span class="comment">//    1. add an entry in test/e2e/nightwatch.conf.json under "test_settings"</span></span><br><span class="line">  <span class="comment">//    2. add it to the --env flag below</span></span><br><span class="line">  <span class="comment">// or override the environment flag, for example: `npm run e2e -- --env chrome,firefox`</span></span><br><span class="line">  <span class="comment">// For more information on Nightwatch's config file, see</span></span><br><span class="line">  <span class="comment">// http://nightwatchjs.org/guide#settings-file</span></span><br><span class="line">  <span class="keyword">var</span> opts = process.argv.slice(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(opts);</span><br><span class="line">  <span class="keyword">if</span> (opts.indexOf(<span class="string">'--config'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">    opts = opts.concat([<span class="string">'--config'</span>, <span class="string">'test/e2e/nightwatch.conf.js'</span>])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.indexOf(<span class="string">'--env'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">    opts = opts.concat([<span class="string">'--env'</span>, <span class="string">'chrome,firefox'</span>])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> spawn = <span class="built_in">require</span>(<span class="string">'cross-spawn'</span>)</span><br><span class="line">  <span class="keyword">var</span> runner = spawn(<span class="string">'./node_modules/.bin/nightwatch'</span>, opts, &#123; <span class="attr">stdio</span>: <span class="string">'inherit'</span> &#125;)</span><br><span class="line"></span><br><span class="line">  runner.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">    server.close()</span><br><span class="line">    process.exit(code)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  runner.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    server.close()</span><br><span class="line">    <span class="keyword">throw</span> err</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="工具详解"><a href="#工具详解" class="headerlink" title="工具详解"></a>工具详解</h3><h4 id="chai"><a href="#chai" class="headerlink" title="chai"></a>chai</h4><p>定义几个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const math = &#123;</span><br><span class="line">    add: (...args) =&gt; args.reduce((num, value) =&gt; num + value),</span><br><span class="line">    mul: (...args) =&gt; args.reduce((num, value) =&gt; num * value),</span><br><span class="line">    cover: (a, b) =&gt; &#123;</span><br><span class="line">        if (a &gt; b) &#123;</span><br><span class="line">            return a - b</span><br><span class="line">        &#125; else if (a == b) &#123;</span><br><span class="line">            return a + b</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return -1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>node</code>自带的断言测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const assert = require(&apos;assert&apos;)</span><br><span class="line">const &#123;add, mul&#125; = require(&apos;./math&apos;)</span><br><span class="line">assert.equal(add(2, 3), 5)</span><br></pre></td></tr></table></figure><p>引入<code>chai</code>库测试,3 个方法作用一样,断言分格不同而已</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const chai = require(&apos;chai&apos;)</span><br><span class="line">// should</span><br><span class="line">chai.should()</span><br><span class="line">add(2, 3).should.equal(5)</span><br><span class="line">// expect</span><br><span class="line">consr expect = chai.expect</span><br><span class="line">expect(add(2, 3).to.be(5)</span><br><span class="line">// assert</span><br><span class="line">consr assert = chai.assert</span><br><span class="line">assert.equal(add(2, 3), 5)</span><br></pre></td></tr></table></figure><p><code>expect</code>断言的优点是很接近自然语言，下面是一些例子</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相等或不相等</span></span><br><span class="line"><span class="selector-tag">expect</span>(<span class="number">4</span> + <span class="number">5</span>)<span class="selector-class">.to</span><span class="selector-class">.be</span><span class="selector-class">.equal</span>(<span class="number">9</span>);</span><br><span class="line"><span class="selector-tag">expect</span>(<span class="number">4</span> + <span class="number">5</span>)<span class="selector-class">.to</span><span class="selector-class">.be</span><span class="selector-class">.not</span><span class="selector-class">.equal</span>(<span class="number">10</span>);</span><br><span class="line"><span class="selector-tag">expect</span>(foo)<span class="selector-class">.to</span><span class="selector-class">.be</span><span class="selector-class">.deep</span><span class="selector-class">.equal</span>(&#123; <span class="attribute">bar</span>: <span class="string">'baz'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值为true</span></span><br><span class="line"><span class="selector-tag">expect</span>(<span class="string">'everthing'</span>)<span class="selector-class">.to</span><span class="selector-class">.be</span><span class="selector-class">.ok</span>;</span><br><span class="line"><span class="selector-tag">expect</span>(false)<span class="selector-class">.to</span><span class="selector-class">.not</span><span class="selector-class">.be</span><span class="selector-class">.ok</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typeof</span></span><br><span class="line"><span class="selector-tag">expect</span>(<span class="string">'test'</span>)<span class="selector-class">.to</span><span class="selector-class">.be</span><span class="selector-class">.a</span>(<span class="string">'string'</span>);</span><br><span class="line"><span class="selector-tag">expect</span>(&#123; <span class="attribute">foo</span>: <span class="string">'bar'</span> &#125;)<span class="selector-class">.to</span><span class="selector-class">.be</span><span class="selector-class">.an</span>(<span class="string">'object'</span>);</span><br><span class="line"><span class="selector-tag">expect</span>(foo)<span class="selector-class">.to</span><span class="selector-class">.be</span><span class="selector-class">.an</span><span class="selector-class">.instanceof</span>(Foo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// include</span></span><br><span class="line"><span class="selector-tag">expect</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])<span class="selector-class">.to</span><span class="selector-class">.include</span>(<span class="number">2</span>);</span><br><span class="line"><span class="selector-tag">expect</span>(<span class="string">'foobar'</span>)<span class="selector-class">.to</span><span class="selector-class">.contain</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="selector-tag">expect</span>(&#123; <span class="attribute">foo</span>: <span class="string">'bar'</span>, <span class="attribute">hello</span>: <span class="string">'universe'</span> &#125;)<span class="selector-class">.to</span><span class="selector-class">.include</span><span class="selector-class">.keys</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// empty</span></span><br><span class="line"><span class="selector-tag">expect</span>([])<span class="selector-class">.to</span><span class="selector-class">.be</span><span class="selector-class">.empty</span>;</span><br><span class="line"><span class="selector-tag">expect</span>(<span class="string">''</span>)<span class="selector-class">.to</span><span class="selector-class">.be</span><span class="selector-class">.empty</span>;</span><br><span class="line"><span class="selector-tag">expect</span>(&#123;&#125;)<span class="selector-class">.to</span><span class="selector-class">.be</span><span class="selector-class">.empty</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// match</span></span><br><span class="line"><span class="selector-tag">expect</span>(<span class="string">'foobar'</span>)<span class="selector-class">.to</span><span class="selector-class">.match</span>(/^foo/);</span><br></pre></td></tr></table></figure><p>基本上，<code>expect</code>断言的写法都是一样的。头部是<code>expect</code>方法，尾部是断言方法，比如<code>equal、a/an、ok、match</code>等。两者之间使用 to 或 to.be 连接</p><p>如果<code>expect</code>断言不成立，就会抛出一个错误。只要不抛出错误，测试用例就算通过</p><h3 id="Mocha"><a href="#Mocha" class="headerlink" title="Mocha"></a>Mocha</h3><p><code>Mocha</code>的作用是运行测试脚本，首先必须学会写测试脚本。所谓”测试脚本”，就是用来测试源码的脚本<br><code>Mocha</code>默认运行<code>test</code>子目录里面的测试脚本 添加<code>--recursive</code>参数可以运行<code>test</code>目录下所有层数用例基本用法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'#math'</span>, () =&gt; &#123;</span><br><span class="line">    describe(<span class="string">'add'</span>, () =&gt; &#123;</span><br><span class="line">        it(<span class="string">'should return 5 when 2 + 3'</span>, () =&gt; &#123;</span><br><span class="line">            assert(add(<span class="number">2</span>, <span class="number">3</span>), <span class="number">5</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    describe(<span class="string">'mul'</span>, () =&gt; &#123;</span><br><span class="line">        it(<span class="string">'should return 6 when 2 * 3'</span>, () =&gt; &#123;</span><br><span class="line">            assert(mul(<span class="number">2</span>, <span class="number">3</span>), <span class="number">6</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 只执行此条</span></span><br><span class="line">       it.only(<span class="string">'should return 6 when 2 * 3'</span>, () =&gt; &#123;</span><br><span class="line">            assert(mul(<span class="number">2</span>, <span class="number">3</span>), <span class="number">6</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">       <span class="comment">// 忽略此条</span></span><br><span class="line">       it.skip(<span class="string">'should return 6 when 2 * 3'</span>, () =&gt; &#123;</span><br><span class="line">            assert(mul(<span class="number">2</span>, <span class="number">3</span>), <span class="number">6</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    describe(<span class="string">'mul'</span>, () =&gt; &#123;</span><br><span class="line">        it(<span class="string">'should return -1 when 2 &lt; 3'</span>, () =&gt; &#123;</span><br><span class="line">            assert(cover(<span class="number">2</span>, <span class="number">3</span>), <span class="number">-1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        it(<span class="string">'should return 1 when 3 &gt; 2'</span>, () =&gt; &#123;</span><br><span class="line">            assert(cover(<span class="number">3</span>, <span class="number">2</span>), <span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        it(<span class="string">'should return 4 when 2 = 2'</span>, () =&gt; &#123;</span><br><span class="line">            assert(cover(<span class="number">2</span>, <span class="number">2</span>), <span class="number">4</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>异步例子:<br><code>it</code>块执行的时候，传入一个<code>done</code>参数，当测试结束的时候，必须显式调用这个函数，告诉<code>Mocha</code>测试结束了需要用<code>-t</code>或<code>--timeout</code>参数，改变默认的<code>(2000)</code>超时设置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $ mocha -t 5000 timeout.test.js</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">'测试应该5000毫秒后结束'</span>, done =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    x = <span class="literal">false</span>;</span><br><span class="line">    expect(x).to.be.not.ok;</span><br><span class="line">    done(); <span class="comment">// 通知Mocha测试结束</span></span><br><span class="line">  &#125;;</span><br><span class="line">  setTimeout(f, <span class="number">4000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>测试用例的钩子:<br><code>Mocha</code>在<code>describe</code>块之中，提供测试用例的四个钩子：<code>before()、after()、beforeEach()和afterEach()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'hooks'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在本区块的所有测试用例之前执行</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在本区块的所有测试用例之后执行</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在本区块的每个测试用例之前执行</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  afterEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在本区块的每个测试用例之后执行</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// test cases</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h4><p><code>benchmark</code>是一个测试函数性能的库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var suite = new Benchmark.Suite;</span><br><span class="line">// add tests</span><br><span class="line">suite.add(&apos;RegExp#test&apos;, function() &#123;</span><br><span class="line">  /o/.test(&apos;Hello World!&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">.add(&apos;String#indexOf&apos;, function() &#123;</span><br><span class="line">  &apos;Hello World!&apos;.indexOf(&apos;o&apos;) &gt; -1;</span><br><span class="line">&#125;)</span><br><span class="line">.add(&apos;String#match&apos;, function() &#123;</span><br><span class="line">  !!&apos;Hello World!&apos;.match(/o/);</span><br><span class="line">&#125;)</span><br><span class="line">// add listeners</span><br><span class="line">.on(&apos;cycle&apos;, function(event) &#123;</span><br><span class="line">  console.log(String(event.target));</span><br><span class="line">&#125;)</span><br><span class="line">.on(&apos;complete&apos;, function() &#123;</span><br><span class="line">  console.log(&apos;Fastest is &apos; + this.filter(&apos;fastest&apos;).map(&apos;name&apos;));</span><br><span class="line">&#125;)</span><br><span class="line">// run async</span><br><span class="line">.run(&#123; &apos;async&apos;: true &#125;);</span><br></pre></td></tr></table></figure><h4 id="Puppeteer"><a href="#Puppeteer" class="headerlink" title="Puppeteer"></a>Puppeteer</h4><p><a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener">Puppeteer</a>是类似于<code>Nightwatch</code>的一个<code>Chrome</code>专用版,有更友好的 api,是用来测试游览器环境的一个工具也可用于爬虫,比如这个<a href="https://github.com/blossom91/demoNode/blob/master/reptile/puppeteer.js" target="_blank" rel="noopener">demo</a>演示了爬取百度图片,相较于<code>cheerio</code>,它的爬虫更模拟真实环境,不易反爬虫</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://example.com'</span>);</span><br><span class="line">  <span class="keyword">await</span> page.screenshot(&#123;path: <span class="string">'example.png'</span>&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h3><p>哦,是不是这一大堆东西看晕了,用个<code>karma</code>还要集成一大堆各种插件配置,这一点上真是跟<code>webpack</code>一样了就像有人受不了<code>webpack</code>这一大堆配置所以有了前端构建集成工具<a href="http://www.parceljs.io/" target="_blank" rel="noopener">Parcel</a><br>而<a href="http://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>就是这样一个前端测试集成工具<br><a href="http://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a>的官方文档支持中文,这里就不详细说明了,有兴趣可以去官网查看相比于<code>karma</code>最大特点就是快和方便,缺点就是没有<code>karma</code>测试环境真实和自由具体抉择,仁者见仁智者见智啦~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直知道前端也是有测试的,但理解很肤浅,今天下定决心摸索一遍到底什么是前端自动化测试…&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.zhaohang.site/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="karma" scheme="http://www.zhaohang.site/tags/karma/"/>
    
  </entry>
  
  <entry>
    <title>mysql学习</title>
    <link href="http://www.zhaohang.site/2017/11/12/mysql%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.zhaohang.site/2017/11/12/mysql学习/</id>
    <published>2017-11-12T12:40:12.000Z</published>
    <updated>2018-01-05T13:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>mysql</code> 的学习,感谢<a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>与<a href="https://ninghao.net/package/mysql" target="_blank" rel="noopener">宁皓网</a>提供的优秀资料随着学习的深入,此文章持续更新…</p><a id="more"></a><p><br><br>MySQL 是一个关系型数据库管理系统,下面是一些术语解释:</p><ul><li>数据库: 数据库是一些关联表的集合。.</li><li>数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li><li>列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</li><li>行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li><li>冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</li><li>主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li><li>外键：外键用于关联两个表。</li><li>复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li><li>索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li><li>参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</li></ul><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>mysql.server start</code></td><td style="text-align:center">开启</td></tr><tr><td style="text-align:center"><code>mysql.server stop</code></td><td style="text-align:center">关闭</td></tr><tr><td style="text-align:center"><code>mysql.server restart</code></td><td style="text-align:center">重启</td></tr><tr><td style="text-align:center"><code>mysql.server reload</code></td><td style="text-align:center">重加载</td></tr><tr><td style="text-align:center"><code>mysql.server force-reload</code></td><td style="text-align:center">强制重载</td></tr><tr><td style="text-align:center"><code>mysql.server status</code></td><td style="text-align:center">状态</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 命令行导入数据库</span><br><span class="line">$ mysql -u root -p 数据库 &lt; 数据库文件.sql;</span><br></pre></td></tr></table></figure><hr><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 用户登录 默认本地  显示警告信息</span><br><span class="line">$ mysql [-h hostname] -u uesr [-p ] [--show-warnings]</span><br><span class="line"></span><br><span class="line"># 创建新用户  localhost: 本地</span><br><span class="line">$ CREATE USER <span class="string">'name'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'password'</span>;</span><br><span class="line"></span><br><span class="line"># 权限: ALL PRIVILEGES 表示所有  数据库.数据表: .表示所有   数据库.* 表示某个库的所有表 主机名:localhost</span><br><span class="line">$ GRANT 权限 ON 数据库.数据表 TO <span class="string">'用户'</span>@<span class="string">'主机名'</span> [IDENTIFIED BY <span class="string">'密码'</span>];</span><br><span class="line"></span><br><span class="line"># 修改立即生效</span><br><span class="line">$ flush privileges;</span><br><span class="line"></span><br><span class="line"># 查看数据库系统里面的所有的用户</span><br><span class="line">$ <span class="keyword">select</span> user from mysql.user;</span><br><span class="line"></span><br><span class="line"># 查看表里的所有的字段</span><br><span class="line">$ desc mysql.user;</span><br><span class="line"></span><br><span class="line"># 查看 mysql 全局系统里面的用户的select_priv权限</span><br><span class="line">$ <span class="keyword">select</span> user, select_priv from mysql.user;</span><br><span class="line"></span><br><span class="line"># 查看特定的数据库上的权限</span><br><span class="line">$ <span class="keyword">select</span> user, db, select_priv from mysql.db;</span><br><span class="line"></span><br><span class="line"># 查看一下用户拥有的权限</span><br><span class="line">$ show grants <span class="keyword">for</span> blssom@localhost</span><br><span class="line"></span><br><span class="line"># 删除更新 删除权限 在某个数据库的所有表上</span><br><span class="line">$ revoke update, <span class="built_in">delete</span> on 数据库.* from blssom@localhost</span><br><span class="line"></span><br><span class="line"># 为用户设置密码<span class="string">"hello"</span></span><br><span class="line">$ set password <span class="keyword">for</span> blssom@localhost = password(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line"># 删除用户</span><br><span class="line">$ drop user blssom@localhost</span><br></pre></td></tr></table></figure><hr><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>varchar(255)</code></td><td style="text-align:center">最大 255 字节的 string</td></tr><tr><td style="text-align:center"><code>date</code></td><td style="text-align:center">时间</td></tr><tr><td style="text-align:center"><code>TEXT</code></td><td style="text-align:center">长文本</td></tr><tr><td style="text-align:center"><code>INT(10)</code></td><td style="text-align:center">最大 10 位数字</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 创建数据库 (如果不存在再创建)</span><br><span class="line">$ CREATE DATABASE [IF NOT EXISTS] blssomHome [charset=utf8]</span><br><span class="line"></span><br><span class="line"># 显示所有数据库</span><br><span class="line">$ show databases;</span><br><span class="line"></span><br><span class="line"># 切换 数据库</span><br><span class="line">$ USE blssomHome;</span><br><span class="line"></span><br><span class="line"># 删除 数据库</span><br><span class="line">$ DROP DATABASE blssomHome;</span><br><span class="line"></span><br><span class="line"># 显示数据库的所有表</span><br><span class="line">$ SHOW TABLES;</span><br><span class="line"></span><br><span class="line"># 创建数据表 film定义<span class="number">3</span>个字段unsigned:不能为负</span><br><span class="line">$ CREATE TABLE film(</span><br><span class="line">id INT(<span class="number">10</span>) unsigned not null auto_increment,</span><br><span class="line">name varchar(<span class="number">255</span>)  DEFAULT <span class="number">0</span> COMMENT <span class="string">'这里是注释'</span>,</span><br><span class="line">date date,</span><br><span class="line">PRIMARY KEY(id)</span><br><span class="line">) <span class="keyword">default</span> charset=utf8</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"># 查看数据表详细信息</span><br><span class="line">$ DESCRIBE film;</span><br><span class="line"></span><br><span class="line"># ALTER TABLE 语句 添加字段在开头(默认末尾)</span><br><span class="line">$ ALTER TABLE film ADD fid INT(<span class="number">10</span>) FIRST;</span><br><span class="line"></span><br><span class="line"># ALTER TABLE 语句 添加字段在name之后</span><br><span class="line">$ ALTER TABLE film ADD fid INT(<span class="number">10</span>) AFTER name;</span><br><span class="line"></span><br><span class="line"># PRIMARY KEY 添加主键</span><br><span class="line">$ ALTER TABLE film ADD PRIMARY KEY (fid);</span><br><span class="line"></span><br><span class="line"># 改变数据栏名字</span><br><span class="line">$ ALTER TABLE film CHANGE fid film_id INT(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"># 重命名数据表</span><br><span class="line">$ ALTER TABLE film RENAME TO movie;</span><br><span class="line"></span><br><span class="line"># 删除数据栏</span><br><span class="line">$ ALTER TABLE movie DROP film_content;</span><br><span class="line"></span><br><span class="line"># 删除数据表</span><br><span class="line">$ DROP TABLE movie;</span><br></pre></td></tr></table></figure><hr><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 添加数据 按顺序添加 按栏添加</span><br><span class="line">$ INSERT INTO 数据表 (栏<span class="number">1</span>, 栏<span class="number">2</span>, 栏<span class="number">3</span>) VALUES (值<span class="number">1</span>, 值<span class="number">2</span>, 值<span class="number">3</span>);</span><br><span class="line">$ INSERT INTO people VALUES (NULL, <span class="string">'华盛顿'</span>, <span class="string">'1954-12-28'</span>, <span class="string">'美国'</span>);</span><br><span class="line">$ INSERT INTO people (name, location) VALUES (<span class="string">'安吉莉娜'</span>, <span class="string">'美国'</span>);</span><br><span class="line"></span><br><span class="line"># 删除数据</span><br><span class="line">$ DELETE FROM 表名称 WHERE 字段 = 值;</span><br><span class="line">$ DELETE FROM people WHERE pid = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"># 更新数据</span><br><span class="line">$ UPDATE 表名称 SET 字段 = <span class="string">'值'</span> WHERE 字段 = 值;</span><br><span class="line">$ UPDATE people SET birth = <span class="string">'1975-06-04'</span> WHERE pid = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"># 查询数据  分栏查询 (*)所有</span><br><span class="line">$ SELECT 栏<span class="number">1</span>,栏<span class="number">2</span>,栏<span class="number">3.</span>.. FROM 数据表;</span><br><span class="line">$ SELECT * FROM people;  </span><br><span class="line"></span><br><span class="line"># where 限制条件</span><br><span class="line">$ SELECT * FROM people WHERE location = <span class="string">'美国'</span>;</span><br><span class="line"></span><br><span class="line"># ORDER BY 排序 默认ASC升序(DESC降序)</span><br><span class="line">$ SELECT * FROM people ORDER BY people_birth DESC;</span><br><span class="line"></span><br><span class="line"># LIMIT 限制查询数量  OFFSET 查询开始的偏移量</span><br><span class="line">$ SELECT * FROM people WHERE location = <span class="string">'美国'</span> LIMIT <span class="number">3</span>;</span><br><span class="line">$ SELECT * FROM people LIMIT <span class="number">3</span> OFFSET <span class="number">1</span>;</span><br><span class="line">$ SELECT * FROM people LIMIT <span class="number">1</span>, <span class="number">3</span>;(等价于上一条)</span><br><span class="line"></span><br><span class="line"># 比较(大于，小于，大于等于，小于等于，或者不等于)</span><br><span class="line">$ SELECT * FROM people WHERE birth &gt; <span class="string">'1960-01-01'</span>;</span><br><span class="line"></span><br><span class="line"># 逻辑(AND:并且 OR:或者)</span><br><span class="line">$ SELECT * FROM people WHERE birth &gt; <span class="string">'1960-01-01'</span> AND birth &lt; <span class="string">'1970-01-01'</span>;</span><br><span class="line">$ SELECT * FROM people WHERE birth &gt; <span class="string">'1970-01-01'</span> OR birth &lt; <span class="string">'1960-01-01'</span>;</span><br><span class="line"></span><br><span class="line"># IN:一个值在一个集合里面  NOT IN:不在</span><br><span class="line">$ SELECT * FROM people WHERE location IN (<span class="string">'美国'</span>, <span class="string">'英国'</span>);</span><br><span class="line">$ SELECT * FROM people WHERE location NOT IN (<span class="string">'美国'</span>, <span class="string">'英国'</span>);</span><br><span class="line"></span><br><span class="line"># LIKE(% 表示一个或者多个字符，_ 表示一个字符)</span><br><span class="line">$ SELECT * FROM people WHERE name LIKE (<span class="string">'李%'</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 栏的名称有冲突的话，写成 数据表.数据栏</span><br><span class="line"># SELECT 栏<span class="number">1</span>,栏<span class="number">2</span> FROM 数据表<span class="number">1</span>, 数据表<span class="number">2</span> WHERE 组织条件</span><br><span class="line">$ SELECT user_name, review_content FROM user, review WHERE review.user_id = user.user_id;</span><br><span class="line"></span><br><span class="line"># 表与表之间, 表示CROSS JOIN:交叉关联  INNER JOIN:内部关联</span><br><span class="line">$ SELECT user_name, review_content FROM user INNER JOIN review ON review.user_id = user.user_id;</span><br><span class="line"></span><br><span class="line"># INNER JOIN(交集) 后继续设置条件</span><br><span class="line">$ SELECT user_name, review_content FROM user INNER JOIN review ON review.user_id = user.user_id WHERE user.user_id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># LEFT JOIN:左关联 RIGHT JOIN:右关联</span><br><span class="line"># 以哪个为主显示所有内容 次表有就关联显示 没有就null</span><br><span class="line">$ SELECT user_name, review_content FROM user LEFT JOIN review ON review.user_id = user.user_id;</span><br><span class="line"></span><br><span class="line"># COUNT()函数统计此栏的 数量</span><br><span class="line">$ SELECT COUNT(review_id) FROM review;</span><br><span class="line"></span><br><span class="line"># GROUP BY: 通过某个栏分组</span><br><span class="line">$ SELECT film_id, COUNT((review_id) FROM review GROUP BY film_id;</span><br><span class="line"></span><br><span class="line"># AVG()函数计算平均分</span><br><span class="line">$ SELECT film_id, AVG(review_rate) FROM review GROUP BY film_id;</span><br><span class="line"></span><br><span class="line"># SUM()函数求和</span><br></pre></td></tr></table></figure><hr><h3 id="一些查询例子"><a href="#一些查询例子" class="headerlink" title="一些查询例子"></a>一些查询例子</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查询电影平均分</span><br><span class="line">$ SELECT review.film_id, film.film_name, AVG(review_rate) FROM review, film WHERE review.film_id = film.film_id GROUP BY review.film_id;</span><br><span class="line"></span><br><span class="line"># 查询电影名与参与电影人和工作</span><br><span class="line">$ SELECT film_name, people_name, job FROM film, people, film_people WHERE film_people.film_id = film.film_id AND film_people.people_id = people.people_id;</span><br><span class="line"></span><br><span class="line"># 查询电影名为x的参与电影人和工作 on duplicate key 当被约束时更新xxxxx</span><br><span class="line">$ SELECT film_name, people_name, job FROM film, people, film_people WHERE film_people.film_id = film.film_id AND film_people.people_id = people.people_id AND film_name = <span class="string">'x'</span> on duplicate key update xxxxxx;</span><br><span class="line"></span><br><span class="line"># 查询电影票房按导演名分组 按票房降序排序</span><br><span class="line"># AS 可以给数据栏和数据表起别名</span><br><span class="line">$ SELECT SUM(film_box) AS total_box, people_name FROM film, people, crew WHERE crew.film_id = film.film_id AND crew.people_id = people.people_id AND crew_job = <span class="string">'导演'</span> GROUP BY people_name ORDER BY total_box DESC;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;mysql&lt;/code&gt; 的学习,感谢&lt;a href=&quot;http://www.runoob.com/mysql/mysql-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程&lt;/a&gt;与&lt;a href=&quot;https://ninghao.net/package/mysql&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;宁皓网&lt;/a&gt;提供的优秀资料随着学习的深入,此文章持续更新…&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://www.zhaohang.site/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://www.zhaohang.site/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>node.js学习</title>
    <link href="http://www.zhaohang.site/2017/11/01/node-js%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.zhaohang.site/2017/11/01/node-js学习/</id>
    <published>2017-10-31T23:40:12.000Z</published>
    <updated>2018-01-05T13:30:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于 <code>node.js</code> 的学习,感谢<a href="http://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>与<a href="http://www.imooc.com/course/list?c=nodejs" target="_blank" rel="noopener">慕课网</a>提供的优秀资料随着学习的深入,此文章持续更新…</p><a id="more"></a><hr><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><ul><li>支持<code>js json node</code>扩展名,不写依次尝试</li><li>不写路径则认为是<code>build-in</code>模块或各级<code>node_modules</code>内的第三方模块</li><li><code>module</code>被加载的时候执行,加载后缓存</li><li>一旦出现某个模块被循环加载,就只输出已经执行的部分,还未执行的部分不会输出</li><li><code>const exports = module.exports</code></li></ul><h3 id="global"><a href="#global" class="headerlink" title="global"></a>global</h3><p>node 里面没有<code>window</code>全局变量,取代的是<code>global</code>全局变量,例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">global.a = <span class="number">200</span></span><br><span class="line"><span class="comment">// 暴露到全局中</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 200</span></span><br></pre></td></tr></table></figure><h4 id="global-process"><a href="#global-process" class="headerlink" title="global.process"></a>global.process</h4><ul><li>挂载在全局<code>global</code>下的方法,可以读取 node 命令参数</li></ul><p>输出到控制台</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.stdout</span><br></pre></td></tr></table></figure><p>argv = [node 命令, main.js 路径, –test, a=1, b=2]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> argv = process</span><br><span class="line">node main.js --test a=<span class="number">1</span> b=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>当前进程执行路径(执行 node 脚本的路径)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.cwd())</span><br></pre></td></tr></table></figure><p>插入当前事件队列的最后一个 发生顺序 <code>nextTick</code> &gt; <code>setTimeout</code> &gt; `setImmediate</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><h4 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h4><ul><li>Buffer 类似于数组,挂载在全局<code>global</code>下的方法,操作二进制数据流</li></ul><p>创建一个长度 10 且不可改变长度的 Buffer,默认用 0 填充</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = Buffer.alloc(<span class="number">10</span>)</span><br><span class="line">buf[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">Buffer.alloc(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 用1填充</span></span><br></pre></td></tr></table></figure><p>定义一个长度为 10 的 Buffer,内容随机.因为没有清空值,所以创建速度更快</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.allocUnsafe(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>创建指定内容的 Buffer,默认使用 utf-8 编码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Buffer.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">Buffer.from(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure><p>Buffer 长度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Buffer.byteLength(<span class="string">'test'</span>) <span class="comment">// 4</span></span><br><span class="line">Buffer.byteLength(<span class="string">'测试'</span>) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>判断 Buffer 类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Buffer.isBuffer(&#123;&#125;) <span class="comment">// false</span></span><br><span class="line">Buffer.isBuffer(Buffer.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>拼接 Buffer 类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = Buffer.concat([Buffer.from(<span class="string">'hello'</span>), Buffer.from(<span class="string">' world'</span>)])</span><br></pre></td></tr></table></figure><ul><li>Buffer 类型的一些实例方法:</li></ul><p>转换字符串类型,默认 utf-8 编码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(buf.toString(<span class="string">'base64'</span>))</span><br></pre></td></tr></table></figure><p>Buffer 类型初始定义长度,与内容无关</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(buf.length) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>填充 Buffer 类型内容,第一个参数为填充内容,第二三个参数为填充位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(buf.fill(<span class="number">10</span>, <span class="number">2</span>, <span class="number">6</span>)) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>判断 Buffer 类型的内容是否一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Buffer.from(<span class="string">'test'</span>).equals(Buffer.from(<span class="string">'test'</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>判断 Buffer 类型包含的内容位置,类似于数组的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Buffer.from(<span class="string">'test'</span>).indexOf(<span class="string">'es'</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(Buffer.from(<span class="string">'test'</span>).indexOf(<span class="string">'es!'</span>) <span class="comment">//  -1</span></span><br></pre></td></tr></table></figure><p>拷贝 Buffer 类型,参数<code>buf2</code>开始拷贝位置,<code>buf</code>拷贝区间汉字长度为 3,有时候会导致<code>copy</code>乱码,可以用内置包<code>string_decode</code>解决</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = Buffer.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="keyword">const</span> buf2 = Buffer.alloc(<span class="number">3</span>)</span><br><span class="line">buf.copy(buf2, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StringDecoder = <span class="built_in">require</span>(<span class="string">'string_decode'</span>).StringDecoder</span><br><span class="line"><span class="keyword">const</span> decoder = <span class="keyword">new</span> StringDecoder(<span class="string">'utf8'</span>)</span><br><span class="line">decoder.write(buf2)</span><br></pre></td></tr></table></figure><h3 id="常用-api"><a href="#常用-api" class="headerlink" title="常用 api"></a>常用 api</h3><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p>合并出文件路径<code>/usr/local/bin/</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line">path.join(<span class="string">'/usr'</span>, <span class="string">'local'</span>, <span class="string">'bin/'</span>)</span><br></pre></td></tr></table></figure><p>解析出绝对路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(<span class="string">'./'</span>)</span><br></pre></td></tr></table></figure><p>文件名 文件夹名 扩展名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(path.basename)</span><br><span class="line"><span class="built_in">console</span>.log(path.dirname)</span><br><span class="line"><span class="built_in">console</span>.log(path.extname)</span><br></pre></td></tr></table></figure><p>(总是)解析出文件绝对路径 文件夹绝对路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(__dirname)</span><br><span class="line"><span class="built_in">console</span>.log(__filename)</span><br></pre></td></tr></table></figure><p><code>./</code>有两种情况:</p><ol><li>当在<code>require</code>里面使用时,等同于<code>__dirname</code>(总是文件绝对路径)</li><li>当在其他地方使用时,等同于<code>process.cwd()</code>(相对于进程绝对路径)</li></ol><h4 id="events"><a href="#events" class="headerlink" title="events"></a>events</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomEvent</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> ce = <span class="keyword">new</span> CustomEvent()</span><br></pre></td></tr></table></figure><p><code>on</code> 绑定事件与触发函数,一个事件可以绑定多个函数<br><code>emit</code> 触发事件,填入参数<br><code>removeListener</code>移除单个事件函数<br><code>removeAllListener</code>移除所有事件函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'remove'</span>)</span><br><span class="line">&#125;</span><br><span class="line">ce.on(<span class="string">'error'</span>, (err, time) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">    <span class="built_in">console</span>.log(time)</span><br><span class="line">&#125;)</span><br><span class="line">ce.on(<span class="string">'error'</span>, fn1)</span><br><span class="line">ce.emit(<span class="string">'error'</span>, <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oops!'</span>), <span class="built_in">Date</span>.now())</span><br><span class="line">ce.removeListener(<span class="string">'error'</span>, fn1)</span><br></pre></td></tr></table></figure><p><code>once</code> 绑定的事件只会触发一次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ce.once(<span class="string">'test'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test event once'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="fs-文件操作"><a href="#fs-文件操作" class="headerlink" title="fs 文件操作"></a>fs 文件操作</h4><p>读取文件,分同步与异步方法,可设置读取格式参数<code>utf8</code> 默认为<code>Buffer</code>类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">fs.readFile(<span class="string">'./main.js'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line"><span class="keyword">const</span> data = fs.readFileSync(<span class="string">'./main.js'</span>, <span class="string">'utf8'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br></pre></td></tr></table></figure><p>创建写入文件,默认类型<code>utf8</code> 也可以传入<code>Buffer</code>类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(<span class="string">'./text'</span>, <span class="string">'hello world'</span>, <span class="string">'uft8'</span>, err =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> content = Buffer.from(<span class="string">'this is a test!'</span>)</span><br><span class="line">fs.writeFile(<span class="string">'./text'</span>, content, err =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加文件内容</span></span><br><span class="line">fs.appendFile(<span class="string">'file'</span>, <span class="string">'你好 python'</span>, err =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure><p>读取文件状态 监视文件状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fs.stat(<span class="string">'./main.js'</span>, (err, stats) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'文件不存在'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(stats.isFile())</span><br><span class="line">    <span class="built_in">console</span>.log(stats)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.watch(</span><br><span class="line">    <span class="string">'./'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        recursive: <span class="literal">true</span> <span class="comment">// 递归监视</span></span><br><span class="line">    &#125;,</span><br><span class="line">    (eventType, filename) =&gt; &#123;</span><br><span class="line">        <span class="comment">//事件类型   文件名</span></span><br><span class="line">        <span class="built_in">console</span>.log(eventType, filename)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>文件流相关 读与写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">'./main.js'</span>)</span><br><span class="line"><span class="comment">// 打印到控制台,pipe可以链式使用</span></span><br><span class="line">rs.pipe(process.stdout).pipe(...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = fs.createWriteStream(<span class="string">'./text.txt'</span>)</span><br><span class="line"><span class="keyword">const</span> tid = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> num = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        ws.write(num + <span class="string">''</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearInterval(tid)</span><br><span class="line">        <span class="comment">// 结束写入流</span></span><br><span class="line">        ws.end()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br><span class="line"><span class="comment">// 结束时触发 finish 事件</span></span><br><span class="line">ws.on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>压缩文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createGzip, createDeflate &#125; = <span class="built_in">require</span>(<span class="string">'zlib'</span>)</span><br><span class="line"><span class="keyword">const</span> inp = fs.createReadStream(<span class="string">'input.txt'</span>)</span><br><span class="line"><span class="keyword">const</span> out = fs.createWriteStream(<span class="string">'input.txt.gz'</span>)</span><br><span class="line">inp.pipe(createGzip()).pipe(out)</span><br></pre></td></tr></table></figure><p>改名 删除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.rename(<span class="string">'./main.js'</span>, <span class="string">'index.js'</span>, err =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">fs.unlink(<span class="string">'./main.js'</span>, err =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure><p>读取文件列表 创建文件夹 删除文件夹</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.readdir(<span class="string">'./'</span>, (err, files) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">console</span>.log(files)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.mkdir(<span class="string">'test'</span>, err =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">fs.rmdir(<span class="string">'test'</span>, err =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure><h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><p>目前解决异步的方法<code>promise</code> 与 <code>async await</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise化工具</span></span><br><span class="line"><span class="keyword">const</span> promisify = <span class="built_in">require</span>(<span class="string">'util'</span>).promisify</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> read = promisify(fs.readFile)</span><br><span class="line">read(<span class="string">'./main.js'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// async await</span></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> content = <span class="keyword">await</span> read(<span class="string">'./main.js'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(content.toString())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于 &lt;code&gt;node.js&lt;/code&gt; 的学习,感谢&lt;a href=&quot;http://www.runoob.com/nodejs/nodejs-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程&lt;/a&gt;与&lt;a href=&quot;http://www.imooc.com/course/list?c=nodejs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;慕课网&lt;/a&gt;提供的优秀资料随着学习的深入,此文章持续更新…&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://www.zhaohang.site/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="node" scheme="http://www.zhaohang.site/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>go依赖管理工具govendor</title>
    <link href="http://www.zhaohang.site/2017/10/24/go%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7govendor/"/>
    <id>http://www.zhaohang.site/2017/10/24/go依赖管理工具govendor/</id>
    <published>2017-10-24T11:16:12.000Z</published>
    <updated>2018-01-05T13:23:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/kardianos/govendor" target="_blank" rel="noopener">govendor</a>是类似于<code>npm</code>的一个包管理工具…</p><a id="more"></a><p>该工具将项目依赖的外部包拷贝到项目下的 <code>vendor</code> 目录下，并通过 <code>vendor.json</code> 文件来记录依赖包的版本，方便用户使用相对稳定的依赖。</p><h3 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h3><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:center">缩写状态</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">+local</td><td style="text-align:center">l</td><td style="text-align:center">本地包，即项目自身的包组织</td></tr><tr><td style="text-align:center">+external</td><td style="text-align:center">e</td><td style="text-align:center">外部包，即被 <code>$GOPATH</code> 管理，但不在 <code>vendor</code> 目录下</td></tr><tr><td style="text-align:center">+vendor</td><td style="text-align:center">v</td><td style="text-align:center">已被 <code>govendor</code> 管理，即在 <code>vendor</code> 目录下</td></tr><tr><td style="text-align:center">+std</td><td style="text-align:center">s</td><td style="text-align:center">标准库中的包</td></tr><tr><td style="text-align:center">+unused</td><td style="text-align:center">u</td><td style="text-align:center">未使用的包，即包在 vendor 目录下，但项目并没有用到</td></tr><tr><td style="text-align:center">+missing</td><td style="text-align:center">m</td><td style="text-align:center">代码引用了依赖包，但该包并没有找到</td></tr><tr><td style="text-align:center">+program</td><td style="text-align:center">p</td><td style="text-align:center">主程序包，意味着可以编译为执行文件</td></tr><tr><td style="text-align:center">+outside</td><td style="text-align:center"></td><td style="text-align:center">外部包和缺失的包</td></tr><tr><td style="text-align:center">+all</td><td style="text-align:center"></td><td style="text-align:center">所有的包</td></tr></tbody></table><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">init</td><td style="text-align:center">创建 <code>vendor</code> 文件夹和 <code>vendor.json</code> 文件</td></tr><tr><td style="text-align:center">list</td><td style="text-align:center">列出已经存在的依赖包</td></tr><tr><td style="text-align:center">add</td><td style="text-align:center">从 <code>$GOPATH</code> 中添加依赖包，会加到 vendor.json</td></tr><tr><td style="text-align:center">update</td><td style="text-align:center">从 <code>$GOPATH</code> 升级依赖包</td></tr><tr><td style="text-align:center">remove</td><td style="text-align:center">从 <code>vendor</code> 文件夹删除依赖</td></tr><tr><td style="text-align:center">status</td><td style="text-align:center">列出本地丢失的、过期的和修改的<code>package</code></td></tr><tr><td style="text-align:center">fetch</td><td style="text-align:center">从远端库添加或者更新 <code>vendor</code> 文件中的依赖包</td></tr><tr><td style="text-align:center">sync</td><td style="text-align:center">本地存在<code>vendor.json</code> 时候拉取依赖包，匹配所记录的版本</td></tr><tr><td style="text-align:center">get</td><td style="text-align:center">等同于<code>go get</code></td></tr></tbody></table><h3 id="常用指令说明"><a href="#常用指令说明" class="headerlink" title="常用指令说明"></a>常用指令说明</h3><p>安装<code>govendor</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span> github.<span class="keyword">com</span>/kardianos/govendor</span><br></pre></td></tr></table></figure><p>从<code>$GOPATH</code> 中添加所有依赖包</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">govendor <span class="keyword">add</span><span class="bash"> +external</span></span><br></pre></td></tr></table></figure><p>查看使用的包列表</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">govendor <span class="built_in">list</span> -v fmt</span><br></pre></td></tr></table></figure><p>从线上远端库添加或更新最新的依赖包</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">govendor fetch golang<span class="meta">.org</span>/<span class="built_in">x</span>/net/context</span><br></pre></td></tr></table></figure><p>从线上远端库添加或更新标签或分支等于<code>v1</code>的依赖包</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">govendor fetch golang<span class="meta">.org</span>/<span class="built_in">x</span>/net/context@=v1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/kardianos/govendor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;govendor&lt;/a&gt;是类似于&lt;code&gt;npm&lt;/code&gt;的一个包管理工具…&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="http://www.zhaohang.site/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="go" scheme="http://www.zhaohang.site/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>服务器响应状态码大全</title>
    <link href="http://www.zhaohang.site/2017/10/17/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    <id>http://www.zhaohang.site/2017/10/17/服务器响应状态码大全/</id>
    <published>2017-10-17T01:10:12.000Z</published>
    <updated>2018-01-05T13:21:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>状态码天天遇到,这东西就是个约定,知道就行,下面先来看一些常用的:</p><a id="more"></a><ul><li>200：服务器响应正常(ok)。</li><li>304：该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用 GET 请求时尤其需要注意）。</li><li>400：无法找到请求的资源(服务器得到响应但没有可以返回的数据)。</li><li>401：访问资源的权限不够。</li><li>403：没有权限访问资源。</li><li>404：需要访问的资源不存在(大名鼎鼎的 404)。</li><li>405：需要访问的资源被禁止。</li><li>500：服务器内部错误(5 开头一般都是服务器错误了)。</li></ul><hr><blockquote><p>下面列出状态码大全备用:</p></blockquote><ul><li><p>100——客户必须继续发出请求</p></li><li><p>101——客户要求服务器根据请求转换 HTTP 协议版本</p></li><li><p>200——交易成功</p></li><li><p>201——提示知道新文件的 URL</p></li><li><p>202——接受和处理、但处理未完成</p></li><li><p>203——返回信息不确定或不完整</p></li><li><p>204——请求收到，但返回信息为空</p></li><li><p>205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</p></li><li><p>206——服务器已经完成了部分用户的 GET 请求</p></li><li><p>300——请求的资源可在多处得到</p></li><li><p>301——删除请求数据</p></li><li><p>302——在其他地址发现了请求数据</p></li><li><p>303——建议客户访问其他 URL 或访问方式</p></li><li><p>304——客户端已经执行了 GET，但文件未变化</p></li><li><p>305——请求的资源必须从服务器指定的地址得到</p></li><li><p>306——前一版本 HTTP 中使用的代码，现行版本中不再使用</p></li><li><p>307——申明请求的资源临时性删除</p></li><li><p>400——错误请求，如语法错误</p></li><li><p>401——请求授权失败</p></li><li><p>402——保留有效 ChargeTo 头响应</p></li><li><p>403——请求不允许</p></li><li><p>404——没有发现文件、查询或 URl</p></li><li><p>405——用户在 Request-Line 字段定义的方法不允许</p></li><li><p>406——根据用户发送的 Accept 拖，请求资源不可访问</p></li><li><p>407——类似 401，用户必须首先在代理服务器上得到授权</p></li><li><p>408——客户端没有在用户指定的时间内完成请求</p></li><li><p>409——对当前资源状态，请求不能完成</p></li><li><p>410——服务器上不再有此资源且无进一步的参考地址</p></li><li><p>411——服务器拒绝用户定义的 Content-Length 属性请求</p></li><li><p>412——一个或多个请求头字段在当前请求中错误</p></li><li><p>413——请求的资源大于服务器允许的大小</p></li><li><p>414——请求的资源 URL 长于服务器允许的长度</p></li><li><p>415——请求资源不支持请求项目格式</p></li><li><p>416——请求中包含 Range 请求头字段，在当前请求资源范围内没有 range 指示值，请求也不包含 If-Range 请求头字段</p></li><li><p>417——服务器不满足请求 Expect 头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求</p></li><li><p>500——服务器产生内部错误</p></li><li><p>501——服务器不支持请求的函数</p></li><li><p>502——服务器暂时不可用，有时是为了防止发生系统过载</p></li><li><p>503——服务器过载或暂停维修</p></li><li><p>504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长</p></li><li><p>505——服务器不支持或拒绝支请求头中指定的 HTTP 版本</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;状态码天天遇到,这东西就是个约定,知道就行,下面先来看一些常用的:&lt;/p&gt;
    
    </summary>
    
      <category term="杂货铺" scheme="http://www.zhaohang.site/categories/%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
      <category term="variety" scheme="http://www.zhaohang.site/tags/variety/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式学习</title>
    <link href="http://www.zhaohang.site/2017/10/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.zhaohang.site/2017/10/05/正则表达式学习/</id>
    <published>2017-10-05T06:15:18.000Z</published>
    <updated>2018-01-05T13:21:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于这个东西,我并不想多说,不求掌握,只求别人写的能看懂,本文参考了<a href="http://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>与<a href="http://www.imooc.com/learn/706" target="_blank" rel="noopener">慕课网</a>,感谢分享</p><a id="more"></a><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>下面来简单了解一下相关解释</p><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><p>元字符就是特殊字符，就是正则里面有特殊含义的字符如果要查找这些符号原义,需要进行转义,即加上反斜杠<code>\</code></p><blockquote><p>由于框架不完善,不能正确识别转义,以下表格<code>\</code>代表<code>|</code></p></blockquote><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">g</td><td style="text-align:left">全局匹配</td></tr><tr><td style="text-align:center">i</td><td style="text-align:left">忽略大小写,默认大小写敏感</td></tr><tr><td style="text-align:center">m</td><td style="text-align:left">多行搜索</td></tr><tr><td style="text-align:center">(assert)</td><td style="text-align:left">分组功能,匹配 <code>assert</code> 并获取这一匹配。所获取的匹配可以从产生的 <code>Matches</code> 集合得到</td></tr><tr><td style="text-align:center">[xyz]</td><td style="text-align:left">字符集合,匹配所包含的任意一个字符<code>[abc]</code>可以匹配<code>plain</code>中的 <code>a</code></td></tr><tr><td style="text-align:center">[^xyz]</td><td style="text-align:left">负值字符集合,匹配未包含的任意字符</td></tr><tr><td style="text-align:center">[a-z]</td><td style="text-align:left">字符范围。匹配指定范围内的任意字符 表示小写字母集合</td></tr><tr><td style="text-align:center">[^a-z]</td><td style="text-align:left">负值字符范围,匹配任何不在指定范围内的任意字符 表示非小写字母集合</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:left">匹配字母,数字,下划线.等价于<code>[A-Za-z0-9_]</code></td></tr><tr><td style="text-align:center">\W</td><td style="text-align:left">匹配非字母,数字,下划线.等价于<code>[^A-Za-z0-9_]</code></td></tr><tr><td style="text-align:center">\d</td><td style="text-align:left">匹配一个数字字符,等价于 <code>[0-9]</code></td></tr><tr><td style="text-align:center">\D</td><td style="text-align:left">匹配一个非数字字符,等价于 <code>[^0-9]</code></td></tr><tr><td style="text-align:center">\s</td><td style="text-align:left">匹配任何空白字符,包括空格,制表符,换页符等.等价于<code>[ \f\n\r\t\v]</code></td></tr><tr><td style="text-align:center">\S</td><td style="text-align:left">匹配任何非空白字符,等价于<code>[^ \f\n\r\t\v]</code></td></tr><tr><td style="text-align:center">.</td><td style="text-align:left">匹配除换行符 <code>\n</code> 之外的任何单字符</td></tr><tr><td style="text-align:center"><code>x\y</code></td><td style="text-align:left">匹配 x 或 y <code>(z\f)ood</code> 则匹配 <code>zood&quot; 或 &quot;food</code></td></tr><tr><td style="text-align:center">exp(?:assert)</td><td style="text-align:left">断言匹配 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用</td></tr><tr><td style="text-align:center">exp(?=assert)</td><td style="text-align:left">非获取匹配,正向匹配<code>Windows(?=95\\98\\NT\\2000)</code>能匹配<code>Windows2000</code>中的<code>Windows</code></td></tr><tr><td style="text-align:center">exp(?!assert)</td><td style="text-align:left">非获取匹配,反向匹配<code>Windows(?!95\\98\\NT\\2000)</code>能匹配<code>Windows3.1</code>中的<code>Windows</code></td></tr></tbody></table><h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:left">匹配前面的子表达式零次或多次 <code>*</code> 等价于<code>{0,}</code></td></tr><tr><td style="text-align:center">+</td><td style="text-align:left">匹配前面的子表达式一次或多次 <code>+</code> 等价于<code>{1,}</code></td></tr><tr><td style="text-align:center">?</td><td style="text-align:left">匹配前面的子表达式零次或一次 <code>?</code> 等价于<code>{0,1}</code></td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:left"><code>n</code> 是一个非负整数。匹配确定的 <code>n</code>次</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:left"><code>n</code> 是一个非负整数。至少匹配<code>n</code> 次 <code>o{1,}</code> 等价于 <code>o+</code> <code>o{0,}</code> 等价于 <code>o*</code></td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:left">均为非负整数,其中<code>n &lt;= m</code>最少匹配 n 次且最多匹配 m 次 <code>o{0,1}&#39;</code>等价于 <code>o?</code></td></tr></tbody></table><hr><p><strong><code>*、+</code>限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个<code>?</code>就可以实现非贪婪或最小匹配</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">H1</span>&gt;</span>Chapter 1 - 介绍正则表达式<span class="tag">&lt;/<span class="name">H1</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 贪婪: 匹配整句</span></span><br><span class="line">/&lt;.*&gt;/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 非贪婪: 只配置开始结束标签</span></span><br><span class="line">/&lt;.*?&gt;/</span><br></pre></td></tr></table></figure><h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><p>定位符使您能够将正则表达式固定到行首或行尾或固定到一个单词的开头或者结尾</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">^</td><td style="text-align:center">匹配输入字符串开始的位置</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配输入字符串结尾的位置</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配一个字边界，即字开头结尾</td></tr><tr><td style="text-align:center">\B</td><td style="text-align:center">非字边界匹配</td></tr></tbody></table><h4 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h4><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 <code>1</code> 开始，最多可存储 <code>99</code> 个捕获的子表达式。每个缓冲区都可以使用<code>\n</code> 访问，其中 <code>n</code> 为一个标识特定缓冲区的一位或两位十进制数</p><p>可以使用非捕获元字符 <code>?:、?= 或 ?!</code> 来重写捕获，忽略对相关匹配的保存</p><h3 id="JavaScript-中的正则"><a href="#JavaScript-中的正则" class="headerlink" title="JavaScript 中的正则"></a>JavaScript 中的正则</h3><p>对于<code>JavaScript</code>来说,捕获访问符合是<code>$1,$2...</code></p><p>一些常用方法</p><p>split: 把字符串按照规则分成数组 平时的使用,也是把输入的字符串转换成正则来生效的</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a1b4c-f.'</span>.split(<span class="regexp">/[\d-\.]/</span>)    <span class="regexp">//</span>[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"f"</span>, <span class="string">""</span>]</span><br></pre></td></tr></table></figure><p>replace: 替换符合匹配规定的字符串 可通过<code>$n</code>获取子匹配 平时的使用,也是把输入的字符串转换成正则来生效的</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'2015-12-25'</span>.replace(/(\d&#123;<span class="number">4</span>&#125;)-(\d&#123;<span class="number">2</span>&#125;)-(\d&#123;<span class="number">2</span>&#125;)/,<span class="string">'$2-$3-$1'</span>)   // <span class="number">12</span>-<span class="number">25</span>-<span class="number">2015</span></span><br><span class="line"></span><br><span class="line">// match: 匹配的字符串  <span class="built_in">a1</span>, <span class="built_in">a2</span>, <span class="built_in">a3</span>: 匹配的字表达式值,没有字表达式就没有这个参数 index: match位置 origin: 被检查的字符串</span><br><span class="line"><span class="string">'a1b2c3d4e5'</span>.replace(/(\d)(\w)(\d)/g, <span class="meta">function</span>(match, <span class="built_in">a1</span>, <span class="built_in">a2</span>, <span class="built_in">a3</span>, index, origin) &#123;</span><br><span class="line">    return <span class="built_in">a1</span> + <span class="built_in">a3</span></span><br><span class="line">&#125;)</span><br><span class="line">// 虽然匹配到的是数字,但<span class="built_in">a1</span> <span class="built_in">a3</span> 都是字符串 所以 返回  <span class="string">"a13c34e5"</span></span><br></pre></td></tr></table></figure><p>test: 检查是否存在匹配 返回<code>bool</code> 当全局匹配的时候 <code>reg.lastIndex</code>会因为变动而存在一些问题,需要注意</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\d(\w)/.test('asdsad<span class="number">2132</span>1')   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>exec: 检查匹配 无匹配返回<code>null</code> 有匹配返回一个数组 <code>index</code>匹配文本的第一个位置<code>input</code>被检查的字符串 全局匹配同样存在问题</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/\d(\w)/</span>.exec(<span class="string">'asdsad21321'</span>)   <span class="regexp">//</span>  [<span class="string">"21"</span>, <span class="string">"1"</span>, index: <span class="number">6</span>, input: <span class="string">"asdsad21321"</span>]</span><br></pre></td></tr></table></figure><p>search : 忽略全局符合<code>g</code> 返回符合查询的<code>index</code></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'aasf134'</span>.search<span class="comment">(s)</span>               <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>match: 非全局模式下与<code>exec</code>返回的内容一样 全局模式下,返回所有匹配的字符串数组 没有<code>input,index</code> <code>match</code>无视<code>lastIndex</code>属性</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'$1az2bb3cy4dd5ee'</span>.match(<span class="regexp">/\d(\w)(\w)\d/g</span>)      <span class="regexp">//</span>[<span class="string">'1az2'</span>,<span class="string">'3cy4'</span>]</span><br></pre></td></tr></table></figure><h3 id="常用例子"><a href="#常用例子" class="headerlink" title="常用例子"></a>常用例子</h3><h4 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h4><ul><li>数字：<strong>^[0-9]*$</strong></li><li>n 位的数字：<strong>^\d{n}$</strong></li><li>至少 n 位的数字：<strong>^\d{n,}$</strong></li><li>m-n 位的数字：<strong>^\d{m,n}$</strong></li><li>零和非零开头的数字：<strong>^(0|[1-9][0-9]*)$</strong></li><li>非零开头的最多带两位小数的数字：<strong>^([1-9][0-9]*)+(.[0-9]{1,2})?$</strong></li><li>带 1-2 位小数的正数或负数：<strong>^(-)?\d+(.\d{1,2})$</strong></li><li>正数、负数、和小数：<strong>^(-|+)?\d+(.\d+)?$</strong></li><li>有两位小数的正实数：<strong>^[0-9]+(.[0-9]{2})?$</strong></li><li>有 1~3 位小数的正实数：<strong>^[0-9]+(.[0-9]{1,3})?$</strong></li><li>非零的正整数：<strong>^[1-9]\d<em>$ 或 ^([1-9][0-9]</em>){1,3}$ 或 ^+?[1-9][0-9]*$</strong></li><li>非零的负整数：<strong>^-[1-9][]0-9”<em>$ 或 ^-[1-9]\d</em>$</strong></li><li>非负整数：<strong>^\d+$ 或 ^[1-9]\d*|0$</strong></li><li>非正整数：<strong>^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</strong></li><li>非负浮点数：<strong>^\d+(.\d+)?$ 或 ^[1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>|0?.0+|0$</strong></li><li>非正浮点数：<strong>^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>))|0?.0+|0$</strong></li><li>正浮点数：<strong>^[1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>$ 或 ^(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]</em>.[0-9]+)|([0-9]<em>[1-9][0-9]</em>))$</strong></li><li>负浮点数：<strong>^-([1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>)$ 或 ^(-(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]</em>.[0-9]+)|([0-9]<em>[1-9][0-9]</em>)))$</strong></li><li>浮点数：<strong>^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d<em>.\d</em>|0.\d<em>[1-9]\d</em>|0?.0+|0)$</strong></li></ul><h4 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h4><ul><li>汉字：<strong>^[\u4e00-\u9fa5]{0,}$</strong></li><li>英文和数字：<strong>^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$</strong></li><li>长度为 3-20 的所有字符：<strong>^.{3,20}$</strong></li><li>由 26 个英文字母组成的字符串：<strong>^[A-Za-z]+$</strong></li><li>由 26 个大写英文字母组成的字符串：<strong>^[A-Z]+$</strong></li><li>由 26 个小写英文字母组成的字符串：<strong>^[a-z]+$</strong></li><li>由数字和 26 个英文字母组成的字符串：<strong>^[A-Za-z0-9]+$</strong></li><li>由数字、26 个英文字母或者下划线组成的字符串：<strong>^\w+$ 或 ^\w{3,20}$</strong></li><li>中文、英文、数字包括下划线：<strong>^[\u4E00-\u9FA5A-Za-z0-9_]+$</strong></li><li>中文、英文、数字但不包括下划线等符号：<strong>^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$</strong></li><li>可以输入含有\^%&amp;’,;=?$\”等字符：<strong>[^%&amp;’,;=?$\x22]+</strong></li><li>禁止输入含有~的字符：<strong>[^~\x22]+</strong></li></ul><h4 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h4><ul><li>Email 地址：<strong>^\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*$</strong></li><li>域名：<strong>[a-zA-Z0-9][-a-za-z0-9]{0,62}(/.[a-zA-Z0-9][-a-za-z0-9]{0,62})+/.?</strong></li><li>InternetURL：<strong>[a-zA-z]+://[^\s]<em> 或 ^<a href="http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=" target="_blank" rel="noopener">http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=</a>]</em>)?$</strong></li><li>手机号码：<strong>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$</strong></li><li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：<strong>^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$</strong></li><li>国内电话号码(0511-4405222、021-87888822)：<strong>\d{3}-\d{8}|\d{4}-\d{7}</strong></li><li>电话号码正则表达式（支持手机号码，3-4 位区号，7-8 位直播号码，1－4 位分机号）: <strong>((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$)</strong></li><li>身份证号(15 位、18 位数字)，最后一位是校验位，可能为数字或字符 X：<strong>(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)</strong></li><li>帐号是否合法(字母开头，允许 5-16 字节，允许字母数字下划线)：<strong>^[a-zA-Z][a-za-z0-9_]{4,15}$</strong></li><li>密码(以字母开头，长度在 6~18 之间，只能包含字母、数字和下划线)：<strong>^[a-zA-Z]\w{5,17}$</strong></li><li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：<strong>^(?=.<em>\d)(?=.</em>[a-z])(?=.*[A-Z]).{8,10}$</strong></li><li>日期格式：<strong>^\d{4}-\d{1,2}-\d{1,2}</strong></li><li>一年的 12 个月(01 ～ 09 和 1 ～ 12)：<strong>^(0?[1-9]|1[0-2])$</strong></li><li>一个月的 31 天(01 ～ 09 和 1 ～ 31)：<strong>^((0?[1-9])|((1|2)[0-9])|30|31)$</strong></li><li>钱的输入格式：<ol><li>有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：<strong>^[1-9][0-9]*$</strong></li><li>这表示任意一个不以 0 开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：<strong>^(0|[1-9][0-9]*)$</strong></li><li>一个 0 或者一个不以 0 开头的数字.我们还可以允许开头有一个负号：<strong>^(0|-?[1-9][0-9]*)$</strong></li><li>这表示一个 0 或者一个可能为负的开头不为 0 的数字.让用户以 0 开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：<strong>^[0-9]+(.[0-9]+)?$</strong></li><li>必须说明的是,小数点后面至少应该有 1 位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：<strong>^[0-9]+(.[0-9]{2})?$</strong></li><li>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：<strong>^[0-9]+(.[0-9]{1,2})?$</strong></li><li>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：<strong>^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$</strong></li><li>1 到 3 个数字,后面跟着任意个 逗号+3 个数字,逗号成为可选,而不是必须：<strong>^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$</strong></li><li>备注：这就是最终结果了,别忘了<code>+</code>可以用<code>*</code>替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</li></ol></li><li>xml 文件：<strong>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|m][l|L]$</strong></li><li>中文字符的正则表达式：<strong>[\u4e00-\u9fa5]</strong></li><li>双字节字符：<strong>[^\x00-\xff]</strong> (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计 2，ASCII 字符计 1))</li><li>空白行的正则表达式：<strong>\n\s*\r</strong> (可以用来删除空白行)</li><li>HTML 标记的正则表达式：<strong>&lt;(\S<em>?)[^&gt;]</em>&gt;.<em>?|&lt;.</em>? /&gt;</strong>( 首尾空白字符的正则表达式：<strong>^\s<em>|\s</em>$</strong>或<strong>(^\s<em>)|(\s</em>$)</strong> (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</li><li>腾讯 QQ 号：<strong>[1-9][0-9]{4,}</strong> (腾讯 QQ 号从 10000 开始)</li><li>中国邮政编码：<strong>[1-9]\d{5}(?!\d)</strong> (中国邮政编码为 6 位数字)</li><li>IP 地址：<strong>((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d))</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于这个东西,我并不想多说,不求掌握,只求别人写的能看懂,本文参考了&lt;a href=&quot;http://www.runoob.com/regexp/regexp-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程&lt;/a&gt;与&lt;a href=&quot;http://www.imooc.com/learn/706&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;慕课网&lt;/a&gt;,感谢分享&lt;/p&gt;
    
    </summary>
    
      <category term="杂货铺" scheme="http://www.zhaohang.site/categories/%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
      <category term="variety" scheme="http://www.zhaohang.site/tags/variety/"/>
    
  </entry>
  
  <entry>
    <title>photoshop简单学习</title>
    <link href="http://www.zhaohang.site/2017/09/26/photoshop%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.zhaohang.site/2017/09/26/photoshop简单学习/</id>
    <published>2017-09-26T06:12:18.000Z</published>
    <updated>2018-01-05T12:26:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>photoshop</code>一直觉得是一门十分实用的技能,了解一下很有必要随着深入学习,此篇文章持续更新…</p><a id="more"></a><h3 id="初始化设置"><a href="#初始化设置" class="headerlink" title="初始化设置"></a>初始化设置</h3><ul><li>web 常用格式一般是<code>高度不固定,宽度1920</code>等按需设置,背景为<code>透明</code></li><li>首选项-<code>单位与标尺</code>-全部改为<code>像素</code></li><li>视图里面 显示-<code>智能参考线</code> 打钩 <code>标尺</code> 打钩</li><li>右边界面 4 大功能 上面<code>字符信息</code> 下面<code>图层历史记录</code></li><li>信息界面面板选项改为<code>rpg</code>颜色模式 标尺为<code>像素</code> <code>文档尺寸</code>勾选</li></ul><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li>Windows 系统：Ctrl + Shift + Alt + E</li><li>Mac OS 系统：Cmd + Shift + Opt + E</li></ul><table><thead><tr><th style="text-align:left">功能介绍</th><th style="text-align:left">快捷键</th></tr></thead><tbody><tr><td style="text-align:left">新建文件</td><td style="text-align:left">Ctrl + N</td></tr><tr><td style="text-align:left">新建图层</td><td style="text-align:left">Ctrl + Shift + N（按住 Alt 可避免对话框)</td></tr><tr><td style="text-align:left">复制图层</td><td style="text-align:left">Ctrl + J</td></tr><tr><td style="text-align:left">选中多个图层</td><td style="text-align:left">Shift + 单击鼠标左键</td></tr><tr><td style="text-align:left">合并选中图层</td><td style="text-align:left">Ctrl + E</td></tr><tr><td style="text-align:left">合并所有可见图层</td><td style="text-align:left">Ctrl + Shift + Alt + E</td></tr><tr><td style="text-align:left">对选中图层编组</td><td style="text-align:left">Ctrl + G/双击可改名字</td></tr><tr><td style="text-align:left">载入选区</td><td style="text-align:left">Ctrl + 左键点击(元素或图层缩略图)</td></tr><tr><td style="text-align:left">取消选区</td><td style="text-align:left">Ctrl + D</td></tr><tr><td style="text-align:left">选择全部</td><td style="text-align:left">Ctrl + A</td></tr><tr><td style="text-align:left">重做最后一项选择</td><td style="text-align:left">Ctrl + Shift + D</td></tr><tr><td style="text-align:left">加选取框,减选取框</td><td style="text-align:left"><code>M</code>,Shift,Alt</td></tr><tr><td style="text-align:left">正选取框,同心选取框</td><td style="text-align:left"><code>M</code>选取后 Shift(正)Alt(同)</td></tr><tr><td style="text-align:left">选择反选</td><td style="text-align:left">Ctrl + Shift + I</td></tr><tr><td style="text-align:left">删除所选元素</td><td style="text-align:left"><code>delete</code></td></tr><tr><td style="text-align:left">自由变换（缩放、斜切）</td><td style="text-align:left">Ctrl + T</td></tr><tr><td style="text-align:left">约束比例或从中心变换</td><td style="text-align:left"><code>Shift</code>=约束 或 <code>Alt</code>=中心</td></tr><tr><td style="text-align:left">添加到选区或从选区减去</td><td style="text-align:left">拖动时按住 Shift 或者 Alt</td></tr><tr><td style="text-align:left">填充图层/选区颜色</td><td style="text-align:left">Alt + Delete</td></tr><tr><td style="text-align:left">设置画笔颜色</td><td style="text-align:left">Alt + 单击左键选取示例色</td></tr><tr><td style="text-align:left">扩大/减小选框大小</td><td style="text-align:left"><code>[</code> = 缩小大小 <code>]</code> = 扩大大小</td></tr><tr><td style="text-align:left">撤销上一步/后退一步</td><td style="text-align:left">Ctrl + Z，Ctrl + Alt + Z</td></tr><tr><td style="text-align:left">放大/缩小</td><td style="text-align:left">Ctrl + “+” 或 Ctrl + “-“</td></tr><tr><td style="text-align:left">按屏幕大小缩放</td><td style="text-align:left">Ctrl + 0</td></tr><tr><td style="text-align:left">默认前景/背景色</td><td style="text-align:left">D</td></tr><tr><td style="text-align:left">对调前景/背景色</td><td style="text-align:left">X</td></tr><tr><td style="text-align:left">显示/隐藏 网格、参考线</td><td style="text-align:left">Ctrl + <code>&#39;</code>,Ctrl + <code>;</code></td></tr><tr><td style="text-align:left">复制该选区为新图层</td><td style="text-align:left">按住 Alt 同时拖动选区</td></tr><tr><td style="text-align:left">文件输出为 web 格式</td><td style="text-align:left">Ctrl + Shift + Alt + S</td></tr><tr><td style="text-align:left">文件存储为</td><td style="text-align:left">Ctrl + Shift + S</td></tr><tr><td style="text-align:left">关闭当前文档</td><td style="text-align:left">Ctrl + W</td></tr></tbody></table><h3 id="切图"><a href="#切图" class="headerlink" title="切图"></a>切图</h3><ul><li>一般方法:<br>可通过把整张图裁剪成一张张模块化小图,然后设置参考线,基于参考线自动切图,导出后可选择导出单张切图和所有切图</li></ul><ul><li>脚本方法:<br>文件-导出-将图层导出到文件选择 PNG-24(8)勾选全部 自动切图导出</li></ul><ul><li>简化方法:<br>首选项-增效工具-启用生成器文件-生成-图像资源(勾选)<br>设置之后会多一个同名文件夹,将想要使用的图层图像命名为相应格式(jpg,png)以后,可以在这个文件夹中看到保存的相应格式文件。通过命名可以更改保存文件的样式,例如命名 200%-像素大小扩大一倍<br>jpg8 就保存品质 80%(只有 jpg 有品质选项)<br>png8 就保存 png-8</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;photoshop&lt;/code&gt;一直觉得是一门十分实用的技能,了解一下很有必要随着深入学习,此篇文章持续更新…&lt;/p&gt;
    
    </summary>
    
      <category term="杂货铺" scheme="http://www.zhaohang.site/categories/%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
      <category term="ps" scheme="http://www.zhaohang.site/tags/ps/"/>
    
  </entry>
  
  <entry>
    <title>css学习</title>
    <link href="http://www.zhaohang.site/2017/09/18/css%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.zhaohang.site/2017/09/18/css学习/</id>
    <published>2017-09-18T07:27:55.000Z</published>
    <updated>2018-01-05T12:31:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于 css 的学习,感谢<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">MDN</a>与<a href="http://www.w3school.com.cn/css/index.asp" target="_blank" rel="noopener">W3school</a>提供的优秀资料随着深入学习,此篇文章持续更新…</p><a id="more"></a><h3 id="媒体查询-响应式开发"><a href="#媒体查询-响应式开发" class="headerlink" title="媒体查询-响应式开发"></a>媒体查询-响应式开发</h3><p>响应式设计就是一套 CSS 根据当前的分辨率选择不同的样式媒体查询主要用来:</p><ul><li>检测媒体的类型, 比如 screen, tv 等</li><li>检测布局视口的特性, 比如视口的宽高分辨率等</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">@media all and (min-width: 200px) and (max-width: 300px)&#123;</span></span><br><span class="line"><span class="undefined">    body &#123;</span></span><br><span class="line"><span class="undefined">        background: red;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">/* 网易移动端字体设置 */</span></span><br><span class="line"><span class="undefined">@media screen and (max-width: 321px) &#123;</span></span><br><span class="line"><span class="undefined">    body &#123;</span></span><br><span class="line"><span class="undefined">        font-size:16px</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">@media screen and (min-width: 321px) and (max-width:400px) &#123;</span></span><br><span class="line"><span class="undefined">    body &#123;</span></span><br><span class="line"><span class="undefined">        font-size:17px</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">@media screen and (min-width: 400px) &#123;</span></span><br><span class="line"><span class="undefined">    body &#123;</span></span><br><span class="line"><span class="undefined">        font-size:19px</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中, all 是媒体类型, 代表任何设备<br>and 是逻辑操作意思是, 对于任何设备, 在宽度在 200-300 的范围内应用这个样式</p><hr><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a><a href="http://www.w3school.com.cn/css/css_pseudo_classes.asp" target="_blank" rel="noopener">伪类</a></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>   &#123; <span class="attribute">color</span>: white; <span class="attribute">text-decoration</span>: none; &#125; <span class="comment">/*未访问--去下划线*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123; <span class="attribute">color</span>: black; &#125; <span class="comment">/*已访问--去下划线*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>  &#123; <span class="attribute">color</span>: red; <span class="attribute">cursor</span>: pointer; &#125; <span class="comment">/*悬停--鼠标样式*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123; <span class="attribute">color</span>: lightblue; &#125; <span class="comment">/*选定*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.class</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>: white;&#125;    <span class="comment">/* 独立伪类 */</span></span><br></pre></td></tr></table></figure><hr><h3 id="定位-position"><a href="#定位-position" class="headerlink" title="定位 position"></a>定位 <a href="http://www.w3school.com.cn/cssref/pr_class_position.asp" target="_blank" rel="noopener">position</a></h3><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">static</td><td style="text-align:left">默认 <code>static</code></td></tr><tr><td style="text-align:left">relative</td><td style="text-align:left">相对定位 可相对自身偏移</td></tr><tr><td style="text-align:left">absolute</td><td style="text-align:left">完全绝对定位, 忽略其他所有东西, 往上浮动到 非 static 的元素</td></tr><tr><td style="text-align:left">fixed</td><td style="text-align:left">基于 <code>window</code> 的绝对定位, 不随页面滚动改变</td></tr></tbody></table><p><strong>非 <code>static</code> 元素可以用 <code>top left bottom right</code> 属性来设置坐标</strong><br><strong>非 <code>static</code> 元素可以用 <code>z-index</code> 属性来设置显示层次</strong></p><ul><li>e.pageX——相对整个页面的坐标</li><li>e.clientX——相对可视区域的坐标</li><li>e.offsetX——相对当前坐标系的 border 左上角开始的坐标</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于 css 的学习,感谢&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MDN&lt;/a&gt;与&lt;a href=&quot;http://www.w3school.com.cn/css/index.asp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;W3school&lt;/a&gt;提供的优秀资料随着深入学习,此篇文章持续更新…&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.zhaohang.site/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="css" scheme="http://www.zhaohang.site/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>shell常用命令</title>
    <link href="http://www.zhaohang.site/2017/09/08/shell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.zhaohang.site/2017/09/08/shell常用命令/</id>
    <published>2017-09-08T06:01:25.000Z</published>
    <updated>2017-12-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>shell</code>既是一种命令语言，又是一种程序设计语言,是用户使用 Linux 的桥梁随着深入学习,此篇文章持续更新…</p><a id="more"></a><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p>文件权限说明</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxrwx<span class="comment">---</span></span><br></pre></td></tr></table></figure><p>第一个字母<code>d</code> 表示目录文件 若为<code>-</code>则是文件其余 9 个字母,分为 3 组,分别是属<strong>主权限 、属组权限 、其他用户权限</strong></p><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">意义</th><th style="text-align:center">数字表示</th><th style="text-align:center">身份代码</th></tr></thead><tbody><tr><td style="text-align:center">r</td><td style="text-align:center">读权限</td><td style="text-align:center">4</td><td style="text-align:center">u</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">写权限</td><td style="text-align:center">2</td><td style="text-align:center">g</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">执行权限</td><td style="text-align:center">1</td><td style="text-align:center">o</td></tr></tbody></table><p>若用<code>-</code>表示,代表没有相应权限所有人的身份代码可用<code>a</code>表示</p><p>更改文件权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 777 表示3组所有权限都打开  是4+2+1的和</span></span><br><span class="line">chmod 777 filename</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以通过+ - = 来设定权限</span></span><br><span class="line">chmod u=rwx, g=rx, o=r filename</span><br><span class="line">chmod u+r, g+r, o+r filename</span><br><span class="line">chmod a-x filename</span><br></pre></td></tr></table></figure><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><ul><li>条件表达式要放在方括号之间,并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]</li><li>单引号中变量无效转义符无效,双引号变量有效转义符有效</li></ul><hr><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重新执行刚修改的文件,使立即成效</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印,等同于<span class="built_in">log</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以传入参数 <span class="variable">$0</span>是脚本名 <span class="variable">$1</span>是1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sh file.sh 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 传入参数的个数  所有传入参数</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$#</span>  $*</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上个命令的退出状态，或函数的返回值</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $?</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $$</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -e 开启转义  \n开启换行  \c不换行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">"OK! \n"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cut 剪切字节、字符和字段并将这些字节、字符和字段写至标准输出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cut -b 3-5</span></span><br></pre></td></tr></table></figure><hr><h3 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义变量,等号两边不可有空格</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> name=<span class="string">"runoob.com"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置只读变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">readonly</span> name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> name 接收标准输入的变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">read</span> name</span></span><br></pre></td></tr></table></figure><hr><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 字符串拼接方法</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> greeting=<span class="string">"hello, "</span><span class="variable">$name</span><span class="string">" !"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> greeting_1=<span class="string">"hello, <span class="variable">$&#123;name&#125;</span> !"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取字符串长度</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;#name&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从字符串第 2 个字符开始截取 4 个字符</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;name:1:4&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> *// 表示从左边开始删除第一个 // 号及左边的所有字符</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;name#*//&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">##表示从左边开始删除最右边一个/及左边的字符</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;name##*/&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> %/* 表示从右边开始，删除第一个 / 号及右边的字符</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;name%/*&#125;</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义数组</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> array_name=(value0 value1 value2 value3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取数组</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="variable">$&#123;数组名[下标]&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取所有数组</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="variable">$&#123;array_name[*]&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取数组长度</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> length=<span class="variable">$&#123;#array_name[*]&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取某个数组元素长度</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lengthn=<span class="variable">$&#123;#array_name[n]&#125;</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> MAC 中 shell 的 expr 语法是：$((表达式))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> expr 运算符</span></span><br><span class="line">+ - * / % = == !=</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 非运算 或运算 与运算</span></span><br><span class="line">! -o  '-a &amp;&amp;'</span><br></pre></td></tr></table></figure><hr><h2 id="Mac-OSX-命令行"><a href="#Mac-OSX-命令行" class="headerlink" title="Mac OSX 命令行"></a>Mac OSX 命令行</h2><h3 id="一些常用命令"><a href="#一些常用命令" class="headerlink" title="一些常用命令"></a>一些常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 允许所有来源</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo spctl --master-disable</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示隐藏文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> defaults write com.apple.finder AppleShowAllFiles -bool <span class="literal">true</span> killall Finder</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复文件隐藏</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> defaults write com.apple.finder AppleShowAllFiles -bool <span class="literal">false</span> killall Finder</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 标题栏显示完整路径</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES killall Finder</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 标题栏显示当前路径</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> defaults write com.apple.finder _FXShowPosixPathInTitle -bool NO killall Finder</span></span><br></pre></td></tr></table></figure><h3 id="快捷命令"><a href="#快捷命令" class="headerlink" title="快捷命令"></a>快捷命令</h3><table><thead><tr><th style="text-align:center">功能说明</th><th style="text-align:center">快捷键</th></tr></thead><tbody><tr><td style="text-align:center">新建一个文件</td><td style="text-align:center">touch</td></tr><tr><td style="text-align:center">拷贝文件</td><td style="text-align:center">cp</td></tr><tr><td style="text-align:center">删除文件</td><td style="text-align:center">rm</td></tr><tr><td style="text-align:center">移动文件</td><td style="text-align:center">mv</td></tr><tr><td style="text-align:center">显示文件类型</td><td style="text-align:center">file</td></tr><tr><td style="text-align:center">显示进程状态</td><td style="text-align:center">ps</td></tr><tr><td style="text-align:center">显示当前时间</td><td style="text-align:center">date</td></tr><tr><td style="text-align:center">显示日历</td><td style="text-align:center">cal</td></tr><tr><td style="text-align:center">统计程序的执行时间</td><td style="text-align:center">time</td></tr><tr><td style="text-align:center">显示操作系统信息</td><td style="text-align:center">uname -a</td></tr><tr><td style="text-align:center">光标回到命令行首(尾)</td><td style="text-align:center">Ctrl + a(e)</td></tr><tr><td style="text-align:center">删除光标处到行首(尾)的字符</td><td style="text-align:center">Ctrl + w(k)</td></tr><tr><td style="text-align:center">删除整个命令行文本字符</td><td style="text-align:center">Ctrl + u</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;shell&lt;/code&gt;既是一种命令语言，又是一种程序设计语言,是用户使用 Linux 的桥梁随着深入学习,此篇文章持续更新…&lt;/p&gt;
    
    </summary>
    
      <category term="杂货铺" scheme="http://www.zhaohang.site/categories/%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
      <category term="shell" scheme="http://www.zhaohang.site/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>html学习</title>
    <link href="http://www.zhaohang.site/2017/08/24/html%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.zhaohang.site/2017/08/24/html学习/</id>
    <published>2017-08-24T07:10:20.000Z</published>
    <updated>2018-01-05T12:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于 <code>html</code> 的学习,感谢<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML" target="_blank" rel="noopener">MDN</a>与<a href="http://www.w3school.com.cn/html/index.asp" target="_blank" rel="noopener">W3school</a>提供的优秀资料随着深入学习,此篇文章持续更新…</p><a id="more"></a><h3 id="移动端设置"><a href="#移动端设置" class="headerlink" title="移动端设置"></a>移动端设置</h3><p>设置 <code>viewport</code><br><code>viewport</code> 是 <code>html</code> 的父元素在手机上需要用下面的语句设置它的尺寸</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">//设置rem</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.documentElement.style.fontSize</span></span><br><span class="line"><span class="javascript">= <span class="built_in">document</span>.documentElement.clientWidth / <span class="number">7.5</span>(iPhone6相对宽度) + <span class="string">'px'</span>;</span></span><br><span class="line"><span class="actionscript"><span class="comment">//通过设计图宽度 / 100 来得出相对宽度 rem</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">//比如iphone5 设计图宽度640 相对宽度 6.4</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">width=device-width</td><td style="text-align:left">宽度等于设备宽度</td></tr><tr><td style="text-align:left">height=device-height</td><td style="text-align:left">高度等于设备宽度</td></tr><tr><td style="text-align:left">initial-scale</td><td style="text-align:left">初始缩放比例</td></tr><tr><td style="text-align:left">minimum-scale</td><td style="text-align:left">允许用户缩放的最小比例</td></tr><tr><td style="text-align:left">maximum-scale</td><td style="text-align:left">允许用户缩放的最大比例</td></tr><tr><td style="text-align:left">user-scalable</td><td style="text-align:left">是否允许用户缩放</td></tr></tbody></table><hr><h3 id="icon-设置"><a href="#icon-设置" class="headerlink" title="icon 设置"></a>icon 设置</h3><p>直接在<code>index.html</code>同文件夹放置<code>favicon.ico</code>图片或者:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"img"</span> <span class="attr">type</span>=<span class="string">"image/x-icon"</span> /&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="视频音频标签"><a href="#视频音频标签" class="headerlink" title="视频音频标签"></a>视频音频标签</h3><p>带控制器的视频标签, 不同浏览器有不同的文件格式要求所以用 2 个 source 标签指定不同的视频格式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"200"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.mp4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.ogv"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>带控制器的音频标签, 不同浏览器有不同的文件格式要求所以用 2 个 source 标签指定不同的音频格式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">id</span>=<span class="string">'id-audio-player'</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"audio.ogg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"audio.mp3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span> &gt;</span></span><br></pre></td></tr></table></figure><p>audio 基本操作如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.querySelector(<span class="string">'#id-audio-player'</span>)</span><br><span class="line">a.play() <span class="comment">//播放</span></span><br><span class="line">a.pause() <span class="comment">//暂停</span></span><br><span class="line">a.autoplay <span class="comment">//自动播放 (设为true)</span></span><br><span class="line">a.src <span class="comment">//链接音频文件</span></span><br><span class="line">a.volume <span class="comment">//音量（0-1之间的数）</span></span><br><span class="line">a.duration <span class="comment">//音频时间长度</span></span><br><span class="line">a.currentTime = <span class="number">1</span> <span class="comment">//现在播放第几s（设置）</span></span><br><span class="line">a.playbackRate <span class="comment">// 播放速率, 默认是 1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于 &lt;code&gt;html&lt;/code&gt; 的学习,感谢&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTML&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MDN&lt;/a&gt;与&lt;a href=&quot;http://www.w3school.com.cn/html/index.asp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;W3school&lt;/a&gt;提供的优秀资料随着深入学习,此篇文章持续更新…&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://www.zhaohang.site/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="html" scheme="http://www.zhaohang.site/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令(转)</title>
    <link href="http://www.zhaohang.site/2017/08/10/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.zhaohang.site/2017/08/10/git常用命令/</id>
    <published>2017-08-10T05:48:03.000Z</published>
    <updated>2018-01-05T13:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>git</code> 是一种分布式的版本管理工具<br><code>github</code> 是基于 <code>git</code> 开发的一种图形化的 <code>git</code> 管理软件,支持免费的开源项目托管,是最大的开源社区</p><a id="more"></a><p>本文转载至<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">阮一峰</a></p><h3 id="git-名词解释与命令说明"><a href="#git-名词解释与命令说明" class="headerlink" title="git 名词解释与命令说明"></a>git 名词解释与命令说明</h3><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><hr><h4 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init [project-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载一个项目和它的整个代码历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [url]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载一个项目分支 默认主机名origin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> -b [dev] [url]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载一个项目 选择其他主机名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> -o [origin] [url]</span></span><br></pre></td></tr></table></figure><hr><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [dir]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -p</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git mv [file-original] [file-renamed]</span></span><br></pre></td></tr></table></figure><hr><h4 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [dir]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -p</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git mv [file-original] [file-renamed]</span></span><br></pre></td></tr></table></figure><hr><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit [file1] [file2] ... -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1] [file2] ...</span></span><br></pre></td></tr></table></figure><hr><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支和远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch] [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --track [branch] [remote-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定分支，并更新工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到上一个分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并指定分支到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择一个commit，合并进当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure><hr><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在当前commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag] [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/[tagName]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看tag信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交指定tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --tags</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向某个tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch] [tag]</span></span><br></pre></td></tr></table></figure><hr><h4 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示有变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的版本历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索提交历史，根据关键词</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，其<span class="string">"提交说明"</span>必须符合搜索条件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git whatchanged [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件相关的每一次diff</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示过去5次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和工作区的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和上一个commit的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示两次提交之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示今天你写了多少行代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交的元数据和内容变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交发生变化的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交时，某个文件的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的最近几次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure><hr><h4 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载远程仓库的所有变动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch [remote]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个远程仓库的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show [remote]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加一个新的远程仓库，并命名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add [shortname] [url]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除一个远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote rm [shortname]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull [remote] [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传本地指定分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] &lt;本地分支名&gt;:&lt;远程分支名&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --force</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送所有分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --all</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定的远程分支(等同于推送空分支)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] :master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --delete master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置默认主机,用于省略 [remote]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br></pre></td></tr></table></figure><hr><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的指定文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [commit] [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的所有文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git revert [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure><hr><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>关于分支的一些约定:</p><ul><li>默认 master 是对外主分支</li><li>dev 是公共开发分支</li><li>修补 bug: 从 dev 创建 fixbug-0.1 分支,修补结束后 merge 回 dev 分支并删除 fixbug 分支</li><li>添加功能: 从 dev 创建 feature-x 分支,开发结束后 merge 回 dev 分支并删除 fixbug 分支</li><li>发布预览: 从 dev 创建 release-1.2 分支,结束后 merge 回 dev 分支并删除 fixbug 分支</li></ul><hr><p>关于 commit 的一些约定:</p><ul><li>feat：新功能（feature）</li><li>fix：修补 bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改 bug 的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul><p><a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">Commitizen</a>是一个撰写合格 Commit message 的工具。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g commitizen</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行下面的命令，使其支持 Angular 的 Commit message 格式</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> commitizen init cz-conventional-changelog --save --save-exact</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成一个可供发布的压缩包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git archive</span></span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决 Git refusing to merge unrelated histories 问题</span></span><br><span class="line">$ git pull origin <span class="keyword">master</span> <span class="title">--allow-unrelated-histories</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;git&lt;/code&gt; 是一种分布式的版本管理工具&lt;br&gt;&lt;code&gt;github&lt;/code&gt; 是基于 &lt;code&gt;git&lt;/code&gt; 开发的一种图形化的 &lt;code&gt;git&lt;/code&gt; 管理软件,支持免费的开源项目托管,是最大的开源社区&lt;/p&gt;
    
    </summary>
    
      <category term="杂货铺" scheme="http://www.zhaohang.site/categories/%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
      <category term="git" scheme="http://www.zhaohang.site/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>博客开通</title>
    <link href="http://www.zhaohang.site/2017/08/01/%E5%8D%9A%E5%AE%A2%E5%BC%80%E9%80%9A/"/>
    <id>http://www.zhaohang.site/2017/08/01/博客开通/</id>
    <published>2017-08-01T10:37:57.000Z</published>
    <updated>2018-01-05T13:32:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>本博客使用<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>搭建,主题使用<a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">Cho</a><br>搭建于<a href="https://pages.github.com/" target="_blank" rel="noopener">github pages</a>,感谢开源社区</p><a id="more"></a><h2 id="hexo框架说明"><a href="#hexo框架说明" class="headerlink" title="hexo框架说明"></a><code>hexo</code>框架说明</h2><p><strong><code>hexo</code>依赖于 node 与 git</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h3 id="新建目录"><a href="#新建目录" class="headerlink" title="新建目录"></a>新建目录</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── <span class="selector-tag">_config</span><span class="selector-class">.yml</span>(配置文件)</span><br><span class="line">├── <span class="selector-tag">package</span><span class="selector-class">.json</span></span><br><span class="line">├── <span class="selector-tag">scaffolds</span>(新建文件模板)</span><br><span class="line">├── <span class="selector-tag">source</span>(资源存放文件夹,ico和CNAME可放此处)</span><br><span class="line">├── <span class="selector-tag">public</span>(生成的静态文件放在这里)</span><br><span class="line">├── <span class="selector-class">.deploy_git</span>(服务器开启时启用的文件放在这里)</span><br><span class="line">|   ├── <span class="selector-tag">_drafts</span>(草稿文件,默认忽略)</span><br><span class="line">|   └── <span class="selector-tag">_posts</span>(文章文件夹)</span><br><span class="line">└── <span class="selector-tag">themes</span>(hexo 根据主题生成静态页面)</span><br></pre></td></tr></table></figure><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a><code>_config.yml</code></h3><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">title</td><td style="text-align:center">标题</td></tr><tr><td style="text-align:center">subtitle</td><td style="text-align:center">副标题</td></tr><tr><td style="text-align:center">description</td><td style="text-align:center">网站描述</td></tr><tr><td style="text-align:center">author</td><td style="text-align:center"> 名字</td></tr><tr><td style="text-align:center">language</td><td style="text-align:center">语言</td></tr><tr><td style="text-align:center">timezone</td><td style="text-align:center">时区</td></tr><tr><td style="text-align:center">url</td><td style="text-align:center">网址</td></tr><tr><td style="text-align:center">root</td><td style="text-align:center">根目录</td></tr><tr><td style="text-align:center">permalink</td><td style="text-align:center">文章的 <code>永久链接</code> 格式</td></tr><tr><td style="text-align:center">theme</td><td style="text-align:center">当前主题名称</td></tr><tr><td style="text-align:center">deploy</td><td style="text-align:center">扩展</td></tr><tr><td style="text-align:center">default_layout</td><td style="text-align:center">预设布局(默认<code>post</code>)</td></tr></tbody></table><h3 id="部署说明"><a href="#部署说明" class="headerlink" title="部署说明"></a>部署说明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> [layout] &lt;title&gt;  <span class="comment">// 无 `layout` 使用默认设置</span></span><br><span class="line">hexo generate (-d -w) <span class="comment">// 文件生成后立即部署网站|监视文件变动</span></span><br><span class="line">hexo g <span class="comment">//简写</span></span><br><span class="line">hexo publish [layout] &lt;filename&gt;  <span class="comment">// 发表草稿</span></span><br><span class="line">hexo server <span class="comment">// 开启热服务器</span></span><br><span class="line">hexo deploy <span class="comment">//部署</span></span><br><span class="line">hexo d  hexo s 简写</span><br><span class="line">hexo clean  <span class="comment">//清理缓存</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span>  <span class="comment">#依次执行每个deploy</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="attr">https://github.com/blossom91/blossom91.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a><code>Front-matter</code></h3><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">layout</td><td style="text-align:center">布局</td></tr><tr><td style="text-align:center">title</td><td style="text-align:center">标题</td></tr><tr><td style="text-align:center">date</td><td style="text-align:center">日期</td></tr><tr><td style="text-align:center">updated</td><td style="text-align:center">更新日期</td></tr><tr><td style="text-align:center">comments</td><td style="text-align:center">开启评论功能</td></tr><tr><td style="text-align:center">categories</td><td style="text-align:center">分类(有时序性)</td></tr><tr><td style="text-align:center">tags</td><td style="text-align:center">标签(无顺序性)</td></tr><tr><td style="text-align:center">toc</td><td style="text-align:center">theme 特有  目录显示</td></tr><tr><td style="text-align:center">mathjax</td><td style="text-align:center">theme 特有 数学符号</td></tr><tr><td style="text-align:center">layout: timeline</td><td style="text-align:center">theme 特有 时间线</td></tr></tbody></table><p><br></p><h2 id="Cho-主题说明"><a href="#Cho-主题说明" class="headerlink" title="Cho 主题说明"></a><code>Cho</code> 主题说明</h2><p>感谢<a href="https://www.haomwei.com/" target="_blank" rel="noopener">屠城</a>优化的<code>cho</code>模板</p><p>评论系统使用<a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">gitment</a>感谢<a href="https://imsun.net/posts/gitment-introduction/" target="_blank" rel="noopener">孙士权</a>的创意</p><h3 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h3><p>文章内容中插入<code>&lt;!--more--&gt;</code>可以隐藏后面的内容,未设置自动引用第一段显示</p><h3 id="添加页面"><a href="#添加页面" class="headerlink" title="添加页面"></a>添加页面</h3><p>在根 source 目录下建立相应名称的文件夹，然后在文件夹中建立 index.md 文件<br><code>front-matter</code>设置<code>layout</code>:<code>page</code>|<code>single-column</code>(单页面)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本博客使用&lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo&lt;/a&gt;搭建,主题使用&lt;a href=&quot;https://www.haomwei.com/technology/maupassant-hexo.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cho&lt;/a&gt;&lt;br&gt;搭建于&lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github pages&lt;/a&gt;,感谢开源社区&lt;/p&gt;
    
    </summary>
    
      <category term="杂货铺" scheme="http://www.zhaohang.site/categories/%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
      <category term="hexo" scheme="http://www.zhaohang.site/tags/hexo/"/>
    
  </entry>
  
</feed>
