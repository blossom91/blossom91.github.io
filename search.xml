<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[go语言学习]]></title>
      <url>/2017/12/19/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p><code>go</code>的学习,感谢<a href="https://gobyexample.xgwang.me/" target="_blank" rel="noopener">Go By Example</a>、<a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md" target="_blank" rel="noopener">go网络编程</a>与<a href="http://books.studygolang.com/The-Golang-Standard-Library-by-Example/" target="_blank" rel="noopener">go语言标准库</a><br>随着学习的深入,此文章持续更新…</p>
<a id="more"></a>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span> = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">var</span> b, c <span class="keyword">int</span> =  <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">f := <span class="string">"world"</span></span><br><span class="line"><span class="comment">// 常量</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="string">"hello, world"</span></span><br></pre></td></tr></table></figure>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">3</span> &#123;</span><br><span class="line">	fmt.Println(i)</span><br><span class="line">	i = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 经典的初始化/条件/后续形式 for 循环。 同样也支持跳过循环</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">7</span>; j &lt;= <span class="number">9</span>; j++ &#123;</span><br><span class="line">	fmt.Println(j)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不带条件的 for 循环将一直执行，直到在循环体内使用了 break 或者 return 来跳出循环。</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"loop"</span>)</span><br><span class="line">	<span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="if-else"><a href="#if-else" class="headerlink" title="if/else"></a>if/else</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">7</span>%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"7 is even"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"7 is odd"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在条件语句之前可以有一个语句；任何在这里声明的变量都可以在所有的条件分支中使用。</span></span><br><span class="line"><span class="keyword">if</span> num := <span class="number">9</span>; num &lt; <span class="number">0</span> &#123;</span><br><span class="line">	fmt.Println(num, <span class="string">"is negative"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> num &lt; <span class="number">10</span> &#123;</span><br><span class="line">	fmt.Println(num, <span class="string">"has 1 digit"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(num, <span class="string">"has multiple digits"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个 case 语句中，你可以使用逗号来分隔多个表达式。在这个例子中，我们很好的使用了可选的default 分支。</span></span><br><span class="line"><span class="keyword">switch</span> time.Now().Weekday() &#123;</span><br><span class="line"><span class="keyword">case</span> time.Saturday, time.Sunday:</span><br><span class="line">	fmt.Println(<span class="string">"it's the weekend"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	fmt.Println(<span class="string">"it's a weekday"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不带表达式的 switch 是实现 if/else 逻辑的另一种方式。这里展示了 case 表达式是如何使用非常量的。</span></span><br><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">	fmt.Println(<span class="string">"it's before noon"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	fmt.Println(<span class="string">"it's after noon"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>strings.Contains(&quot;test&quot;, &quot;es&quot;)</code></td>
<td style="text-align:left">是否包含:<code>true</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.Count(&quot;test&quot;, &quot;t&quot;)</code></td>
<td style="text-align:left">包含数量:<code>2</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.HasPrefix(&quot;test&quot;, &quot;te&quot;)</code></td>
<td style="text-align:left">前缀:<code>true</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.HasSuffix(&quot;test&quot;, &quot;st&quot;)</code></td>
<td style="text-align:left">后缀:<code>true</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.Index(&quot;test&quot;, &quot;e&quot;)</code></td>
<td style="text-align:left">index:<code>1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.Join([]string{&quot;a&quot;, &quot;b&quot;, &quot;b&quot;}, &quot;-&quot;)</code></td>
<td style="text-align:left">join:<code>a-b-b</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.Repeat(&quot;a&quot;, 5)</code></td>
<td style="text-align:left">复制:<code>aaaaa</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.Replace(&quot;foo&quot;, &quot;o&quot;, &quot;0&quot;, -1)</code></td>
<td style="text-align:left">替换:<code>f00</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.Replace(&quot;foo&quot;, &quot;o&quot;, &quot;0&quot;, 1)</code></td>
<td style="text-align:left">替换1次:<code>f0o</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.Split(&quot;a-b-c-d-e&quot;, &quot;-&quot;)</code></td>
<td style="text-align:left">split:<code>[a b c d e]</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.ToLower(&quot;TEST&quot;)</code></td>
<td style="text-align:left">转小写:<code>test</code></td>
</tr>
<tr>
<td style="text-align:left"><code>strings.ToUpper(&quot;test&quot;)</code></td>
<td style="text-align:left">转大写:<code>TEST</code></td>
</tr>
<tr>
<td style="text-align:left"><code>len(&quot;hello&quot;)</code></td>
<td style="text-align:left">长度:<code>5</code></td>
</tr>
<tr>
<td style="text-align:left"><code>&quot;hello&quot;[1]</code></td>
<td style="text-align:left">索引取值:<code>101</code></td>
</tr>
</tbody>
</table>
<hr>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// fmt.Printf  通过 os.Stdout打印格式化的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Sprintf 格式化并返回一个字符串而不带任何输出</span></span><br><span class="line">s := fmt.Sprintf(<span class="string">"a %s"</span>, <span class="string">"string"</span>)</span><br><span class="line">fmt.Println(s)   <span class="comment">// a string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Fprintf 格式化并输出到 io.Writers而不是 os.Stdout</span></span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"an %s\n"</span>, <span class="string">"error"</span>)  <span class="comment">// an error</span></span><br><span class="line"></span><br><span class="line">p := point&#123;x:<span class="number">1</span>, y:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%v\n&quot;, p)</code></td>
<td style="text-align:left">打印结构体<code>{1 2}</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%+v\n&quot;, p)</code></td>
<td style="text-align:left">打印结构体的字段名<code>{x:1 y:2}</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%#v\n&quot;, p)</code></td>
<td style="text-align:left">打印Go 语法表示<code>main.point{x:1, y:2}</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%T\n&quot;, p)</code></td>
<td style="text-align:left">打印值的类型<code>main.point</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%t\n&quot;, true)</code></td>
<td style="text-align:left">格式化布尔值<code>true</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%d\n&quot;, 123)</code></td>
<td style="text-align:left">整数标准的十进制格式化<code>123</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%b\n&quot;, 14)</code></td>
<td style="text-align:left">整数二进制<code>1110</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%c\n&quot;, 33)</code></td>
<td style="text-align:left">整数输出给定整数的对应字符<code>!</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%x\n&quot;, 456)</code></td>
<td style="text-align:left">整数十六进制<code>1c8</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%f\n&quot;, 78.9)</code></td>
<td style="text-align:left">浮点数十进制格式化<code>78.900000</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%e\n&quot;, 123400000.0)</code></td>
<td style="text-align:left">浮点型格式化科学技科学记数法<code>1.234000e+08</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%E\n&quot;, 123400000.0)</code></td>
<td style="text-align:left">浮点型格式化科学技科学记数法<code>1.234000E+08</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%s\n&quot;, &quot;\&quot;string\&quot;&quot;)</code></td>
<td style="text-align:left">基本的字符串输出<code>&quot;string&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%q\n&quot;, &quot;\&quot;string\&quot;&quot;)</code></td>
<td style="text-align:left">Go 源代码中那样带有双引号的输出<code>&quot;\&quot;string\&quot;&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%x\n&quot;, &quot;hex this&quot;)</code></td>
<td style="text-align:left">base-16 编码的字符串<code>6865782074686973</code></td>
</tr>
<tr>
<td style="text-align:left"><code>fmt.Printf(&quot;%p\n&quot;, &amp;p)</code></td>
<td style="text-align:left">输出一个指针的值<code>0x42135100</code></td>
</tr>
</tbody>
</table>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当输出数字的时候，你将经常想要控制输出结果的宽度和精度，可以使用在 % 后面使用数字来控制输出宽度。默认结果使用右对齐并且通过空格来填充空白部分。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%6d|%6d|\n"</span>, <span class="number">12</span>, <span class="number">345</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也可以指定浮点型的输出宽度，同时也可以通过 宽度.精度 的语法来指定输出的精度。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%6.2f|%6.2f|\n"</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要左对齐，使用 - 标志。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%-6.2f|%-6.2f|\n"</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也许也想控制字符串输出时的宽度，特别是要确保他们在类表格输出时的对齐。这是基本的右对齐宽度表示。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%6s|%6s|\n"</span>, <span class="string">"foo"</span>, <span class="string">"b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要左对齐，和数字一样，使用 - 标志。</span></span><br><span class="line">fmt.Printf(<span class="string">"|%-6s|%-6s|\n"</span>, <span class="string">"foo"</span>, <span class="string">"b"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里我们创建了一个数组 a 来存放刚好 5 个 int。元素的类型和长度都是数组类型的一部分。数组默认是零值的，对于 int 数组来说也就是 0。</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(<span class="string">"emp:"</span>, a)</span><br><span class="line"><span class="comment">// 我们可以使用 array[index] = value 语法来设置数组指定位置的值，或者用 array[index] 得到值。</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(<span class="string">"set:"</span>, a)</span><br><span class="line">fmt.Println(<span class="string">"get:"</span>, a[<span class="number">4</span>])</span><br><span class="line"><span class="comment">// 使用内置函数 len 返回数组的长度</span></span><br><span class="line">fmt.Println(<span class="string">"len:"</span>, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="comment">// 使用这个语法在一行内初始化一个数组</span></span><br><span class="line">b := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"dcl:"</span>, b)</span><br><span class="line"><span class="comment">// 数组的存储类型是单一的，但是你可以组合这些数据来构造多维的数据结构。</span></span><br><span class="line"><span class="keyword">var</span> twoD [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">		twoD[i][j] = i + j</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"2d: "</span>, twoD)</span><br></pre></td></tr></table></figure>
<h3 id="切片slice"><a href="#切片slice" class="headerlink" title="切片slice"></a>切片<code>slice</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不像数组，slice 的类型仅由它所包含的元素决定（不像数组中还需要元素的个数）。要创建一个长度非零的空slice，需要使用内建的方法 make。这里我们创建了一个长度为3的 string 类型 slice（初始化为零值）。</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">"emp:"</span>, s)</span><br><span class="line"><span class="comment">// 我们可以和数组一样设置和得到值</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">"a"</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">"b"</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="string">"c"</span></span><br><span class="line">fmt.Println(<span class="string">"set:"</span>, s)</span><br><span class="line">fmt.Println(<span class="string">"get:"</span>, s[<span class="number">2</span>])</span><br><span class="line"><span class="comment">// 如你所料，len 返回 slice 的长度</span></span><br><span class="line">fmt.Println(<span class="string">"len:"</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="comment">// 作为基本操作的补充，slice 支持比数组更多的操作。其中一个是内建的 append，它返回一个包含了一个或者多个新值的 slice。注意我们接受返回由 append返回的新的 slice 值。</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"d"</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">"e"</span>, <span class="string">"f"</span>)</span><br><span class="line">fmt.Println(<span class="string">"apd:"</span>, s)</span><br><span class="line"><span class="comment">// Slice 也可以被 copy。这里我们创建一个空的和 s 有相同长度的 slice c，并且将 s 复制给 c。</span></span><br><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="built_in">copy</span>(c, s)</span><br><span class="line">fmt.Println(<span class="string">"cpy:"</span>, c)</span><br><span class="line"><span class="comment">// Slice 支持通过 slice[low:high] 语法进行“切片”操作。例如，这里得到一个包含元素 s[2], s[3],s[4] 的 slice。</span></span><br><span class="line">l := s[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Println(<span class="string">"sl1:"</span>, l)</span><br><span class="line"><span class="comment">// 这个 slice 从 s[0] 到（但是包含）s[5]。</span></span><br><span class="line">l = s[:<span class="number">5</span>]</span><br><span class="line">fmt.Println(<span class="string">"sl2:"</span>, l)</span><br><span class="line"><span class="comment">// 这个 slice 从（包含）s[2] 到 slice 的后一个值。</span></span><br><span class="line">l = s[<span class="number">2</span>:]</span><br><span class="line">fmt.Println(<span class="string">"sl3:"</span>, l)</span><br><span class="line"><span class="comment">// 我们可以在一行代码中声明并初始化一个 slice 变量。</span></span><br><span class="line">t := []<span class="keyword">string</span>&#123;<span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"dcl:"</span>, t)</span><br><span class="line"><span class="comment">// Slice 可以组成多维数据结构。内部的 slice 长度可以不同，这和多位数组不同。</span></span><br><span class="line">twoD := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">	innerLen := i + <span class="number">1</span></span><br><span class="line">	twoD[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, innerLen)</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; innerLen; j++ &#123;</span><br><span class="line">		twoD[i][j] = i + j</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"2d: "</span>, twoD)</span><br></pre></td></tr></table></figure>
<h3 id="关系数组map"><a href="#关系数组map" class="headerlink" title="关系数组map"></a>关系数组<code>map</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要创建一个空 map，需要使用内建的 make:make(map[key-type]val-type).</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 使用典型的 make[key] = val 语法来设置键值对。</span></span><br><span class="line">m[<span class="string">"k1"</span>] = <span class="number">7</span></span><br><span class="line">m[<span class="string">"k2"</span>] = <span class="number">13</span></span><br><span class="line"><span class="comment">// 使用例如 Println 来打印一个 map 将会输出所有的键值对。</span></span><br><span class="line">fmt.Println(<span class="string">"map:"</span>, m)</span><br><span class="line"><span class="comment">// 使用 name[key] 来获取一个键的值</span></span><br><span class="line">v1 := m[<span class="string">"k1"</span>]</span><br><span class="line">fmt.Println(<span class="string">"v1: "</span>, v1)</span><br><span class="line"><span class="comment">// 当对一个 map 调用内建的 len 时，返回的是键值对数目</span></span><br><span class="line">fmt.Println(<span class="string">"len:"</span>, <span class="built_in">len</span>(m))</span><br><span class="line"><span class="comment">// 内建的 delete 可以从一个 map 中移除键值对</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"k2"</span>)</span><br><span class="line">fmt.Println(<span class="string">"map:"</span>, m)</span><br><span class="line"><span class="comment">// 当从一个 map 中取值时，可选的第二返回值指示这个键是在这个 map 中。这可以用来消除键不存在和键有零值，像 0 或者 "" 而产生的歧义。</span></span><br><span class="line">num, prs := m[<span class="string">"k1"</span>]</span><br><span class="line">fmt.Println(<span class="string">"prs:"</span>, prs, num)</span><br><span class="line"><span class="comment">// 你也可以通过这个语法在同一行申明和初始化一个新的map。</span></span><br><span class="line">n := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"foo"</span>: <span class="number">1</span>, <span class="string">"bar"</span>: <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"map:"</span>, n)</span><br></pre></td></tr></table></figure>
<h3 id="遍历Rang"><a href="#遍历Rang" class="headerlink" title="遍历Rang"></a>遍历<code>Rang</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里我们使用 range 来统计一个 slice 的元素个数。数组也可以采用这种方法。</span></span><br><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">	sum += num</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"sum:"</span>, sum)</span><br><span class="line"><span class="comment">// range 在数组和 slice 中都同样提供每个项的索引和值。上面我们不需要索引，所以我们使用 空值定义符_ 来忽略它。有时候我们实际上是需要这个索引的。</span></span><br><span class="line"><span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">	<span class="keyword">if</span> num == <span class="number">3</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"index:"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// range 在 map 中迭代键值对。</span></span><br><span class="line">kvs := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"a"</span>: <span class="string">"apple"</span>, <span class="string">"b"</span>: <span class="string">"banana"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s -&gt; %s\n"</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// range 在字符串中迭代 unicode 编码。第一个返回值是rune 的起始字节位置，然后第二个是 rune 自己。</span></span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> <span class="string">"go"</span> &#123;</span><br><span class="line">	fmt.Println(i, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 首先我们来看一下基本数据类型到 JSON 字符串的编码过程。这里是一些原子值的例子。</span></span><br><span class="line">	bolB, _ := json.Marshal(<span class="literal">true</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(bolB))</span><br><span class="line">	intB, _ := json.Marshal(<span class="number">1</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(intB))</span><br><span class="line">	fltB, _ := json.Marshal(<span class="number">2.34</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(fltB))</span><br><span class="line">	strB, _ := json.Marshal(<span class="string">"gopher"</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(strB))</span><br><span class="line">	<span class="comment">// 这里是一些切片和 map 编码成 JSON 数组和对象的例子。</span></span><br><span class="line">	slcD := []<span class="keyword">string</span>&#123;<span class="string">"apple"</span>, <span class="string">"peach"</span>, <span class="string">"pear"</span>&#125;</span><br><span class="line">	slcB, _ := json.Marshal(slcD)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(slcB))</span><br><span class="line">	mapD := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"apple"</span>: <span class="number">5</span>, <span class="string">"lettuce"</span>: <span class="number">7</span>&#125;</span><br><span class="line">	mapB, _ := json.Marshal(mapD)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(mapB))</span><br><span class="line">	<span class="comment">// JSON 包可以自动的编码你的自定义类型。编码仅输出可导出的字段，并且默认使用他们的名字作为 JSON 数据的键。</span></span><br><span class="line">	res1D := &amp;Response1&#123;</span><br><span class="line">		Page:   <span class="number">1</span>,</span><br><span class="line">		Fruits: []<span class="keyword">string</span>&#123;<span class="string">"apple"</span>, <span class="string">"peach"</span>, <span class="string">"pear"</span>&#125;&#125;</span><br><span class="line">	res1B, _ := json.Marshal(res1D)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(res1B))</span><br><span class="line">	<span class="comment">// 你可以给结构字段声明标签来自定义编码的 JSON 数据键名称。在上面 Response2 的定义可以作为这个标签这个的一个例子。</span></span><br><span class="line">	res2D := Response2&#123;</span><br><span class="line">		Page:   <span class="number">1</span>,</span><br><span class="line">		Fruits: []<span class="keyword">string</span>&#123;<span class="string">"apple"</span>, <span class="string">"peach"</span>, <span class="string">"pear"</span>&#125;&#125;</span><br><span class="line">	res2B, _ := json.Marshal(res2D)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(res2B))</span><br><span class="line">	<span class="comment">// 现在来看看解码 JSON 数据为 Go 值的过程。这里是一个普通数据结构的解码例子。</span></span><br><span class="line">	byt := []<span class="keyword">byte</span>(<span class="string">`&#123;"num":6.13,"strs":["a","b"]&#125;`</span>)</span><br><span class="line">	<span class="comment">// 我们需要提供一个 JSON 包可以存放解码数据的变量。这里的 map[string]interface&#123;&#125; 将保存一个 string 为键，值为任意值的map。</span></span><br><span class="line">	<span class="keyword">var</span> dat <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 这里就是实际的解码和相关的错误检查。</span></span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal(byt, &amp;dat); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(dat)</span><br><span class="line">	<span class="comment">// 为了使用解码 map 中的值，我们需要将他们进行适当的类型转换。例如这里我们将 num 的值转换成 float64类型。</span></span><br><span class="line">	num := dat[<span class="string">"num"</span>].(<span class="keyword">float64</span>)</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">	<span class="comment">// 访问嵌套的值需要一系列的转化。</span></span><br><span class="line">	strs := dat[<span class="string">"strs"</span>].([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	str1 := strs[<span class="number">0</span>].(<span class="keyword">string</span>)</span><br><span class="line">	fmt.Println(str1)</span><br><span class="line">	<span class="comment">// 我们也可以解码 JSON 值到自定义类型。这个功能的好处就是可以为我们的程序带来额外的类型安全加强，并且消除在访问数据时的类型断言。</span></span><br><span class="line">	str := <span class="string">`&#123;"page": 1, "fruits": ["apple", "peach"]&#125;`</span></span><br><span class="line">	res := &amp;Response2&#123;&#125;</span><br><span class="line">	json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;res)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">	fmt.Println(res.Fruits[<span class="number">0</span>])</span><br><span class="line">	<span class="comment">// 在上面的例子中，我们经常使用 byte 和 string 作为使用标准输出时数据和 JSON 表示之间的中间值。我们也可以和os.Stdout 一样，直接将 JSON 编码直接输出至 os.Writer流中，或者作为 HTTP 响应体。</span></span><br><span class="line">	enc := json.NewEncoder(os.Stdout)</span><br><span class="line">	d := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"apple"</span>: <span class="number">5</span>, <span class="string">"lettuce"</span>: <span class="number">7</span>&#125;</span><br><span class="line">	enc.Encode(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是一个函数，接受两个 int 并且以 int 返回它们的和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// Go 需要明确的返回值，例如，它不会自动返回最后一个表达式的值</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 正如你期望的那样，通过 name(args) 来调用一个函数，</span></span><br><span class="line">	res := plus(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	fmt.Println(<span class="string">"1+2 ="</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (int, int) 在这个函数中标志着这个函数返回 2 个 int。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">vals</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span>, <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里我们通过多赋值 操作来使用这两个不同的返回值。</span></span><br><span class="line">	a, b := vals()</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	<span class="comment">// 如果你仅仅想返回值的一部分的话，你可以使用空白定义符 _。</span></span><br><span class="line">	_, c := vals()</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变参函数"><a href="#变参函数" class="headerlink" title="变参函数"></a>变参函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数使用任意数目的 int 作为参数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Print(nums, <span class="string">" "</span>)</span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		total += num</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(total)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 变参函数使用常规的调用方式，除了参数比较特殊。</span></span><br><span class="line">	sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 如果你的 slice 已经有了多个值，想把它们作为变参使用，你要这样调用 func(slice...)。</span></span><br><span class="line">	nums := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	sum(nums...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个 intSeq 函数返回另一个在 intSeq 函数体内定义的匿名函数。这个返回的函数使用闭包的方式 隐藏 变量 i。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSeq</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 我们调用 intSeq 函数，将返回值（也是一个函数）赋给nextInt。这个函数的值包含了自己的值 i，这样在每次调用 nextInt 时都会更新 i 的值。</span></span><br><span class="line">	nextInt := intSeq()</span><br><span class="line">	<span class="comment">// 通过多次调用 nextInt 来看看闭包的效果。</span></span><br><span class="line">	fmt.Println(nextInt())</span><br><span class="line">	fmt.Println(nextInt())</span><br><span class="line">	fmt.Println(nextInt())</span><br><span class="line">	<span class="comment">// 为了确认这个状态对于这个特定的函数是唯一的，我们重新创建并测试一下。</span></span><br><span class="line">	newInts := intSeq()</span><br><span class="line">	fmt.Println(newInts())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// face 函数在到达 face(0) 前一直调用自身。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fact</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n * fact(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(fact(<span class="number">7</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们将通过两个函数：zeroval 和 zeroptr 来比较指针和值类型的不同。zeroval 有一个 int 型参数，所以使用值传递。zeroval 将从调用它的那个函数中得到一个 ival形参的拷贝。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zeroval</span><span class="params">(ival <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	ival = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zeroptr 有一和上面不同的 *int 参数，意味着它用了一个 int指针。函数体内的 *iptr 接着解引用 这个指针，从它内存地址得到这个地址对应的当前值。对一个解引用的指针赋值将会改变这个指针引用的真实地址的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zeroptr</span><span class="params">(iptr *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	*iptr = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	fmt.Println(<span class="string">"initial:"</span>, i)</span><br><span class="line">	zeroval(i)</span><br><span class="line">	fmt.Println(<span class="string">"zeroval:"</span>, i)</span><br><span class="line">	<span class="comment">// 通过 &amp;i 语法来取得 i 的内存地址，例如一个变量i 的指针。</span></span><br><span class="line">	zeroptr(&amp;i)</span><br><span class="line">	fmt.Println(<span class="string">"zeroptr:"</span>, i)</span><br><span class="line">	<span class="comment">// 指针也是可以被打印的。</span></span><br><span class="line">	fmt.Println(<span class="string">"pointer:"</span>, &amp;i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zeroval 在 main 函数中不能改变 i 的值，但是zeroptr 可以，因为它有一个这个变量的内存地址的引用。</span></span><br></pre></td></tr></table></figure>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用这个语法创建了一个新的结构体元素。</span></span><br><span class="line">	fmt.Println(person&#123;<span class="string">"Bob"</span>, <span class="number">20</span>&#125;)</span><br><span class="line">	<span class="comment">// 你可以在初始化一个结构体元素时指定字段名字。</span></span><br><span class="line">	fmt.Println(person&#123;name: <span class="string">"Alice"</span>, age: <span class="number">30</span>&#125;)</span><br><span class="line">	<span class="comment">// 省略的字段将被初始化为零值。</span></span><br><span class="line">	fmt.Println(person&#123;name: <span class="string">"Fred"</span>&#125;)</span><br><span class="line">	<span class="comment">// &amp; 前缀生成一个结构体指针。</span></span><br><span class="line">	fmt.Println(&amp;person&#123;name: <span class="string">"Ann"</span>, age: <span class="number">40</span>&#125;)</span><br><span class="line">	<span class="comment">// 使用点来访问结构体字段。</span></span><br><span class="line">	s := person&#123;name: <span class="string">"Sean"</span>, age: <span class="number">50</span>&#125;</span><br><span class="line">	fmt.Println(s.name)</span><br><span class="line">	<span class="comment">// 也可以对结构体指针使用. - 指针会被自动解引用。</span></span><br><span class="line">	sp := &amp;s</span><br><span class="line">	fmt.Println(sp.age)</span><br><span class="line">	<span class="comment">// 结构体是可变的。</span></span><br><span class="line">	sp.age = <span class="number">51</span></span><br><span class="line">	fmt.Println(sp.age)</span><br><span class="line">	fmt.Println(s.age) <span class="comment">// 51</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 area 方法有一个接收器类型 rect。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rect)</span> <span class="title">area</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以为值类型或者指针类型的接收器定义方法。这里是一个值类型接收器的例子。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>*r.width + <span class="number">2</span>*r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := rect&#123;width: <span class="number">10</span>, height: <span class="number">5</span>&#125;</span><br><span class="line">	<span class="comment">// 这里我们调用上面为结构体定义的两个方法。</span></span><br><span class="line">	fmt.Println(<span class="string">"area: "</span>, r.area())</span><br><span class="line">	fmt.Println(<span class="string">"perim:"</span>, r.perim())</span><br><span class="line">	<span class="comment">// Go 自动处理方法调用时的值和指针之间的转化。你可以使用指针来调用方法来避免在方法调用时产生一个拷贝，或者让方法能够改变接受的数据。</span></span><br><span class="line">	rp := &amp;r</span><br><span class="line">	fmt.Println(<span class="string">"area: "</span>, rp.area())</span><br><span class="line">	fmt.Println(<span class="string">"perim:"</span>, rp.perim())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口 是方法特征的命名集合。</span></span><br><span class="line"><span class="comment">// 这里是一个几何体的基本接口。</span></span><br><span class="line"><span class="keyword">type</span> geometry <span class="keyword">interface</span> &#123;</span><br><span class="line">	area() <span class="keyword">float64</span></span><br><span class="line">	perim() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在我们的例子中，我们将让 rect 和 circle 实现这个接口</span></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要在 Go 中实现一个接口，我们只需要实现接口中的所有方法。这里我们让 rect 实现了 geometry 接口。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>*r.width + <span class="number">2</span>*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// circle 的实现。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c circle)</span> <span class="title">perim</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一个变量的是接口类型，那么我们可以调用这个被命名的接口中的方法。这里有一个一通用的 measure 函数，利用这个特性，它可以用在任何 geometry 上。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">measure</span><span class="params">(g geometry)</span></span> &#123;</span><br><span class="line">	fmt.Println(g)</span><br><span class="line">	fmt.Println(g.area())</span><br><span class="line">	fmt.Println(g.perim())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := rect&#123;width: <span class="number">3</span>, height: <span class="number">4</span>&#125;</span><br><span class="line">	c := circle&#123;radius: <span class="number">5</span>&#125;</span><br><span class="line">	<span class="comment">// 结构体类型 circle 和 rect 都实现了 geometry接口，所以我们可以使用它们的实例作为 measure 的参数。</span></span><br><span class="line">	measure(r)</span><br><span class="line">	measure(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照惯例，错误通常是最后一个返回值并且是 error 类型，一个内建的接口。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(arg <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> arg == <span class="number">42</span> &#123;</span><br><span class="line">		<span class="comment">// errors.New 构造一个使用给定的错误信息的基本error 值。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"can't work with 42"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回错误值为 nil 代表没有错误。</span></span><br><span class="line">	<span class="keyword">return</span> arg + <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过实现 Error 方法来自定义 error 类型是可以的。这里使用自定义错误类型来表示上面的参数错误。</span></span><br><span class="line"><span class="keyword">type</span> argError <span class="keyword">struct</span> &#123;</span><br><span class="line">	arg  <span class="keyword">int</span></span><br><span class="line">	prob <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *argError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d - %s"</span>, e.arg, e.prob)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(arg <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> arg == <span class="number">42</span> &#123;</span><br><span class="line">		<span class="comment">// 在这个例子中，我们使用 &amp;argError 语法来建立一个新的结构体，并提供了 arg 和 prob 这个两个字段的值。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, &amp;argError&#123;arg, <span class="string">"can't work with it"</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arg + <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 下面的两个循环测试了各个返回错误的函数。注意在 if行内的错误检查代码，在 Go 中是一个普遍的用法。</span></span><br><span class="line">	<span class="keyword">for</span> _, i := <span class="keyword">range</span> []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">42</span>&#125; &#123;</span><br><span class="line">		<span class="keyword">if</span> r, e := f1(i); e != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"f1 failed:"</span>, e)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"f1 worked:"</span>, r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, i := <span class="keyword">range</span> []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">42</span>&#125; &#123;</span><br><span class="line">		<span class="keyword">if</span> r, e := f2(i); e != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"f2 failed:"</span>, e)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"f2 worked:"</span>, r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 你如果想在程序中使用一个自定义错误类型中的数据，你需要通过类型断言来得到这个错误类型的实例。</span></span><br><span class="line">	_, e := f2(<span class="number">42</span>)</span><br><span class="line">	<span class="keyword">if</span> ae, ok := e.(*argError); ok &#123;</span><br><span class="line">		fmt.Println(ae.arg)</span><br><span class="line">		fmt.Println(ae.prob)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 排序方法是正对内置数据类型的；这里是一个字符串的例子。注意排序是原地更新的，所以他会改变给定的序列并且不返回一个新值。</span></span><br><span class="line">	strs := []<span class="keyword">string</span>&#123;<span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>&#125;</span><br><span class="line">	sort.Strings(strs)</span><br><span class="line">	fmt.Println(<span class="string">"Strings:"</span>, strs)</span><br><span class="line">	<span class="comment">// 一个 int 排序的例子。</span></span><br><span class="line">	ints := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line">	sort.Ints(ints)</span><br><span class="line">	fmt.Println(<span class="string">"Ints:   "</span>, ints)</span><br><span class="line">	<span class="comment">// 我们也可以使用 sort 来检查一个序列是不是已经是排好序的。</span></span><br><span class="line">	s := sort.IntsAreSorted(ints)</span><br><span class="line">	fmt.Println(<span class="string">"Sorted: "</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了在 Go 中使用自定义函数进行排序，我们需要一个对应的类型。这里我们创建一个为内置 []string 类型的别名的ByLength 类型，</span></span><br><span class="line"><span class="keyword">type</span> ByLength []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在类型中实现了 sort.Interface 的 Len，Less和 Swap 方法，这样我们就可以使用 sort 包的通用Sort 方法了，Len 和 Swap 通常在各个类型中都差不多，Less 将控制实际的自定义排序逻辑。在我们的例子中，我们想按字符串长度增加的顺序来排序，所以这里使用了 len(s[i]) 和 len(s[j])。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByLength)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByLength)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByLength)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s[i]) &lt; <span class="built_in">len</span>(s[j])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一切都准备好了，我们现在可以通过将原始的 fruits 切片转型成 ByLength 来实现我们的自定排序了。然后对这个转型的切片使用 sort.Sort 方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fruits := []<span class="keyword">string</span>&#123;<span class="string">"peach"</span>, <span class="string">"banana"</span>, <span class="string">"kiwi"</span>&#125;</span><br><span class="line">	sort.Sort(ByLength(fruits))</span><br><span class="line">	fmt.Println(fruits)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 我们将在这个网站中使用 panic 来检查预期外的错误。这个是唯一一个为 panic 准备的例子。</span></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"a problem"</span>)</span><br><span class="line">	<span class="comment">// panic 的一个基本用法就是在一个函数返回了错误值但是我们并不知道（或者不想）处理时终止运行。这里是一个在创建一个新文件时返回异常错误时的panic 用法。</span></span><br><span class="line">	_, err := os.Create(<span class="string">"/tmp/file"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们想要创建一个文件，向它进行写操作，然后在结束时关闭它。这里展示了如何通过 defer 来做到这一切。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在 closeFile 后得到一个文件对象，我们使用 defer通过 closeFile 来关闭这个文件。这会在封闭函数（main）结束时执行，就是 writeFile 结束后。</span></span><br><span class="line">	f := createFile(<span class="string">"/tmp/defer.txt"</span>)</span><br><span class="line">	<span class="keyword">defer</span> closeFile(f)</span><br><span class="line">	writeFile(f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createFile</span><span class="params">(p <span class="keyword">string</span>)</span> *<span class="title">os</span>.<span class="title">File</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"creating"</span>)</span><br><span class="line">	f, err := os.Create(p)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">(f *os.File)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"writing"</span>)</span><br><span class="line">	fmt.Fprintln(f, <span class="string">"data"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closeFile</span><span class="params">(f *os.File)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"closing"</span>)</span><br><span class="line">	f.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := fmt.Println</span><br><span class="line">	<span class="comment">// 得到当前时间。</span></span><br><span class="line">	now := time.Now()</span><br><span class="line">	p(now)</span><br><span class="line">	<span class="comment">// 通过提供年月日等信息，你可以构建一个 time。时间总是关联着位置信息，例如时区。</span></span><br><span class="line">	then := time.Date(</span><br><span class="line">		<span class="number">2009</span>, <span class="number">11</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">34</span>, <span class="number">58</span>, <span class="number">651387237</span>, time.UTC)</span><br><span class="line">	p(then)</span><br><span class="line">	<span class="comment">// 你可以提取出时间的各个组成部分。</span></span><br><span class="line">	p(then.Year())</span><br><span class="line">	p(then.Month())</span><br><span class="line">	p(then.Day())</span><br><span class="line">	p(then.Hour())</span><br><span class="line">	p(then.Minute())</span><br><span class="line">	p(then.Second())</span><br><span class="line">	p(then.Nanosecond())</span><br><span class="line">	p(then.Location())</span><br><span class="line">	<span class="comment">// 输出是星期一到日的 Weekday 也是支持的。</span></span><br><span class="line">	p(then.Weekday())</span><br><span class="line">	<span class="comment">// 这些方法来比较两个时间，分别测试一下是否是之前，之后或者是同一时刻，精确到秒。</span></span><br><span class="line">	p(then.Before(now))</span><br><span class="line">	p(then.After(now))</span><br><span class="line">	p(then.Equal(now))</span><br><span class="line">	<span class="comment">// 方法 Sub 返回一个 Duration 来表示两个时间点的间隔时间。</span></span><br><span class="line">	diff := now.Sub(then)</span><br><span class="line">	p(diff)</span><br><span class="line">	<span class="comment">// 我们计算出不同单位下的时间长度值。</span></span><br><span class="line">	p(diff.Hours())</span><br><span class="line">	p(diff.Minutes())</span><br><span class="line">	p(diff.Seconds())</span><br><span class="line">	p(diff.Nanoseconds())</span><br><span class="line">	<span class="comment">// 你可以使用 Add 将时间后移一个时间间隔，或者使用一个 - 来将时间前移一个时间间隔。</span></span><br><span class="line">	p(then.Add(diff))</span><br><span class="line">	p(then.Add(-diff))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 分别使用带 Unix 或者 UnixNano 的 time.Now来获取从自协调世界时起到现在的秒数或者纳秒数。</span></span><br><span class="line">	now := time.Now()</span><br><span class="line">	secs := now.Unix()</span><br><span class="line">	nanos := now.UnixNano()</span><br><span class="line">	fmt.Println(now)</span><br><span class="line">	<span class="comment">// 注意 UnixMillis 是不存在的，所以要得到毫秒数的话，你要自己手动的从纳秒转化一下。</span></span><br><span class="line">	millis := nanos / <span class="number">1000000</span></span><br><span class="line">	fmt.Println(secs)</span><br><span class="line">	fmt.Println(millis)</span><br><span class="line">	fmt.Println(nanos)</span><br><span class="line">	<span class="comment">// 你也可以将协调世界时起的整数秒或者纳秒转化到相应的时间。</span></span><br><span class="line">	fmt.Println(time.Unix(secs, <span class="number">0</span>))</span><br><span class="line">	fmt.Println(time.Unix(<span class="number">0</span>, nanos))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间的格式化与解析"><a href="#时间的格式化与解析" class="headerlink" title="时间的格式化与解析"></a>时间的格式化与解析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := fmt.Println</span><br><span class="line">	<span class="comment">// 这里是一个基本的按照 RFC3339 进行格式化的例子，使用对应模式常量。</span></span><br><span class="line">	t := time.Now()</span><br><span class="line">	p(t.Format(time.RFC3339))</span><br><span class="line">	<span class="comment">// 时间解析使用同 Format 相同的形式值。</span></span><br><span class="line">	t1, e := time.Parse(</span><br><span class="line">		time.RFC3339,</span><br><span class="line">		<span class="string">"2012-11-01T22:08:41+00:00"</span>)</span><br><span class="line">	p(t1)</span><br><span class="line">	<span class="comment">// Format 和 Parse 使用基于例子的形式来决定日期格式，一般你只要使用 time 包中提供的模式常量就行了，但是你也可以实现自定义模式。模式必须使用时间 Mon Jan 2 15:04:05 MST 2006来指定给定时间/字符串的格式化/解析方式。时间一定要按照如下所示：2006为年，15 为小时，Monday 代表星期几，等等。</span></span><br><span class="line">	p(t.Format(<span class="string">"3:04PM"</span>))</span><br><span class="line">	p(t.Format(<span class="string">"Mon Jan _2 15:04:05 2006"</span>))</span><br><span class="line">	p(t.Format(<span class="string">"2006-01-02T15:04:05.999999-07:00"</span>))</span><br><span class="line">	form := <span class="string">"3 04 PM"</span></span><br><span class="line">	t2, e := time.Parse(form, <span class="string">"8 41 PM"</span>)</span><br><span class="line">	p(t2)</span><br><span class="line">	<span class="comment">// 对于纯数字表示的时间，你也可以使用标准的格式化字符串来提出出时间值得组成。</span></span><br><span class="line">	fmt.Printf(<span class="string">"%d-%02d-%02dT%02d:%02d:%02d-00:00\n"</span>,</span><br><span class="line">		t.Year(), t.Month(), t.Day(),</span><br><span class="line">		t.Hour(), t.Minute(), t.Second())</span><br><span class="line">	<span class="comment">// Parse 函数在输入的时间格式不正确是会返回一个错误。</span></span><br><span class="line">	ansic := <span class="string">"Mon Jan _2 15:04:05 2006"</span></span><br><span class="line">	_, e = time.Parse(ansic, <span class="string">"8:41PM"</span>)</span><br><span class="line">	p(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数字解析"><a href="#数字解析" class="headerlink" title="数字解析"></a>数字解析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用 ParseFloat 解析浮点数，这里的 64 表示表示解析的数的位数。</span></span><br><span class="line">	f, _ := strconv.ParseFloat(<span class="string">"1.234"</span>, <span class="number">64</span>)</span><br><span class="line">	fmt.Println(f)</span><br><span class="line">	<span class="comment">// 在使用 ParseInt 解析整形数时，例子中的参数 0 表示自动推断字符串所表示的数字的进制。64 表示返回的整形数是以 64 位存储的。</span></span><br><span class="line">	i, _ := strconv.ParseInt(<span class="string">"123"</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">	fmt.Println(i)</span><br><span class="line">	<span class="comment">// ParseInt 会自动识别出十六进制数。</span></span><br><span class="line">	d, _ := strconv.ParseInt(<span class="string">"0x1c8"</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">	fmt.Println(d)</span><br><span class="line">	<span class="comment">// ParseUint 也是可用的。</span></span><br><span class="line">	u, _ := strconv.ParseUint(<span class="string">"789"</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">	fmt.Println(u)</span><br><span class="line">	<span class="comment">// Atoi 是一个基础的 10 进制整型数转换函数。</span></span><br><span class="line">	k, _ := strconv.Atoi(<span class="string">"135"</span>)</span><br><span class="line">	fmt.Println(k)</span><br><span class="line">	<span class="comment">// 在输入错误时，解析函数会返回一个错误。</span></span><br><span class="line">	_, e := strconv.Atoi(<span class="string">"wat"</span>)</span><br><span class="line">	fmt.Println(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="url解析"><a href="#url解析" class="headerlink" title="url解析"></a>url解析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 我们将解析这个 URL 示例，它包含了一个 scheme，认证信息，主机名，端口，路径，查询参数和片段。</span></span><br><span class="line">	s := <span class="string">"postgres://user:pass@host.com:5432/path?k=v#f"</span></span><br><span class="line">	<span class="comment">// 解析这个 URL 并确保解析没有出错。</span></span><br><span class="line">	u, err := url.Parse(s)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 直接访问 scheme。</span></span><br><span class="line">	fmt.Println(u.Scheme) <span class="comment">// postgres</span></span><br><span class="line">	<span class="comment">// User 包含了所有的认证信息，这里调用 Username和 Password 来获取独立值。</span></span><br><span class="line">	fmt.Println(u.User)            <span class="comment">// user:pass</span></span><br><span class="line">	fmt.Println(u.User.Username()) <span class="comment">// user</span></span><br><span class="line">	p, _ := u.User.Password()</span><br><span class="line">	fmt.Println(p) <span class="comment">// pass</span></span><br><span class="line">	<span class="comment">// Host 同时包括主机名和端口信息，如过端口存在的话，使用 strings.Split() 从 Host 中手动提取端口。</span></span><br><span class="line">	fmt.Println(u.Host) <span class="comment">// host.com:5432</span></span><br><span class="line">	h := strings.Split(u.Host, <span class="string">":"</span>)</span><br><span class="line">	fmt.Println(h[<span class="number">0</span>]) <span class="comment">// host.com</span></span><br><span class="line">	fmt.Println(h[<span class="number">1</span>]) <span class="comment">// 5432</span></span><br><span class="line">	<span class="comment">// 这里我们提出路径和查询片段信息。</span></span><br><span class="line">	fmt.Println(u.Path)     <span class="comment">// /path</span></span><br><span class="line">	fmt.Println(u.Fragment) <span class="comment">// f</span></span><br><span class="line">	<span class="comment">// 要得到字符串中的 k=v 这种格式的查询参数，可以使用 RawQuery 函数。你也可以将查询参数解析为一个map。</span></span><br><span class="line">	<span class="comment">// 已解析的查询参数 map 以查询字符串为键，对应值字符串切片为值，所以如何只想得到一个键对应的第一个值，将索引位置设置为 [0] 就行了。</span></span><br><span class="line">	fmt.Println(u.RawQuery) <span class="comment">// k=v</span></span><br><span class="line">	m, _ := url.ParseQuery(u.RawQuery)</span><br><span class="line">	fmt.Println(m)         <span class="comment">// map[k:[v]]</span></span><br><span class="line">	fmt.Println(m[<span class="string">"k"</span>][<span class="number">0</span>]) <span class="comment">// v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 例如，rand.Intn 返回一个随机的整数 n，0 &lt;= n &lt;= 100。</span></span><br><span class="line">	fmt.Print(rand.Intn(<span class="number">100</span>), <span class="string">","</span>)</span><br><span class="line">	fmt.Print(rand.Intn(<span class="number">100</span>))</span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="comment">// rand.Float64 返回一个64位浮点数 f，0.0 &lt;= f &lt;= 1.0。</span></span><br><span class="line">	fmt.Println(rand.Float64())</span><br><span class="line">	<span class="comment">// 这个技巧可以用来生成其他范围的随机浮点数，例如5.0 &lt;= f &lt;= 10.0</span></span><br><span class="line">	fmt.Print((rand.Float64()*<span class="number">5</span>)+<span class="number">5</span>, <span class="string">","</span>)</span><br><span class="line">	fmt.Print((rand.Float64() * <span class="number">5</span>) + <span class="number">5</span>)</span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="comment">// 默认情况下，给定的种子是确定的，每次都会产生相同的随机数数字序列。要产生变化的序列，需要给定一个变化的种子。需要注意的是，如果你出于加密目的，需要使用随机数的话，请使用 crypto/rand 包，此方法不够安全。</span></span><br><span class="line">	s1 := rand.NewSource(time.Now().UnixNano())</span><br><span class="line">	r1 := rand.New(s1)</span><br><span class="line">	<span class="comment">// 调用上面返回的 rand.Source 的函数和调用 rand 包中函数是相同的。</span></span><br><span class="line">	fmt.Print(r1.Intn(<span class="number">100</span>), <span class="string">","</span>)</span><br><span class="line">	fmt.Print(r1.Intn(<span class="number">100</span>))</span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="comment">// 如果使用相同的种子生成的随机数生成器，将会产生相同的随机数序列。</span></span><br><span class="line">	s2 := rand.NewSource(<span class="number">42</span>)</span><br><span class="line">	r2 := rand.New(s2)</span><br><span class="line">	fmt.Print(r2.Intn(<span class="number">100</span>), <span class="string">","</span>)</span><br><span class="line">	fmt.Print(r2.Intn(<span class="number">100</span>))</span><br><span class="line">	fmt.Println()</span><br><span class="line">	s3 := rand.NewSource(<span class="number">42</span>)</span><br><span class="line">	r3 := rand.New(s3)</span><br><span class="line">	fmt.Print(r3.Intn(<span class="number">100</span>), <span class="string">","</span>)</span><br><span class="line">	fmt.Print(r3.Intn(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SHA1散列"><a href="#SHA1散列" class="headerlink" title="SHA1散列"></a>SHA1散列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">"sha1"</span></span><br><span class="line">	<span class="comment">// 产生一个散列值得方式是 sha1.New()，sha1.Write(bytes)，然后 sha1.Sum([]byte&#123;&#125;)。这里我们从一个新的散列开始。</span></span><br><span class="line">	h := sha1.New()</span><br><span class="line">	<span class="comment">// 写入要处理的字节。如果是一个字符串，需要使用[]byte(s) 来强制转换成字节数组。</span></span><br><span class="line">	h.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">	<span class="comment">// 这个用来得到最终的散列值的字符切片。Sum 的参数可以用来都现有的字符切片追加额外的字节切片：一般不需要要。</span></span><br><span class="line">	bs := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// SHA1 值经常以 16 进制输出，例如在 git commit 中。使用%x 来将散列结果格式化为 16 进制字符串。</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	fmt.Printf(<span class="string">"%x\n"</span>, bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BASE64编码"><a href="#BASE64编码" class="headerlink" title="BASE64编码"></a>BASE64编码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这是将要编解码的字符串。</span></span><br><span class="line">	data := <span class="string">"abc123!?$*&amp;()'-=@~"</span></span><br><span class="line">	<span class="comment">// Go 同时支持标准的和 URL 兼容的 base64 格式。编码需要使用 []byte 类型的参数，所以要将字符串转成此类型。</span></span><br><span class="line">	<span class="comment">// 标准 base64 编码和 URL 兼容 base64 编码的编码字符串存在稍许不同（后缀为 + 和 -），但是两者都可以正确解码为原始字符串。</span></span><br><span class="line">	sEnc := base64.StdEncoding.EncodeToString([]<span class="keyword">byte</span>(data))</span><br><span class="line">	fmt.Println(sEnc)</span><br><span class="line">	<span class="comment">// 解码可能会返回错误，如果不确定输入信息格式是否正确，那么，你就需要进行错误检查了。</span></span><br><span class="line">	sDec, _ := base64.StdEncoding.DecodeString(sEnc)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(sDec))</span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="comment">// 使用 URL 兼容的 base64 格式进行编解码。</span></span><br><span class="line">	uEnc := base64.URLEncoding.EncodeToString([]<span class="keyword">byte</span>(data))</span><br><span class="line">	fmt.Println(uEnc)</span><br><span class="line">	uDec, _ := base64.URLEncoding.DecodeString(uEnc)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(uDec))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(from <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		fmt.Println(from, <span class="string">":"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 假设我们有一个函数叫做 f(s)。我们使用一般的方式调并同时运行。</span></span><br><span class="line">	f(<span class="string">"direct"</span>)</span><br><span class="line">	<span class="comment">// 使用 go f(s) 在一个 Go 协程中调用这个函数。这个新的 Go 协程将会并行的执行这个函数调用。</span></span><br><span class="line">	<span class="keyword">go</span> f(<span class="string">"goroutine"</span>)</span><br><span class="line">	<span class="comment">// 你也可以为匿名函数启动一个 Go 协程。</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(msg)</span><br><span class="line">	&#125;(<span class="string">"going"</span>)</span><br><span class="line">	<span class="comment">// 现在这两个 Go 协程在独立的 Go 协程中异步的运行，所以我们需要等它们执行结束。这里的 Scanln 代码需要我们在程序退出前按下任意键结束。</span></span><br><span class="line">	<span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">	fmt.Scanln(&amp;input)</span><br><span class="line">	fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">	<span class="comment">// 当我们运行这个程序时，将首先看到阻塞式调用的输出，然后是两个 Go 协程的交替输出。这种交替的情况表示 Go 运行时是以异步的方式运行协程的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通道 是连接多个 Go 协程的管道。你可以从一个 Go 协程将值发送到通道，然后在别的 Go 协程中接收。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用 make(chan val-type) 创建一个新的通道。通道类型就是他们需要传递值的类型。</span></span><br><span class="line">	messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="comment">// 使用 channel &lt;- 语法 发送 一个新的值到通道中。这里我们在一个新的 Go 协程中发送 "ping" 到上面创建的messages 通道中。</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; messages &lt;- <span class="string">"ping"</span> &#125;()</span><br><span class="line">	<span class="comment">// 使用 &lt;-channel 语法从通道中 接收 一个值。这里将接收我们在上面发送的 "ping" 消息并打印出来。</span></span><br><span class="line">	msg := &lt;-messages</span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们运行程序时，通过通道，消息 "ping" 成功的从一个 Go 协程传到另一个中。</span></span><br><span class="line"><span class="comment">// 默认发送和接收操作是阻塞的，直到发送方和接收方都准备完毕。这个特性允许我们，不使用任何其它的同步操作，来在程序结尾等待消息 "ping"。</span></span><br></pre></td></tr></table></figure>
<h3 id="通道缓冲"><a href="#通道缓冲" class="headerlink" title="通道缓冲"></a>通道缓冲</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认通道是 无缓冲 的，这意味着只有在对应的接收（&lt;- chan）通道准备好接收时，才允许进行发送（chan &lt;-）。可缓存通道允许在没有对应接收方的情况下，缓存限定数量的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里我们 make 了一个通道，最多允许缓存 2 个值。</span></span><br><span class="line">	messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="comment">// 因为这个通道是有缓冲区的，即使没有一个对应的并发接收方，我们仍然可以发送这些值。</span></span><br><span class="line">	messages &lt;- <span class="string">"buffered"</span></span><br><span class="line">	messages &lt;- <span class="string">"channel"</span></span><br><span class="line">	<span class="comment">// 然后我们可以像前面一样接收这两个值。</span></span><br><span class="line">	fmt.Println(&lt;-messages)</span><br><span class="line">	fmt.Println(&lt;-messages)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通道同步"><a href="#通道同步" class="headerlink" title="通道同步"></a>通道同步</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们可以使用通道来同步 Go 协程间的执行状态。这里是一个使用阻塞的接受方式来等待一个 Go 协程的运行结束。</span></span><br><span class="line"><span class="comment">// 这是一个我们将要在 Go 协程中运行的函数。done 通道将被用于通知其他 Go 协程这个函数已经工作完毕。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">"working..."</span>)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">	<span class="comment">// 发送一个值来通知我们已经完工啦。</span></span><br><span class="line">	done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 运行一个 worker Go协程，并给予用于通知的通道。</span></span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> worker(done)</span><br><span class="line">	<span class="comment">// 程序将在接收到通道中 worker 发出的通知前一直阻塞。</span></span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你把 &lt;- done 这行代码从程序中移除，程序甚至会在 worker还没开始运行时就结束了</span></span><br></pre></td></tr></table></figure>
<h3 id="通道方向"><a href="#通道方向" class="headerlink" title="通道方向"></a>通道方向</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ping 函数定义了一个只允许发送数据的通道。尝试使用这个通道来接收数据将会得到一个编译时错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping</span><span class="params">(pings <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>, msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	pings &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pong 函数允许通道（pings）来接收数据，另一通道（pongs）来发送数据。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pong</span><span class="params">(pings &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>, pongs <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	msg := &lt;-pings</span><br><span class="line">	pongs &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pings := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">	pongs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">	ping(pings, <span class="string">"passed message"</span>)</span><br><span class="line">	pong(pings, pongs)</span><br><span class="line">	fmt.Println(&lt;-pongs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通道选择器"><a href="#通道选择器" class="headerlink" title="通道选择器"></a>通道选择器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在我们的例子中，我们将从两个通道中选择。</span></span><br><span class="line">	c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="comment">// 各个通道将在若干时间后接收一个值，这个用来模拟例如并行的 Go 协程中阻塞的 RPC 操作</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">		c1 &lt;- <span class="string">"one"</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">		c2 &lt;- <span class="string">"two"</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 我们使用 select 关键字来同时等待这两个值，并打印各自接收到的值。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">			fmt.Println(<span class="string">"received"</span>, msg1)</span><br><span class="line">		<span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">			fmt.Println(<span class="string">"received"</span>, msg2)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在我们的例子中，假如我们执行一个外部调用，并在 2 秒后通过通道 c1 返回它的执行结果。</span></span><br><span class="line">	c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">		c1 &lt;- <span class="string">"result 1"</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 这里是使用 select 实现一个超时操作。res := &lt;- c1 等待结果，&lt;-Time.After 等待超时时间 1 秒后发送的值。由于 select 默认处理第一个已准备好的接收操作，如果这个操作超过了允许的 1 秒的话，将会执行超时 case。</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> res := &lt;-c1:</span><br><span class="line">		fmt.Println(res)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>):</span><br><span class="line">		fmt.Println(<span class="string">"timeout 1"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果我允许一个长一点的超时时间 3 秒，将会成功的从 c2接收到值，并且打印出结果。</span></span><br><span class="line">	c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">		c2 &lt;- <span class="string">"result 2"</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> res := &lt;-c2:</span><br><span class="line">		fmt.Println(res)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">3</span>):</span><br><span class="line">		fmt.Println(<span class="string">"timeout 2"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非阻塞通道"><a href="#非阻塞通道" class="headerlink" title="非阻塞通道"></a>非阻塞通道</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规的通过通道发送和接收数据是阻塞的。然而，我们可以使用带一个 default 子句的 select 来实现非阻塞 的发送、接收，甚至是非阻塞的多路 select。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	signals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="comment">// 这里是一个非阻塞接收的例子。如果在 messages 中存在，然后 select 将这个值带入 &lt;-messages case中。如果不是，就直接到 default 分支中。</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> msg := &lt;-messages:</span><br><span class="line">		fmt.Println(<span class="string">"received message"</span>, msg)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"no message received"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 一个非阻塞发送的实现方法和上面一样。</span></span><br><span class="line">	msg := <span class="string">"hi"</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> messages &lt;- msg:</span><br><span class="line">		fmt.Println(<span class="string">"sent message"</span>, msg)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"no message sent"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 我们可以在 default 前使用多个 case 子句来实现一个多路的非阻塞的选择器。这里我们试图在 messages和 signals 上同时使用非阻塞的接受操作。</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> msg := &lt;-messages:</span><br><span class="line">		fmt.Println(<span class="string">"received message"</span>, msg)</span><br><span class="line">	<span class="keyword">case</span> sig := &lt;-signals:</span><br><span class="line">		fmt.Println(<span class="string">"received signal"</span>, sig)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"no activity"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通道的关闭"><a href="#通道的关闭" class="headerlink" title="通道的关闭"></a>通道的关闭</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭 一个通道意味着不能再向这个通道发送值了。这个特性可以用来给这个通道的接收方传达工作已经完成的信息。</span></span><br><span class="line"><span class="comment">// 在这个例子中，我们将使用一个 jobs 通道来传递 main() 中 Go协程任务执行的结束信息到一个工作 Go 协程中。当我们没有多余的任务给这个工作 Go 协程时，我们将 close 这个 jobs 通道。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="comment">// 这是工作 Go 协程。使用 j, more := &lt;- jobs 循环的从jobs 接收数据。在接收的这个特殊的二值形式的值中，如果 jobs 已经关闭了，并且通道中所有的值都已经接收完毕，那么 more 的值将是 false。当我们完成所有的任务时，将使用这个特性通过 done 通道去进行通知。</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			j, more := &lt;-jobs</span><br><span class="line">			<span class="keyword">if</span> more &#123;</span><br><span class="line">				fmt.Println(<span class="string">"received job"</span>, j)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">"received all jobs"</span>)</span><br><span class="line">				done &lt;- <span class="literal">true</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 这里使用 jobs 发送 3 个任务到工作函数中，然后关闭 jobs。</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++ &#123;</span><br><span class="line">		jobs &lt;- j</span><br><span class="line">		fmt.Println(<span class="string">"sent job"</span>, j)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(jobs)</span><br><span class="line">	fmt.Println(<span class="string">"sent all jobs"</span>)</span><br><span class="line">	<span class="comment">// 我们使用前面学到的通道同步方法等待任务结束。</span></span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通道遍历"><a href="#通道遍历" class="headerlink" title="通道遍历"></a>通道遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在前面的例子中，我们讲过 for 和 range为基本的数据结构提供了迭代的功能。我们也可以使用这个语法来遍历从通道中取得的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 我们将遍历在 queue 通道中的两个值。</span></span><br><span class="line">	queue := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">	queue &lt;- <span class="string">"one"</span></span><br><span class="line">	queue &lt;- <span class="string">"two"</span></span><br><span class="line">	<span class="built_in">close</span>(queue)</span><br><span class="line">	<span class="comment">// 这个 range 迭代从 queue 中得到的每个值。因为我们在前面 close 了这个通道，这个迭代会在接收完 2 个值之后结束。如果我们没有 close 它，我们将在这个循环中继续阻塞执行，等待接收第三个值</span></span><br><span class="line">	<span class="keyword">for</span> elem := <span class="keyword">range</span> queue &#123;</span><br><span class="line">		fmt.Println(elem)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个例子也让我们看到，一个非空的通道也是可以关闭的，但是通道中剩下的值仍然可以被接收到。</span></span><br></pre></td></tr></table></figure>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定时器表示在未来某一时刻的独立事件。你告诉定时器需要等待的时间，然后它将提供一个用于通知的通道。这里的定时器将等待 2 秒。</span></span><br><span class="line">	timer1 := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">	<span class="comment">// &lt;-timer1.C 直到这个定时器的通道 C 明确的发送了定时器失效的值之前，将一直阻塞。</span></span><br><span class="line">	&lt;-timer1.C</span><br><span class="line">	fmt.Println(<span class="string">"Timer 1 expired"</span>)</span><br><span class="line">	<span class="comment">// 如果你需要的仅仅是单纯的等待，你需要使用 time.Sleep。定时器是有用原因之一就是你可以在定时器失效之前，取消这个定时器。这是一个例子</span></span><br><span class="line">	timer2 := time.NewTimer(time.Second)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-timer2.C</span><br><span class="line">		fmt.Println(<span class="string">"Timer 2 expired"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	stop2 := timer2.Stop()</span><br><span class="line">	<span class="keyword">if</span> stop2 &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Timer 2 stopped"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打点器"><a href="#打点器" class="headerlink" title="打点器"></a>打点器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打点器和定时器的机制有点相似：一个通道用来发送数据。这里我们在这个通道上使用内置的 range 来迭代值每隔500ms 发送一次的值。</span></span><br><span class="line">	ticker := time.NewTicker(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> t := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Tick at"</span>, t)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 打点器可以和定时器一样被停止。一旦一个打点停止了，将不能再从它的通道中接收到值。我们将在运行后 1600ms停止这个打点器。</span></span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">1600</span>)</span><br><span class="line">	ticker.Stop()</span><br><span class="line">	fmt.Println(<span class="string">"Ticker stopped"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="工作池"><a href="#工作池" class="headerlink" title="工作池"></a>工作池</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是我们将要在多个并发实例中支持的任务了。这些执行者将从 jobs 通道接收任务，并且通过 results 发送对应的结果。我们将让每个任务间隔 1s 来模仿一个耗时的任务。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, results <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> j := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">		fmt.Println(<span class="string">"worker"</span>, id, <span class="string">"processing job"</span>, j)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		results &lt;- j * <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 为了使用 worker 工作池并且收集他们的结果，我们需要2 个通道。</span></span><br><span class="line">	jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">	results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="comment">// 这里启动了 3 个 worker，初始是阻塞的，因为还没有传递任务。</span></span><br><span class="line">	<span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= <span class="number">3</span>; w++ &#123;</span><br><span class="line">		<span class="keyword">go</span> worker(w, jobs, results)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里我们发送 9 个 jobs，然后 close 这些通道来表示这些就是所有的任务了。</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++ &#123;</span><br><span class="line">		jobs &lt;- j</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(jobs)</span><br><span class="line">	<span class="comment">// 最后，我们收集所有这些任务的返回值。</span></span><br><span class="line">	<span class="keyword">for</span> a := <span class="number">1</span>; a &lt;= <span class="number">9</span>; a++ &#123;</span><br><span class="line">		&lt;-results</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行这个程序，显示 9 个任务被多个 worker 执行。整个程序处理所有的任务仅执行了 3s 而不是 9s，是因为 3 个 worker是并行的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="速率限制-未懂"><a href="#速率限制-未懂" class="headerlink" title="速率限制(未懂)"></a>速率限制(未懂)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 首先我们将看一下基本的速率限制。假设我们想限制我们接收请求的处理，我们将这些请求发送给一个相同的通道。</span></span><br><span class="line">	requests := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		requests &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(requests)</span><br><span class="line">	<span class="comment">// 这个 limiter 通道将每 200ms 接收一个值。这个是速率限制任务中的管理器。</span></span><br><span class="line">	limiter := time.Tick(time.Millisecond * <span class="number">200</span>)</span><br><span class="line">	<span class="comment">// 通过在每次请求前阻塞 limiter 通道的一个接收，我们限制自己每 200ms 执行一次请求。</span></span><br><span class="line">	<span class="keyword">for</span> req := <span class="keyword">range</span> requests &#123;</span><br><span class="line">		&lt;-limiter</span><br><span class="line">		fmt.Println(<span class="string">"request"</span>, req, time.Now())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 有时候我们想临时进行速率限制，并且不影响整体的速率控制我们可以通过通道缓冲来实现。这个 burstyLimiter 通道用来进行 3 次临时的脉冲型速率限制。</span></span><br><span class="line">	burstyLimiter := <span class="built_in">make</span>(<span class="keyword">chan</span> time.Time, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 想将通道填充需要临时改变3次的值，做好准备。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		burstyLimiter &lt;- time.Now()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 每 200 ms 我们将添加一个新的值到 burstyLimiter中，直到达到 3 个的限制。</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> t := <span class="keyword">range</span> time.Tick(time.Millisecond * <span class="number">200</span>) &#123;</span><br><span class="line">			burstyLimiter &lt;- t</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 现在模拟超过 5 个的接入请求。它们中刚开始的 3 个将由于受 burstyLimiter 的“脉冲”影响。</span></span><br><span class="line">	burstyRequests := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		burstyRequests &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(burstyRequests)</span><br><span class="line">	<span class="keyword">for</span> req := <span class="keyword">range</span> burstyRequests &#123;</span><br><span class="line">		&lt;-burstyLimiter</span><br><span class="line">		fmt.Println(<span class="string">"request"</span>, req, time.Now())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 运行程序，我们看到第一批请求意料之中的大约每 200ms 处理一次。</span></span><br><span class="line">	<span class="comment">// 第二批请求，我们直接连续处理了 3 次，这是由于这个“脉冲”速率控制，然后大约每 200ms 处理其余的 2 个。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原子计数器"><a href="#原子计数器" class="headerlink" title="原子计数器"></a>原子计数器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 我们将使用一个无符号整型数来表示（永远是正整数）这个计数器。</span></span><br><span class="line">	<span class="keyword">var</span> ops <span class="keyword">uint64</span> = <span class="number">0</span></span><br><span class="line">	<span class="comment">// 为了模拟并发更新，我们启动 50 个 Go 协程，对计数器每隔 1ms （译者注：应为非准确时间）进行一次加一操作。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="comment">// 使用 AddUint64 来让计数器自动增加，使用&amp; 语法来给出 ops 的内存地址。</span></span><br><span class="line">				atomic.AddUint64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">				<span class="comment">// 允许其它 Go 协程的执行</span></span><br><span class="line">				runtime.Gosched()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等待一秒，让 ops 的自加操作执行一会。</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="comment">// 为了在计数器还在被其它 Go 协程更新时，安全的使用它，我们通过 LoadUint64 将当前值的拷贝提取到 opsFinal中。和上面一样，我们需要给这个函数所取值的内存地址 &amp;ops</span></span><br><span class="line">	opsFinal := atomic.LoadUint64(&amp;ops)</span><br><span class="line">	fmt.Println(<span class="string">"ops:"</span>, opsFinal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="互斥锁-未懂"><a href="#互斥锁-未懂" class="headerlink" title="互斥锁(未懂)"></a>互斥锁(未懂)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在我们的例子中，state 是一个 map。</span></span><br><span class="line">	<span class="keyword">var</span> state = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="comment">// 这里的 mutex 将同步对 state 的访问。</span></span><br><span class="line">	<span class="keyword">var</span> mutex = &amp;sync.Mutex&#123;&#125;</span><br><span class="line">	<span class="comment">// we'll see later, ops will count how manyoperations we perform against the state.为了比较基于互斥锁的处理方式和我们后面将要看到的其他方式，ops 将记录我们对 state 的操作次数。</span></span><br><span class="line">	<span class="keyword">var</span> ops <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line">	<span class="comment">// 这里我们运行 100 个 Go 协程来重复读取 state。</span></span><br><span class="line">	<span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="number">100</span>; r++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			total := <span class="number">0</span></span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="comment">// 每次循环读取，我们使用一个键来进行访问，Lock() 这个 mutex 来确保对 state 的独占访问，读取选定的键的值，Unlock() 这个mutex，并且 ops 值加 1。</span></span><br><span class="line">				key := rand.Intn(<span class="number">5</span>)</span><br><span class="line">				mutex.Lock()</span><br><span class="line">				total += state[key]</span><br><span class="line">				mutex.Unlock()</span><br><span class="line">				atomic.AddInt64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">				<span class="comment">// 为了确保这个 Go 协程不会在调度中饿死，我们在每次操作后明确的使用 runtime.Gosched()进行释放。这个释放一般是自动处理的，像例如每个通道操作后或者 time.Sleep 的阻塞调用后相似，但是在这个例子中我们需要手动的处理。</span></span><br><span class="line">				runtime.Gosched()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 同样的，我们运行 10 个 Go 协程来模拟写入操作，使用和读取相同的模式。</span></span><br><span class="line">	<span class="keyword">for</span> w := <span class="number">0</span>; w &lt; <span class="number">10</span>; w++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				key := rand.Intn(<span class="number">5</span>)</span><br><span class="line">				val := rand.Intn(<span class="number">100</span>)</span><br><span class="line">				mutex.Lock()</span><br><span class="line">				state[key] = val</span><br><span class="line">				mutex.Unlock()</span><br><span class="line">				atomic.AddInt64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">				runtime.Gosched()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 让这 10 个 Go 协程对 state 和 mutex 的操作运行 1 s。</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="comment">// 获取并输出最终的操作计数。</span></span><br><span class="line">	opsFinal := atomic.LoadInt64(&amp;ops)</span><br><span class="line">	fmt.Println(<span class="string">"ops:"</span>, opsFinal)</span><br><span class="line">	<span class="comment">// 对 state 使用一个最终的锁，显示它是如何结束的。</span></span><br><span class="line">	mutex.Lock()</span><br><span class="line">	fmt.Println(<span class="string">"state:"</span>, state)</span><br><span class="line">	mutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="go状态协程-未读"><a href="#go状态协程-未读" class="headerlink" title="go状态协程(未读)"></a><code>go</code>状态协程(未读)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这个例子中，state 将被一个单独的 Go 协程拥有。这就能够保证数据在并行读取时不会混乱。为了对 state 进行读取或者写入，其他的 Go 协程将发送一条数据到拥有的 Go协程中，然后接收对应的回复。结构体 readOp 和 writeOp封装这些请求，并且是拥有 Go 协程响应的一个方式。</span></span><br><span class="line"><span class="keyword">type</span> readOp <span class="keyword">struct</span> &#123;</span><br><span class="line">	key  <span class="keyword">int</span></span><br><span class="line">	resp <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> writeOp <span class="keyword">struct</span> &#123;</span><br><span class="line">	key  <span class="keyword">int</span></span><br><span class="line">	val  <span class="keyword">int</span></span><br><span class="line">	resp <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 和前面一样，我们将计算我们执行操作的次数。</span></span><br><span class="line">	<span class="keyword">var</span> ops <span class="keyword">int64</span></span><br><span class="line">	<span class="comment">// reads 和 writes 通道分别将被其他 Go 协程用来发布读和写请求。</span></span><br><span class="line">	reads := <span class="built_in">make</span>(<span class="keyword">chan</span> *readOp)</span><br><span class="line">	writes := <span class="built_in">make</span>(<span class="keyword">chan</span> *writeOp)</span><br><span class="line">	<span class="comment">// 这个就是拥有 state 的那个 Go 协程，和前面例子中的map一样，不过这里是被这个状态协程私有的。这个 Go 协程反复响应到达的请求。先响应到达的请求，然后返回一个值到响应通道 resp 来表示操作成功（或者是 reads 中请求的值）</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> state = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> read := &lt;-reads:</span><br><span class="line">				read.resp &lt;- state[read.key]</span><br><span class="line">			<span class="keyword">case</span> write := &lt;-writes:</span><br><span class="line">				state[write.key] = write.val</span><br><span class="line">				write.resp &lt;- <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 启动 100 个 Go 协程通过 reads 通道发起对 state 所有者Go 协程的读取请求。每个读取请求需要构造一个 readOp，发送它到 reads 通道中，并通过给定的 resp 通道接收结果。</span></span><br><span class="line">	<span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="number">100</span>; r++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				read := &amp;readOp&#123;</span><br><span class="line">					key:  rand.Intn(<span class="number">5</span>),</span><br><span class="line">					resp: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)&#125;</span><br><span class="line">				reads &lt;- read</span><br><span class="line">				&lt;-read.resp</span><br><span class="line">				atomic.AddInt64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 用相同的方法启动 10 个写操作。</span></span><br><span class="line">	<span class="keyword">for</span> w := <span class="number">0</span>; w &lt; <span class="number">10</span>; w++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				write := &amp;writeOp&#123;</span><br><span class="line">					key:  rand.Intn(<span class="number">5</span>),</span><br><span class="line">					val:  rand.Intn(<span class="number">100</span>),</span><br><span class="line">					resp: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)&#125;</span><br><span class="line">				writes &lt;- write</span><br><span class="line">				&lt;-write.resp</span><br><span class="line">				atomic.AddInt64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 让 Go 协程们跑 1s。</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="comment">// 最后，获取并报告 ops 值。</span></span><br><span class="line">	opsFinal := atomic.LoadInt64(&amp;ops)</span><br><span class="line">	fmt.Println(<span class="string">"ops:"</span>, opsFinal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文件需要经常进行错误检查，这个帮助方法可以精简下面的错误检查过程。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(e error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 也许大部分基本的文件读取任务是将文件内容读取到内存中。</span></span><br><span class="line">	dat, err := ioutil.ReadFile(<span class="string">"/tmp/dat"</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	fmt.Print(<span class="keyword">string</span>(dat))</span><br><span class="line">	<span class="comment">// 你经常会想对于一个文件是怎么读并且读取到哪一部分进行更多的控制。对于这个任务，从使用 os.Open打开一个文件获取一个 os.File 值开始。</span></span><br><span class="line">	f, err := os.Open(<span class="string">"/tmp/dat"</span>)</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	check(err)</span><br><span class="line">	<span class="comment">// 从文件开始位置读取一些字节。这里最多读取 5 个字节，并且这也是我们实际读取的字节数。</span></span><br><span class="line">	b1 := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br><span class="line">	n1, err := f.Read(b1)</span><br><span class="line">	check(err)</span><br><span class="line">	fmt.Printf(<span class="string">"%d bytes: %s\n"</span>, n1, <span class="keyword">string</span>(b1))</span><br><span class="line">	<span class="comment">// 你也可以 Seek 到一个文件中已知的位置并从这个位置开始进行读取。</span></span><br><span class="line">	o2, err := f.Seek(<span class="number">6</span>, <span class="number">0</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	b2 := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line">	n2, err := f.Read(b2)</span><br><span class="line">	check(err)</span><br><span class="line">	fmt.Printf(<span class="string">"%d bytes @ %d: %s\n"</span>, n2, o2, <span class="keyword">string</span>(b2))</span><br><span class="line">	<span class="comment">// io 包提供了一些可以帮助我们进行文件读取的函数。例如，上面的读取可以使用 ReadAtLeast 得到一个更健壮的实现。</span></span><br><span class="line">	o3, err := f.Seek(<span class="number">6</span>, <span class="number">0</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	b3 := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line">	n3, err := io.ReadAtLeast(f, b3, <span class="number">2</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	fmt.Printf(<span class="string">"%d bytes @ %d: %s\n"</span>, n3, o3, <span class="keyword">string</span>(b3))</span><br><span class="line">	<span class="comment">// 没有内置的回转支持，但是使用 Seek(0, 0) 实现。</span></span><br><span class="line">	_, err = f.Seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	<span class="comment">// bufio 包实现了带缓冲的读取，这不仅对有很多小的读取操作的能提升性能，也提供了很多附加的读取函数。</span></span><br><span class="line">	r4 := bufio.NewReader(f)</span><br><span class="line">	b4, err := r4.Peek(<span class="number">5</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	fmt.Printf(<span class="string">"5 bytes: %s\n"</span>, <span class="keyword">string</span>(b4))</span><br><span class="line">	<span class="comment">// 任务结束后要关闭这个文件（通常这个操作应该在 Open操作后立即使用 defer 来完成）。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 开始，这里是展示如写入一个字符串（或者只是一些字节）到一个文件。</span></span><br><span class="line">	d1 := []<span class="keyword">byte</span>(<span class="string">"hello\ngo\n"</span>)</span><br><span class="line">	err := ioutil.WriteFile(<span class="string">"/tmp/dat1"</span>, d1, <span class="number">0644</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	<span class="comment">// 对于更细粒度的写入，先打开一个文件。</span></span><br><span class="line">	f, err := os.Create(<span class="string">"/tmp/dat2"</span>)</span><br><span class="line">	check(err)</span><br><span class="line">	<span class="comment">// 打开文件后，习惯立即使用 defer 调用文件的 Close操作。</span></span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	<span class="comment">// 你可以写入你想写入的字节切片</span></span><br><span class="line">	d2 := []<span class="keyword">byte</span>&#123;<span class="number">115</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">10</span>&#125;</span><br><span class="line">	n2, err := f.Write(d2)</span><br><span class="line">	check(err)</span><br><span class="line">	fmt.Printf(<span class="string">"wrote %d bytes\n"</span>, n2)</span><br><span class="line">	<span class="comment">// WriteString 也是可用的。</span></span><br><span class="line">	n3, err := f.WriteString(<span class="string">"writes\n"</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"wrote %d bytes\n"</span>, n3)</span><br><span class="line">	<span class="comment">// 调用 Sync 来将缓冲区的信息写入磁盘。</span></span><br><span class="line">	f.Sync()</span><br><span class="line">	<span class="comment">// bufio 提供了和我们前面看到的带缓冲的读取器一样的带缓冲的写入器。</span></span><br><span class="line">	w := bufio.NewWriter(f)</span><br><span class="line">	n4, err := w.WriteString(<span class="string">"buffered\n"</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"wrote %d bytes\n"</span>, n4)</span><br><span class="line">	<span class="comment">// 使用 Flush 来确保所有缓存的操作已写入底层写入器。</span></span><br><span class="line">	w.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="行过滤器"><a href="#行过滤器" class="headerlink" title="行过滤器"></a>行过滤器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在读取标准输入流的输入，处理该输入，然后将得到一些的结果输出到标准输出的程序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 对 os.Stdin 使用一个带缓冲的 scanner，让我们可以直接使用方便的 Scan 方法来直接读取一行，每次调用该方法可以让 scanner 读取下一行。</span></span><br><span class="line">	scanner := bufio.NewScanner(os.Stdin)</span><br><span class="line">	<span class="comment">// Text 返回当前的 token，现在是输入的下一行。</span></span><br><span class="line">	<span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">		ucl := strings.ToUpper(scanner.Text())</span><br><span class="line">		<span class="comment">// 写出大写的行。</span></span><br><span class="line">		fmt.Println(ucl)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 检查 Scan 的错误。文件结束符是可以接受的，并且不会被 Scan 当作一个错误。</span></span><br><span class="line">	<span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Fprintln(os.Stderr, <span class="string">"error:"</span>, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令行参数是指定程序运行参数的一个常见方式。例如，go run hello.go，程序 go 使用了 run 和 hello.go 两个参数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// os.Args 提供原始命令行参数访问功能。注意，切片中的第一个参数是该程序的路径，并且 os.Args[1:]保存所有程序的的参数。</span></span><br><span class="line">	argsWithProg := os.Args</span><br><span class="line">	argsWithoutProg := os.Args[<span class="number">1</span>:]</span><br><span class="line">	<span class="comment">// 你可以使用标准的索引位置方式取得单个参数的值。</span></span><br><span class="line">	arg := os.Args[<span class="number">3</span>]</span><br><span class="line">	fmt.Println(argsWithProg)    <span class="comment">// [./command-line-arguments a b c d]</span></span><br><span class="line">	fmt.Println(argsWithoutProg) <span class="comment">// [a b c d]</span></span><br><span class="line">	fmt.Println(arg)             <span class="comment">// c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要实验命令行参数，最好先使用 go build 编译一个可执行二进制文件</span></span><br><span class="line"><span class="comment">// $ go build command-line-arguments.go</span></span><br><span class="line"><span class="comment">// $ ./command-line-arguments a b c d</span></span><br></pre></td></tr></table></figure>
<h3 id="命令行标志-未懂"><a href="#命令行标志-未懂" class="headerlink" title="命令行标志(未懂)"></a>命令行标志(未懂)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 基本的标记声明仅支持字符串、整数和布尔值选项。这里我们声明一个默认值为 "foo" 的字符串标志 word并带有一个简短的描述。</span></span><br><span class="line">	<span class="comment">// 这里的 flag.String 函数返回一个字符串指针（不是一个字符串值），在下面我们会看到是如何使用这个指针的。</span></span><br><span class="line">	wordPtr := flag.String(<span class="string">"word"</span>, <span class="string">"foo"</span>, <span class="string">"a string"</span>)</span><br><span class="line">	<span class="comment">// 使用和声明 word 标志相同的方法来声明 numb 和 fork 标志。</span></span><br><span class="line">	numbPtr := flag.Int(<span class="string">"numb"</span>, <span class="number">42</span>, <span class="string">"an int"</span>)</span><br><span class="line">	boolPtr := flag.Bool(<span class="string">"fork"</span>, <span class="literal">false</span>, <span class="string">"a bool"</span>)</span><br><span class="line">	<span class="comment">// 用程序中已有的参数来声明一个标志也是可以的。注意在标志声明函数中需要使用该参数的指针。</span></span><br><span class="line">	<span class="keyword">var</span> svar <span class="keyword">string</span></span><br><span class="line">	flag.StringVar(&amp;svar, <span class="string">"svar"</span>, <span class="string">"bar"</span>, <span class="string">"a string var"</span>)</span><br><span class="line">	<span class="comment">// 所有标志都声明完成以后，调用 flag.Parse() 来执行命令行解析。</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// 这里我们将仅输出解析的选项以及后面的位置参数。注意，我们需要使用类似 *wordPtr 这样的语法来对指针解引用，从而得到选项的实际值。</span></span><br><span class="line">	fmt.Println(<span class="string">"word:"</span>, *wordPtr)</span><br><span class="line">	fmt.Println(<span class="string">"numb:"</span>, *numbPtr)</span><br><span class="line">	fmt.Println(<span class="string">"fork:"</span>, *boolPtr)</span><br><span class="line">	fmt.Println(<span class="string">"svar:"</span>, svar)</span><br><span class="line">	fmt.Println(<span class="string">"tail:"</span>, flag.Args())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试这个程序前，最好将这个程序编译成二进制文件，然后再运行这个程序。</span></span><br><span class="line"><span class="comment">// $ go build command-line-flags.go</span></span><br><span class="line"><span class="comment">// word: opt</span></span><br><span class="line"><span class="comment">// numb: 7</span></span><br><span class="line"><span class="comment">// fork: true</span></span><br><span class="line"><span class="comment">// svar: flag</span></span><br><span class="line"><span class="comment">// tail: []</span></span><br><span class="line"><span class="comment">// 注意到，如果你省略一个标志，那么这个标志的值自动的设定为他的默认值。</span></span><br><span class="line"><span class="comment">// $ ./command-line-flags -word=opt</span></span><br><span class="line"><span class="comment">// word: opt</span></span><br><span class="line"><span class="comment">// numb: 42</span></span><br><span class="line"><span class="comment">// fork: false</span></span><br><span class="line"><span class="comment">// svar: bar</span></span><br><span class="line"><span class="comment">// tail: []</span></span><br><span class="line"><span class="comment">// 位置参数可以出现在任何标志后面。</span></span><br><span class="line"><span class="comment">// $ ./command-line-flags -word=opt a1 a2 a3</span></span><br><span class="line"><span class="comment">// word: opt</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// tail: [a1 a2 a3]</span></span><br><span class="line"><span class="comment">// 注意，flag 包需要所有的标志出现位置参数之前（否则，这个标志将会被解析为位置参数）。</span></span><br><span class="line"><span class="comment">// $ ./command-line-flags -word=opt a1 a2 a3 -numb=7</span></span><br><span class="line"><span class="comment">// word: opt</span></span><br><span class="line"><span class="comment">// numb: 42</span></span><br><span class="line"><span class="comment">// fork: false</span></span><br><span class="line"><span class="comment">// svar: bar</span></span><br><span class="line"><span class="comment">// trailing: [a1 a2 a3 -numb=7]</span></span><br><span class="line"><span class="comment">// 使用 -h 或者 --help 标志来得到自动生成的这个命令行程序的帮助文本。</span></span><br><span class="line"><span class="comment">// $ ./command-line-flags -h</span></span><br><span class="line"><span class="comment">// Usage of ./command-line-flags:</span></span><br><span class="line"><span class="comment">//   -fork=false: a bool</span></span><br><span class="line"><span class="comment">//   -numb=42: an int</span></span><br><span class="line"><span class="comment">//   -svar="bar": a string var</span></span><br><span class="line"><span class="comment">//   -word="foo": a string</span></span><br><span class="line"><span class="comment">// 如果你提供一个没有使用 flag 包指定的标志，程序会输出一个错误信息，并再次显示帮助文本。</span></span><br><span class="line"><span class="comment">// $ ./command-line-flags -wat</span></span><br><span class="line"><span class="comment">// flag provided but not defined: -wat</span></span><br><span class="line"><span class="comment">// Usage of ./command-line-flags:</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="环境变量-未懂"><a href="#环境变量-未懂" class="headerlink" title="环境变量(未懂)"></a>环境变量(未懂)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用 os.Setenv 来设置一个键值队。使用 os.Getenv获取一个键对应的值。如果键不存在，将会返回一个空字符串。</span></span><br><span class="line">	os.Setenv(<span class="string">"FOO"</span>, <span class="string">"1"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"FOO:"</span>, os.Getenv(<span class="string">"FOO"</span>))</span><br><span class="line">	fmt.Println(<span class="string">"BAR:"</span>, os.Getenv(<span class="string">"BAR"</span>))</span><br><span class="line">	<span class="comment">// 使用 os.Environ 来列出所有环境变量键值队。这个函数会返回一个 KEY=value 形式的字符串切片。你可以使用strings.Split 来得到键和值。这里我们打印所有的键。</span></span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="keyword">for</span> _, e := <span class="keyword">range</span> os.Environ() &#123;</span><br><span class="line">		pair := strings.Split(e, <span class="string">"="</span>)</span><br><span class="line">		fmt.Println(pair[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行这个程序，显示我们在程序中设置的 FOO 的值，然而没有设置的 BAR 是空的。</span></span><br><span class="line"><span class="comment">// $ go run environment-variables.go</span></span><br><span class="line"><span class="comment">// FOO: 1</span></span><br><span class="line"><span class="comment">// BAR:</span></span><br><span class="line"><span class="comment">// 键的列表是由你的电脑情况而定的。</span></span><br><span class="line"><span class="comment">// TERM_PROGRAM</span></span><br><span class="line"><span class="comment">// PATH</span></span><br><span class="line"><span class="comment">// SHELL</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 如果我们在运行前设置了 BAR 的值，那么运行程序将会获取到这个值。</span></span><br><span class="line"><span class="comment">// $ BAR=2 go run environment-variables.go</span></span><br><span class="line"><span class="comment">// FOO: 1</span></span><br><span class="line"><span class="comment">// BAR: 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="执行外部进程"><a href="#执行外部进程" class="headerlink" title="执行外部进程"></a>执行外部进程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 我们将从一个简单的命令开始，没有参数或者输入，仅打印一些信息到标准输出流。exec.Command 函数帮助我们创建一个表示这个外部进程的对象。</span></span><br><span class="line">	dateCmd := exec.Command(<span class="string">"date"</span>)</span><br><span class="line">	<span class="comment">// .Output 是另一个帮助我们处理运行一个命令的常见情况的函数，它等待命令运行完成，并收集命令的输出。如果没有出错，dateOut 将获取到日期信息的字节。</span></span><br><span class="line">	dateOut, err := dateCmd.Output()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"&gt; date"</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(dateOut))</span><br><span class="line">	<span class="comment">// 下面我们将看看一个稍复杂的例子，我们将从外部进程的stdin 输入数据并从 stdout 收集结果。</span></span><br><span class="line">	grepCmd := exec.Command(<span class="string">"grep"</span>, <span class="string">"hello"</span>)</span><br><span class="line">	<span class="comment">// 这里我们明确的获取输入/输出管道，运行这个进程，写入一些输入信息，读取输出的结果，最后等待程序运行结束。</span></span><br><span class="line">	grepIn, _ := grepCmd.StdinPipe()</span><br><span class="line">	grepOut, _ := grepCmd.StdoutPipe()</span><br><span class="line">	grepCmd.Start()</span><br><span class="line">	grepIn.Write([]<span class="keyword">byte</span>(<span class="string">"hello grep\ngoodbye grep"</span>))</span><br><span class="line">	grepIn.Close()</span><br><span class="line">	grepBytes, _ := ioutil.ReadAll(grepOut)</span><br><span class="line">	grepCmd.Wait()</span><br><span class="line">	<span class="comment">// 上面的例子中，我们忽略了错误检测，但是你可以使用if err != nil 的方式来进行错误检查，我们也只收集StdoutPipe 的结果，但是你可以使用相同的方法收集StderrPipe 的结果。</span></span><br><span class="line">	fmt.Println(<span class="string">"&gt; grep hello"</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(grepBytes))</span><br><span class="line">	<span class="comment">// 注意，当我们需要提供一个明确的命令和参数数组来生成命令，和能够只需要提供一行命令行字符串相比，你想使用通过一个字符串生成一个完整的命令，那么你可以使用 bash命令的 -c 选项：</span></span><br><span class="line">	lsCmd := exec.Command(<span class="string">"bash"</span>, <span class="string">"-c"</span>, <span class="string">"ls -a -l -h"</span>)</span><br><span class="line">	lsOut, err := lsCmd.Output()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"&gt; ls -a -l -h"</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(lsOut))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="替换执行进程"><a href="#替换执行进程" class="headerlink" title="替换执行进程"></a>替换执行进程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 有时候只想 用其他的（也许是非 Go 程序）来完全替代当前的 Go 进程</span></span><br><span class="line">	<span class="comment">// 在我们的例子中，我们将执行 ls 命令。Go 需要提供我 们需要执行的可执行文件的绝对路径，所以我们将使用 exec.LookPath 来得到它（大概是 /bin/ls）。</span></span><br><span class="line">	binary, lookErr := exec.LookPath(<span class="string">"ls"</span>)</span><br><span class="line">	<span class="keyword">if</span> lookErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(lookErr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Exec 需要的参数是切片的形式的（不是放在一起的一个大字 符串）。我们给 ls 一些基本的参数。注意，第一个参数需要 是程序名。</span></span><br><span class="line">	args := []<span class="keyword">string</span>&#123;<span class="string">"ls"</span>, <span class="string">"-a"</span>, <span class="string">"-l"</span>, <span class="string">"-h"</span>&#125;</span><br><span class="line">	<span class="comment">// Exec 同样需要使用环境变量。 这里我们仅提供当前的环境变量。</span></span><br><span class="line">	env := os.Environ()</span><br><span class="line">	<span class="comment">// 这里是 os.Exec 调用。如果这个调用成功，那么我们的 进程将在这里被替换成 /bin/ls -a -l -h 进程。如果存 在错误，那么我们将会得到一个返回值。</span></span><br><span class="line">	execErr := syscall.Exec(binary, args, env)</span><br><span class="line">	<span class="keyword">if</span> execErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(execErr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 运行程序时，它会替换为 ls</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Go 通过向一个通道发送 os.Signal 值来进行信号通知。我们 将创建一个通道来接收这些通知（同时还创建一个用于在程序可 以结束时进行通知的通道）。</span></span><br><span class="line">	sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// signal.Notify 注册这个给定的通道用于接收特定信号。</span></span><br><span class="line">	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">	<span class="comment">// 这个 Go 协程执行一个阻塞的信号接收操作。当它得到一个 值时，它将打印这个值，然后通知程序可以退出。</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		sig := &lt;-sigs</span><br><span class="line">		fmt.Println()</span><br><span class="line">		fmt.Println(sig)</span><br><span class="line">		done &lt;- <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 程序将在这里进行等待，直到它得到了期望的信号（也就 是上面的 Go 协程发送的 done 值）然后退出。</span></span><br><span class="line">	fmt.Println(<span class="string">"awaiting signal"</span>)</span><br><span class="line">	&lt;-done</span><br><span class="line">	fmt.Println(<span class="string">"exiting"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们运行这个程序时，它将一直等待一个信号。使用 ctrl-C （终端显示为 ^C），我们可以发送一个 SIGINT 信号，这会 使程序打印 interrupt 然后退出。</span></span><br><span class="line"><span class="comment">// $ go run signals.go</span></span><br><span class="line"><span class="comment">// awaiting signal</span></span><br><span class="line"><span class="comment">// ^C</span></span><br><span class="line"><span class="comment">// interrupt</span></span><br><span class="line"><span class="comment">// exiting</span></span><br></pre></td></tr></table></figure>
<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 当使用 os.Exit 时 defer 将不会 执行，所以这里的 fmt.Println 将永远不会被调用。</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"!"</span>)</span><br><span class="line">	<span class="comment">// 退出并且退出状态为 3。</span></span><br><span class="line">	os.Exit(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 后端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[photoshop简单学习]]></title>
      <url>/2017/09/26/photoshop%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p><code>photoshop</code>一直觉得是一门十分实用的技能,了解一下很有必要<br>随着深入学习,此篇文章持续更新…</p>
<a id="more"></a>
<h3 id="初始化设置"><a href="#初始化设置" class="headerlink" title="初始化设置"></a>初始化设置</h3><ul>
<li>web常用格式一般是<code>高度不固定,宽度1920</code>等按需设置,背景为<code>透明</code></li>
<li>首选项-<code>单位与标尺</code>-全部改为<code>像素</code></li>
<li>视图里面 显示-<code>智能参考线</code> 打钩 <code>标尺</code>  打钩</li>
<li>右边界面4大功能   上面<code>字符信息</code>  下面<code>图层历史记录</code></li>
<li>信息界面面板选项改为<code>rpg</code>颜色模式 标尺为<code>像素</code> <code>文档尺寸</code>勾选</li>
</ul>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul>
<li>Windows 系统：Ctrl + Shift + Alt + E</li>
<li>Mac OS 系统：Cmd + Shift + Opt + E</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">功能介绍</th>
<th style="text-align:left">快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">新建文件</td>
<td style="text-align:left">Ctrl + N</td>
</tr>
<tr>
<td style="text-align:left">新建图层</td>
<td style="text-align:left">Ctrl + Shift + N（按住Alt可避免对话框)</td>
</tr>
<tr>
<td style="text-align:left">复制图层</td>
<td style="text-align:left">Ctrl + J</td>
</tr>
<tr>
<td style="text-align:left">选中多个图层</td>
<td style="text-align:left">Shift + 单击鼠标左键</td>
</tr>
<tr>
<td style="text-align:left">合并选中图层</td>
<td style="text-align:left">Ctrl + E</td>
</tr>
<tr>
<td style="text-align:left">合并所有可见图层</td>
<td style="text-align:left">Ctrl + Shift + Alt + E</td>
</tr>
<tr>
<td style="text-align:left">对选中图层编组</td>
<td style="text-align:left">Ctrl + G/双击可改名字</td>
</tr>
<tr>
<td style="text-align:left">载入选区</td>
<td style="text-align:left">Ctrl + 左键点击(元素或图层缩略图)</td>
</tr>
<tr>
<td style="text-align:left">取消选区</td>
<td style="text-align:left">Ctrl + D</td>
</tr>
<tr>
<td style="text-align:left">选择全部</td>
<td style="text-align:left">Ctrl + A</td>
</tr>
<tr>
<td style="text-align:left">重做最后一项选择</td>
<td style="text-align:left">Ctrl + Shift + D</td>
</tr>
<tr>
<td style="text-align:left">加选取框,减选取框</td>
<td style="text-align:left"><code>M</code>,Shift,Alt</td>
</tr>
<tr>
<td style="text-align:left">正选取框,同心选取框</td>
<td style="text-align:left"><code>M</code>选取后Shift(正)Alt(同)</td>
</tr>
<tr>
<td style="text-align:left">选择反选</td>
<td style="text-align:left">Ctrl + Shift + I</td>
</tr>
<tr>
<td style="text-align:left">删除所选元素</td>
<td style="text-align:left"><code>delete</code></td>
</tr>
<tr>
<td style="text-align:left">自由变换（缩放、斜切）</td>
<td style="text-align:left">Ctrl + T</td>
</tr>
<tr>
<td style="text-align:left">约束比例或从中心变换</td>
<td style="text-align:left"><code>Shift</code>=约束 或 <code>Alt</code>=中心</td>
</tr>
<tr>
<td style="text-align:left">添加到选区或从选区减去</td>
<td style="text-align:left">拖动时按住 Shift 或者 Alt</td>
</tr>
<tr>
<td style="text-align:left">填充图层/选区颜色</td>
<td style="text-align:left">Alt + Delete</td>
</tr>
<tr>
<td style="text-align:left">设置画笔颜色</td>
<td style="text-align:left">Alt + 单击左键选取示例色</td>
</tr>
<tr>
<td style="text-align:left">扩大/减小选框大小</td>
<td style="text-align:left"><code>[</code> = 缩小大小  <code>]</code> = 扩大大小</td>
</tr>
<tr>
<td style="text-align:left">撤销上一步/后退一步</td>
<td style="text-align:left">Ctrl + Z，Ctrl + Alt + Z</td>
</tr>
<tr>
<td style="text-align:left">放大/缩小</td>
<td style="text-align:left">Ctrl + “+” 或 Ctrl + “-“</td>
</tr>
<tr>
<td style="text-align:left">按屏幕大小缩放</td>
<td style="text-align:left">Ctrl + 0</td>
</tr>
<tr>
<td style="text-align:left">默认前景/背景色</td>
<td style="text-align:left">D</td>
</tr>
<tr>
<td style="text-align:left">对调前景/背景色</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">显示/隐藏 网格、参考线</td>
<td style="text-align:left">Ctrl + <code>&#39;</code>,Ctrl + <code>;</code></td>
</tr>
<tr>
<td style="text-align:left">复制该选区为新图层</td>
<td style="text-align:left">按住Alt同时拖动选区</td>
</tr>
<tr>
<td style="text-align:left">文件输出为web格式</td>
<td style="text-align:left">Ctrl + Shift + Alt + S</td>
</tr>
<tr>
<td style="text-align:left">文件存储为</td>
<td style="text-align:left">Ctrl + Shift + S</td>
</tr>
<tr>
<td style="text-align:left">关闭当前文档</td>
<td style="text-align:left">Ctrl + W</td>
</tr>
</tbody>
</table>
<h3 id="切图"><a href="#切图" class="headerlink" title="切图"></a>切图</h3><ul>
<li>一般方法:<br>可通过把整张图裁剪成一张张模块化小图,然后设置参考线,基于参考线自动切图,导出后可选择导出单张切图和所有切图</li>
</ul>
<ul>
<li>脚本方法:<br>文件-导出-将图层导出到文件选择PNG-24(8)勾选全部 自动切图导出</li>
</ul>
<ul>
<li>简化方法:<br>首选项-增效工具-启用生成器<br>文件-生成-图像资源(勾选)<br>设置之后会多一个同名文件夹,将想要使用的图层图像命名为相应格式(jpg,png)以后,可以在这个文件夹中看到保存的相应格式文件。<br>通过命名可以更改保存文件的样式,例如<br>命名200%-像素大小扩大一倍<br>jpg8就保存品质80%(只有jpg有品质选项)<br>png8就保存png-8</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 杂货铺 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ps </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[css学习]]></title>
      <url>/2017/09/18/css%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>对于css的学习,感谢<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">MDN</a>与<a href="http://www.w3school.com.cn/css/index.asp" target="_blank" rel="noopener">W3school</a>提供的优秀资料<br>随着深入学习,此篇文章持续更新…</p>
<a id="more"></a>
<h3 id="媒体查询-响应式开发"><a href="#媒体查询-响应式开发" class="headerlink" title="媒体查询-响应式开发"></a>媒体查询-响应式开发</h3><p>响应式设计就是一套 CSS 根据当前的分辨率选择不同的样式<br>媒体查询主要用来:</p>
<ul>
<li>检测媒体的类型, 比如 screen, tv等</li>
<li>检测布局视口的特性, 比如视口的宽高分辨率等</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">@media all and (min-width: 200px) and (max-width: 300px)&#123;</span></span><br><span class="line"><span class="undefined">    body &#123;</span></span><br><span class="line"><span class="undefined">        background: red;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">/* 网易移动端字体设置 */</span></span><br><span class="line"><span class="undefined">@media screen and (max-width: 321px) &#123;</span></span><br><span class="line"><span class="undefined">    body &#123;</span></span><br><span class="line"><span class="undefined">        font-size:16px</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">@media screen and (min-width: 321px) and (max-width:400px) &#123;</span></span><br><span class="line"><span class="undefined">    body &#123;</span></span><br><span class="line"><span class="undefined">        font-size:17px</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">@media screen and (min-width: 400px) &#123;</span></span><br><span class="line"><span class="undefined">    body &#123;</span></span><br><span class="line"><span class="undefined">        font-size:19px</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中, all 是媒体类型, 代表任何设备<br>and 是逻辑操作<br>意思是, 对于任何设备, 在宽度在 200-300 的范围内应用这个样式</p>
<hr>
<h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a><a href="http://www.w3school.com.cn/css/css_pseudo_classes.asp" target="_blank" rel="noopener">伪类</a></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>   &#123; <span class="attribute">color</span>: white; <span class="attribute">text-decoration</span>: none; &#125; <span class="comment">/*未访问--去下划线*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123; <span class="attribute">color</span>: black; &#125; <span class="comment">/*已访问--去下划线*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>  &#123; <span class="attribute">color</span>: red; <span class="attribute">cursor</span>: pointer; &#125; <span class="comment">/*悬停--鼠标样式*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123; <span class="attribute">color</span>: lightblue; &#125; <span class="comment">/*选定*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.class</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>: white;&#125;    <span class="comment">/* 独立伪类 */</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="定位-position"><a href="#定位-position" class="headerlink" title="定位 position"></a>定位 <a href="http://www.w3school.com.cn/cssref/pr_class_position.asp" target="_blank" rel="noopener">position</a></h3><table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">static</td>
<td style="text-align:left">默认 <code>static</code></td>
</tr>
<tr>
<td style="text-align:left">relative</td>
<td style="text-align:left">相对定位 可相对自身偏移</td>
</tr>
<tr>
<td style="text-align:left">absolute</td>
<td style="text-align:left">完全绝对定位, 忽略其他所有东西, 往上浮动到 非 static 的元素</td>
</tr>
<tr>
<td style="text-align:left">fixed</td>
<td style="text-align:left">基于 <code>window</code> 的绝对定位, 不随页面滚动改变</td>
</tr>
</tbody>
</table>
<p><strong>非 <code>static</code> 元素可以用 <code>top left bottom right</code> 属性来设置坐标</strong><br><strong>非 <code>static</code> 元素可以用 <code>z-index</code> 属性来设置显示层次</strong></p>
<ul>
<li>e.pageX——相对整个页面的坐标</li>
<li>e.clientX——相对可视区域的坐标</li>
<li>e.offsetX——相对当前坐标系的border左上角开始的坐标</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shell常用命令]]></title>
      <url>/2017/09/08/shell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p><code>shell</code>既是一种命令语言，又是一种程序设计语言,是用户使用Linux 的桥梁<br>随着深入学习,此篇文章持续更新…</p>
<a id="more"></a>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>条件表达式要放在方括号之间,并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]</li>
<li>单引号中变量无效转义符无效,双引号变量有效转义符有效</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 重新执行刚修改的文件,使立即成效</span><br><span class="line"><span class="meta">$</span> source [file]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打印,等同于log</span><br><span class="line"><span class="meta">$</span> echo ...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 可以传入参数 $0是脚本名 $1是1</span><br><span class="line"><span class="meta">$</span> sh file.sh 1 2 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 传入参数的个数  所有传入参数</span><br><span class="line"><span class="meta">$</span> echo $#  $*</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 上个命令的退出状态，或函数的返回值</span><br><span class="line"><span class="meta">$</span> echo $?</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID</span><br><span class="line"><span class="meta">$</span> echo $$</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> -e 开启转义  \n开启换行  \c不换行</span><br><span class="line"><span class="meta">$</span> echo -e "OK! \n"</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 定义变量,等号两边不可有空格</span><br><span class="line"><span class="meta">$</span> name="runoob.com"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置只读变量</span><br><span class="line"><span class="meta">$</span> readonly name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除变量</span><br><span class="line"><span class="meta">$</span> unset name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> name 接收标准输入的变量</span><br><span class="line"><span class="meta">$</span> read name</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 字符串拼接方法</span><br><span class="line"><span class="meta">$</span> greeting="hello, "$name" !"</span><br><span class="line"><span class="meta">$</span> greeting_1="hello, $&#123;name&#125; !"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取字符串长度</span><br><span class="line"><span class="meta">$</span> echo $&#123;#name&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 从字符串第 2 个字符开始截取 4 个字符</span><br><span class="line"><span class="meta">$</span> echo $&#123;name:1:4&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> *// 表示从左边开始删除第一个 // 号及左边的所有字符</span><br><span class="line"><span class="meta">$</span> echo $&#123;name#*//&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> ##表示从左边开始删除最右边一个/及左边的字符</span><br><span class="line"><span class="meta">$</span> echo $&#123;name##*/&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> %/* 表示从右边开始，删除第一个 / 号及右边的字符</span><br><span class="line"><span class="meta">$</span> echo $&#123;name%/*&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 定义数组</span><br><span class="line"><span class="meta">$</span> array_name=(value0 value1 value2 value3)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 读取数组</span><br><span class="line"><span class="meta">$</span> $&#123;数组名[下标]&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取所有数组</span><br><span class="line"><span class="meta">$</span> $&#123;array_name[*]&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取数组长度</span><br><span class="line"><span class="meta">$</span> length=$&#123;#array_name[*]&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取某个数组元素长度</span><br><span class="line"><span class="meta">$</span> lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> MAC 中 shell 的 expr 语法是：$((表达式))</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> expr 运算符</span><br><span class="line">+ - * / % = == !=</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 非运算 或运算 与运算</span><br><span class="line">! -o  '-a &amp;&amp;'</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Mac-OSX-命令行"><a href="#Mac-OSX-命令行" class="headerlink" title="Mac OSX 命令行"></a>Mac OSX 命令行</h3><h4 id="一些常用命令"><a href="#一些常用命令" class="headerlink" title="一些常用命令"></a>一些常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 允许所有来源</span><br><span class="line"><span class="meta">$</span> sudo spctl --master-disable</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示隐藏文件</span><br><span class="line"><span class="meta">$</span> defaults write com.apple.finder AppleShowAllFiles -bool true killall Finder</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 恢复文件隐藏</span><br><span class="line"><span class="meta">$</span> defaults write com.apple.finder AppleShowAllFiles -bool false killall Finder</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 标题栏显示完整路径</span><br><span class="line"><span class="meta">$</span> defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES killall Finder</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 标题栏显示当前路径</span><br><span class="line"><span class="meta">$</span> defaults write com.apple.finder _FXShowPosixPathInTitle -bool NO killall Finder</span><br></pre></td></tr></table></figure>
<h4 id="快捷命令"><a href="#快捷命令" class="headerlink" title="快捷命令"></a>快捷命令</h4><table>
<thead>
<tr>
<th style="text-align:center">功能说明</th>
<th style="text-align:center">快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">查询目录文件</td>
<td style="text-align:center">ls -a(所有)</td>
</tr>
<tr>
<td style="text-align:center">转换目录</td>
<td style="text-align:center">cd</td>
</tr>
<tr>
<td style="text-align:center">转换到根目录</td>
<td style="text-align:center">cd /</td>
</tr>
<tr>
<td style="text-align:center">转换到上一级目录</td>
<td style="text-align:center">cd ..</td>
</tr>
<tr>
<td style="text-align:center">显示当前目录路径</td>
<td style="text-align:center">pwd</td>
</tr>
<tr>
<td style="text-align:center">新建一个文件</td>
<td style="text-align:center">touch</td>
</tr>
<tr>
<td style="text-align:center">建立新目录</td>
<td style="text-align:center">mkdir</td>
</tr>
<tr>
<td style="text-align:center">打开文件</td>
<td style="text-align:center">open</td>
</tr>
<tr>
<td style="text-align:center">删除一个目录</td>
<td style="text-align:center">rmdir</td>
</tr>
<tr>
<td style="text-align:center">拷贝文件</td>
<td style="text-align:center">cp</td>
</tr>
<tr>
<td style="text-align:center">删除文件</td>
<td style="text-align:center">rm</td>
</tr>
<tr>
<td style="text-align:center">移动文件</td>
<td style="text-align:center">mv</td>
</tr>
<tr>
<td style="text-align:center">显示文件类型</td>
<td style="text-align:center">file</td>
</tr>
<tr>
<td style="text-align:center">显示进程状态</td>
<td style="text-align:center">ps</td>
</tr>
<tr>
<td style="text-align:center">终止进程</td>
<td style="text-align:center">kill</td>
</tr>
<tr>
<td style="text-align:center">显示当前时间</td>
<td style="text-align:center">date</td>
</tr>
<tr>
<td style="text-align:center">显示日历</td>
<td style="text-align:center">cal</td>
</tr>
<tr>
<td style="text-align:center">统计程序的执行时间</td>
<td style="text-align:center">time</td>
</tr>
<tr>
<td style="text-align:center">显示操作系统信息</td>
<td style="text-align:center">uname -a</td>
</tr>
<tr>
<td style="text-align:center">清除屏幕信息</td>
<td style="text-align:center">clear</td>
</tr>
<tr>
<td style="text-align:center">终止操作</td>
<td style="text-align:center">Ctrl + c</td>
</tr>
<tr>
<td style="text-align:center">光标回到命令行首(尾)</td>
<td style="text-align:center">Ctrl + a(e)</td>
</tr>
<tr>
<td style="text-align:center">删除光标处到行首(尾)的字符</td>
<td style="text-align:center">Ctrl + w(k)</td>
</tr>
<tr>
<td style="text-align:center">删除整个命令行文本字符</td>
<td style="text-align:center">Ctrl + u</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 杂货铺 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[html学习]]></title>
      <url>/2017/08/24/html%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>对于html的学习,感谢<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML" target="_blank" rel="noopener">MDN</a>与<a href="http://www.w3school.com.cn/html/index.asp" target="_blank" rel="noopener">W3school</a>提供的优秀资料<br>随着深入学习,此篇文章持续更新…</p>
<a id="more"></a>
<h3 id="移动端设置"><a href="#移动端设置" class="headerlink" title="移动端设置"></a>移动端设置</h3><p>设置 viewport<br>viewport 是 html 的父元素<br>在手机上需要用下面的语句设置它的尺寸</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">//设置rem</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.documentElement.style.fontSize </span></span><br><span class="line"><span class="javascript">= <span class="built_in">document</span>.documentElement.clientWidth / <span class="number">7.5</span>(iPhone6相对宽度) + <span class="string">'px'</span>;</span></span><br><span class="line"><span class="actionscript"><span class="comment">//通过设计图宽度 / 100 来得出相对宽度 rem</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">//比如iphone5 设计图宽度640 相对宽度 6.4</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">width=device-width</td>
<td style="text-align:left">宽度等于设备宽度</td>
</tr>
<tr>
<td style="text-align:left">height=device-height</td>
<td style="text-align:left">高度等于设备宽度</td>
</tr>
<tr>
<td style="text-align:left">initial-scale</td>
<td style="text-align:left">初始缩放比例</td>
</tr>
<tr>
<td style="text-align:left">minimum-scale</td>
<td style="text-align:left">允许用户缩放的最小比例</td>
</tr>
<tr>
<td style="text-align:left">maximum-scale</td>
<td style="text-align:left">允许用户缩放的最大比例</td>
</tr>
<tr>
<td style="text-align:left">user-scalable</td>
<td style="text-align:left">是否允许用户缩放</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="icon设置"><a href="#icon设置" class="headerlink" title="icon设置"></a>icon设置</h3><p>直接在<code>index.html</code>同文件夹放置<code>favicon.ico</code>图片或者:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"img"</span> <span class="attr">type</span>=<span class="string">"image/x-icon"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="视频音频标签"><a href="#视频音频标签" class="headerlink" title="视频音频标签"></a>视频音频标签</h3><p>带控制器的视频标签, 不同浏览器有不同的文件格式要求<br>所以用 2 个 source 标签指定不同的视频格式</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"200"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.mp4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.ogv"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>带控制器的音频标签, 不同浏览器有不同的文件格式要求<br>所以用 2 个 source 标签指定不同的音频格式</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">id</span>=<span class="string">'id-audio-player'</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"audio.ogg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"audio.mp3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span> &gt;</span></span><br></pre></td></tr></table></figure>
<p>audio 基本操作如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.querySelector(<span class="string">'#id-audio-player'</span>)</span><br><span class="line">a.play()                <span class="comment">//播放</span></span><br><span class="line">a.pause()               <span class="comment">//暂停</span></span><br><span class="line">a.autoplay              <span class="comment">//自动播放 (设为true) </span></span><br><span class="line">a.src                   <span class="comment">//链接音频文件</span></span><br><span class="line">a.volume                <span class="comment">//音量（0-1之间的数）</span></span><br><span class="line">a.duration              <span class="comment">//音频时间长度</span></span><br><span class="line">a.currentTime = <span class="number">1</span>       <span class="comment">//现在播放第几s（设置）</span></span><br><span class="line">a.playbackRate          <span class="comment">// 播放速率, 默认是 1</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> html </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git常用命令(转)]]></title>
      <url>/2017/08/10/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>本文转载至<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">阮一峰</a>,感谢阮老师一直以来的优秀分享</p>
<p>git是一种分布式的版本管理工具<br>可通过<strong>ssh</strong> <strong>token</strong>来管理权限问题</p>
<a id="more"></a>
<h4 id="git名词解释与命令说明"><a href="#git名词解释与命令说明" class="headerlink" title="git名词解释与命令说明"></a>git名词解释与命令说明</h4><ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<h4 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init [project-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载一个项目和它的整个代码历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [url]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载一个项目分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> -b [dev] [url]</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [dir]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -p</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git mv [file-original] [file-renamed]</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [dir]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -p</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git mv [file-original] [file-renamed]</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit [file1] [file2] ... -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1] [file2] ...</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支和远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch] [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --track [branch] [remote-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定分支，并更新工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到上一个分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并指定分支到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择一个commit，合并进当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在当前commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag] [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/[tagName]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看tag信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交指定tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --tags</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向某个tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch] [tag]</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示有变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的版本历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索提交历史，根据关键词</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，其<span class="string">"提交说明"</span>必须符合搜索条件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git whatchanged [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件相关的每一次diff</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示过去5次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和工作区的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和上一个commit的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示两次提交之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示今天你写了多少行代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交的元数据和内容变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交发生变化的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交时，某个文件的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的最近几次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载远程仓库的所有变动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch [remote]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个远程仓库的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show [remote]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加一个新的远程仓库，并命名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add [shortname] [url]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull [remote] [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传本地指定分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --force</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送所有分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --all</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的指定文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [commit] [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的所有文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git revert [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成一个可供发布的压缩包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git archive</span></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      
        <categories>
            
            <category> 杂货铺 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[博客开通]]></title>
      <url>/2017/08/01/%E5%8D%9A%E5%AE%A2%E5%BC%80%E9%80%9A/</url>
      <content type="html"><![CDATA[<p>本博客使用<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>搭建,主题使用<a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">Cho</a><br>搭建于<a href="https://pages.github.com/" target="_blank" rel="noopener">github pages</a>,感谢开源社区</p>
<h2 id="hexo框架说明"><a href="#hexo框架说明" class="headerlink" title="hexo框架说明"></a><code>hexo</code>框架说明</h2><p><strong><code>hexo</code>依赖于node与git</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<h3 id="新建目录"><a href="#新建目录" class="headerlink" title="新建目录"></a>新建目录</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── <span class="selector-tag">_config</span><span class="selector-class">.yml</span>(配置文件)</span><br><span class="line">├── <span class="selector-tag">package</span><span class="selector-class">.json</span></span><br><span class="line">├── <span class="selector-tag">scaffolds</span>(新建文件模板)</span><br><span class="line">├── <span class="selector-tag">source</span>(资源存放文件夹,ico和CNAME可放此处)</span><br><span class="line">├── <span class="selector-tag">public</span>(生成的静态文件放在这里)</span><br><span class="line">├── <span class="selector-class">.deploy_git</span>(服务器开启时启用的文件放在这里)</span><br><span class="line">|   ├── <span class="selector-tag">_drafts</span>(草稿文件,默认忽略)</span><br><span class="line">|   └── <span class="selector-tag">_posts</span>(文章文件夹)</span><br><span class="line">└── <span class="selector-tag">themes</span>(hexo 根据主题生成静态页面)</span><br></pre></td></tr></table></figure>
<h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a><code>_config.yml</code></h3><table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">title</td>
<td style="text-align:center">标题</td>
</tr>
<tr>
<td style="text-align:center">subtitle</td>
<td style="text-align:center">副标题</td>
</tr>
<tr>
<td style="text-align:center">description</td>
<td style="text-align:center">网站描述</td>
</tr>
<tr>
<td style="text-align:center">author</td>
<td style="text-align:center">名字</td>
</tr>
<tr>
<td style="text-align:center">language</td>
<td style="text-align:center">语言</td>
</tr>
<tr>
<td style="text-align:center">timezone</td>
<td style="text-align:center">时区</td>
</tr>
<tr>
<td style="text-align:center">url</td>
<td style="text-align:center">网址</td>
</tr>
<tr>
<td style="text-align:center">root</td>
<td style="text-align:center">根目录</td>
</tr>
<tr>
<td style="text-align:center">permalink</td>
<td style="text-align:center">文章的 <code>永久链接</code> 格式</td>
</tr>
<tr>
<td style="text-align:center">theme</td>
<td style="text-align:center">当前主题名称</td>
</tr>
<tr>
<td style="text-align:center">deploy</td>
<td style="text-align:center">扩展</td>
</tr>
<tr>
<td style="text-align:center">default_layout</td>
<td style="text-align:center">预设布局(默认<code>post</code>)</td>
</tr>
</tbody>
</table>
<h3 id="部署说明"><a href="#部署说明" class="headerlink" title="部署说明"></a>部署说明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> [layout] &lt;title&gt;  <span class="comment">// 无 `layout` 使用默认设置</span></span><br><span class="line">hexo generate (-d -w) <span class="comment">// 文件生成后立即部署网站|监视文件变动</span></span><br><span class="line">hexo g <span class="comment">//简写</span></span><br><span class="line">hexo publish [layout] &lt;filename&gt;  <span class="comment">// 发表草稿</span></span><br><span class="line">hexo server <span class="comment">// 开启热服务器</span></span><br><span class="line">hexo deploy <span class="comment">//部署</span></span><br><span class="line">hexo d  hexo s 简写</span><br><span class="line">hexo clean  <span class="comment">//清理缓存</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span>  <span class="comment">#依次执行每个deploy</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span> </span><br><span class="line"><span class="attr">  repository:</span> <span class="attr">https://github.com/blossom91/blossom91.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a><code>Front-matter</code></h3><table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">layout</td>
<td style="text-align:center">布局</td>
</tr>
<tr>
<td style="text-align:center">title</td>
<td style="text-align:center">标题</td>
</tr>
<tr>
<td style="text-align:center">date</td>
<td style="text-align:center">日期</td>
</tr>
<tr>
<td style="text-align:center">updated</td>
<td style="text-align:center">更新日期</td>
</tr>
<tr>
<td style="text-align:center">comments</td>
<td style="text-align:center">开启评论功能</td>
</tr>
<tr>
<td style="text-align:center">categories</td>
<td style="text-align:center">分类(有时序性)</td>
</tr>
<tr>
<td style="text-align:center">tags</td>
<td style="text-align:center">标签(无顺序性)</td>
</tr>
<tr>
<td style="text-align:center">toc</td>
<td style="text-align:center">theme特有 目录显示</td>
</tr>
<tr>
<td style="text-align:center">mathjax</td>
<td style="text-align:center">theme特有 数学符号</td>
</tr>
<tr>
<td style="text-align:center">layout: timeline</td>
<td style="text-align:center">theme特有 时间线</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="Cho-主题说明"><a href="#Cho-主题说明" class="headerlink" title="Cho 主题说明"></a><code>Cho</code> 主题说明</h2><p>感谢<a href="https://www.haomwei.com/" target="_blank" rel="noopener">屠城</a>优化的<code>cho</code>模板</p>
<p>评论系统使用<a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">gitment</a>感谢<a href="https://imsun.net/posts/gitment-introduction/" target="_blank" rel="noopener">孙士权</a>的创意</p>
<h3 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h3><p>文章内容中插入<code>&lt;!--more--&gt;</code>可以隐藏后面的内容,未设置自动引用第一段显示</p>
<h3 id="添加页面"><a href="#添加页面" class="headerlink" title="添加页面"></a>添加页面</h3><p>在根source目录下建立相应名称的文件夹，然后在文件夹中建立index.md文件<br><code>front-matter</code>设置<code>layout</code>:<code>page</code>|<code>single-column</code>(单页面)</p>
]]></content>
      
        <categories>
            
            <category> 杂货铺 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
